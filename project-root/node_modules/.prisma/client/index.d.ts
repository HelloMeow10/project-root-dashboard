
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model UsuarioInterno
 * 
 */
export type UsuarioInterno = $Result.DefaultSelection<Prisma.$UsuarioInternoPayload>
/**
 * Model TipoProducto
 * 
 */
export type TipoProducto = $Result.DefaultSelection<Prisma.$TipoProductoPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model Hospedaje
 * 
 */
export type Hospedaje = $Result.DefaultSelection<Prisma.$HospedajePayload>
/**
 * Model Pasaje
 * 
 */
export type Pasaje = $Result.DefaultSelection<Prisma.$PasajePayload>
/**
 * Model Alquiler
 * 
 */
export type Alquiler = $Result.DefaultSelection<Prisma.$AlquilerPayload>
/**
 * Model PaqueteDetalle
 * 
 */
export type PaqueteDetalle = $Result.DefaultSelection<Prisma.$PaqueteDetallePayload>
/**
 * Model Carrito
 * 
 */
export type Carrito = $Result.DefaultSelection<Prisma.$CarritoPayload>
/**
 * Model CarritoItem
 * 
 */
export type CarritoItem = $Result.DefaultSelection<Prisma.$CarritoItemPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model PedidoItem
 * 
 */
export type PedidoItem = $Result.DefaultSelection<Prisma.$PedidoItemPayload>
/**
 * Model Pago
 * 
 */
export type Pago = $Result.DefaultSelection<Prisma.$PagoPayload>
/**
 * Model ContactoInterno
 * 
 */
export type ContactoInterno = $Result.DefaultSelection<Prisma.$ContactoInternoPayload>
/**
 * Model Auto
 * 
 */
export type Auto = $Result.DefaultSelection<Prisma.$AutoPayload>
/**
 * Model Venta
 * 
 */
export type Venta = $Result.DefaultSelection<Prisma.$VentaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clientes
 * const clientes = await prisma.cliente.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarioInterno`: Exposes CRUD operations for the **UsuarioInterno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioInternos
    * const usuarioInternos = await prisma.usuarioInterno.findMany()
    * ```
    */
  get usuarioInterno(): Prisma.UsuarioInternoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoProducto`: Exposes CRUD operations for the **TipoProducto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoProductos
    * const tipoProductos = await prisma.tipoProducto.findMany()
    * ```
    */
  get tipoProducto(): Prisma.TipoProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hospedaje`: Exposes CRUD operations for the **Hospedaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospedajes
    * const hospedajes = await prisma.hospedaje.findMany()
    * ```
    */
  get hospedaje(): Prisma.HospedajeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pasaje`: Exposes CRUD operations for the **Pasaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pasajes
    * const pasajes = await prisma.pasaje.findMany()
    * ```
    */
  get pasaje(): Prisma.PasajeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alquiler`: Exposes CRUD operations for the **Alquiler** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alquilers
    * const alquilers = await prisma.alquiler.findMany()
    * ```
    */
  get alquiler(): Prisma.AlquilerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paqueteDetalle`: Exposes CRUD operations for the **PaqueteDetalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaqueteDetalles
    * const paqueteDetalles = await prisma.paqueteDetalle.findMany()
    * ```
    */
  get paqueteDetalle(): Prisma.PaqueteDetalleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carrito`: Exposes CRUD operations for the **Carrito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carritos
    * const carritos = await prisma.carrito.findMany()
    * ```
    */
  get carrito(): Prisma.CarritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carritoItem`: Exposes CRUD operations for the **CarritoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarritoItems
    * const carritoItems = await prisma.carritoItem.findMany()
    * ```
    */
  get carritoItem(): Prisma.CarritoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedidoItem`: Exposes CRUD operations for the **PedidoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoItems
    * const pedidoItems = await prisma.pedidoItem.findMany()
    * ```
    */
  get pedidoItem(): Prisma.PedidoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **Pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.PagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactoInterno`: Exposes CRUD operations for the **ContactoInterno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactoInternos
    * const contactoInternos = await prisma.contactoInterno.findMany()
    * ```
    */
  get contactoInterno(): Prisma.ContactoInternoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auto`: Exposes CRUD operations for the **Auto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos
    * const autos = await prisma.auto.findMany()
    * ```
    */
  get auto(): Prisma.AutoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venta`: Exposes CRUD operations for the **Venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventas
    * const ventas = await prisma.venta.findMany()
    * ```
    */
  get venta(): Prisma.VentaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cliente: 'Cliente',
    Rol: 'Rol',
    UsuarioInterno: 'UsuarioInterno',
    TipoProducto: 'TipoProducto',
    Producto: 'Producto',
    Hospedaje: 'Hospedaje',
    Pasaje: 'Pasaje',
    Alquiler: 'Alquiler',
    PaqueteDetalle: 'PaqueteDetalle',
    Carrito: 'Carrito',
    CarritoItem: 'CarritoItem',
    Pedido: 'Pedido',
    PedidoItem: 'PedidoItem',
    Pago: 'Pago',
    ContactoInterno: 'ContactoInterno',
    Auto: 'Auto',
    Venta: 'Venta'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cliente" | "rol" | "usuarioInterno" | "tipoProducto" | "producto" | "hospedaje" | "pasaje" | "alquiler" | "paqueteDetalle" | "carrito" | "carritoItem" | "pedido" | "pedidoItem" | "pago" | "contactoInterno" | "auto" | "venta"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      UsuarioInterno: {
        payload: Prisma.$UsuarioInternoPayload<ExtArgs>
        fields: Prisma.UsuarioInternoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioInternoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioInternoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          findFirst: {
            args: Prisma.UsuarioInternoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioInternoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          findMany: {
            args: Prisma.UsuarioInternoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>[]
          }
          create: {
            args: Prisma.UsuarioInternoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          createMany: {
            args: Prisma.UsuarioInternoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioInternoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>[]
          }
          delete: {
            args: Prisma.UsuarioInternoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          update: {
            args: Prisma.UsuarioInternoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioInternoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioInternoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioInternoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioInternoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioInternoPayload>
          }
          aggregate: {
            args: Prisma.UsuarioInternoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioInterno>
          }
          groupBy: {
            args: Prisma.UsuarioInternoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioInternoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioInternoCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioInternoCountAggregateOutputType> | number
          }
        }
      }
      TipoProducto: {
        payload: Prisma.$TipoProductoPayload<ExtArgs>
        fields: Prisma.TipoProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          findFirst: {
            args: Prisma.TipoProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          findMany: {
            args: Prisma.TipoProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>[]
          }
          create: {
            args: Prisma.TipoProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          createMany: {
            args: Prisma.TipoProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoProductoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>[]
          }
          delete: {
            args: Prisma.TipoProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          update: {
            args: Prisma.TipoProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          deleteMany: {
            args: Prisma.TipoProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoProductoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>[]
          }
          upsert: {
            args: Prisma.TipoProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProductoPayload>
          }
          aggregate: {
            args: Prisma.TipoProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoProducto>
          }
          groupBy: {
            args: Prisma.TipoProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoProductoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoProductoCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      Hospedaje: {
        payload: Prisma.$HospedajePayload<ExtArgs>
        fields: Prisma.HospedajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospedajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospedajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          findFirst: {
            args: Prisma.HospedajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospedajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          findMany: {
            args: Prisma.HospedajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>[]
          }
          create: {
            args: Prisma.HospedajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          createMany: {
            args: Prisma.HospedajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospedajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>[]
          }
          delete: {
            args: Prisma.HospedajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          update: {
            args: Prisma.HospedajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          deleteMany: {
            args: Prisma.HospedajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospedajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HospedajeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>[]
          }
          upsert: {
            args: Prisma.HospedajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospedajePayload>
          }
          aggregate: {
            args: Prisma.HospedajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospedaje>
          }
          groupBy: {
            args: Prisma.HospedajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospedajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospedajeCountArgs<ExtArgs>
            result: $Utils.Optional<HospedajeCountAggregateOutputType> | number
          }
        }
      }
      Pasaje: {
        payload: Prisma.$PasajePayload<ExtArgs>
        fields: Prisma.PasajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          findFirst: {
            args: Prisma.PasajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          findMany: {
            args: Prisma.PasajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>[]
          }
          create: {
            args: Prisma.PasajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          createMany: {
            args: Prisma.PasajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>[]
          }
          delete: {
            args: Prisma.PasajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          update: {
            args: Prisma.PasajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          deleteMany: {
            args: Prisma.PasajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasajeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>[]
          }
          upsert: {
            args: Prisma.PasajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasajePayload>
          }
          aggregate: {
            args: Prisma.PasajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasaje>
          }
          groupBy: {
            args: Prisma.PasajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasajeCountArgs<ExtArgs>
            result: $Utils.Optional<PasajeCountAggregateOutputType> | number
          }
        }
      }
      Alquiler: {
        payload: Prisma.$AlquilerPayload<ExtArgs>
        fields: Prisma.AlquilerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlquilerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlquilerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          findFirst: {
            args: Prisma.AlquilerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlquilerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          findMany: {
            args: Prisma.AlquilerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>[]
          }
          create: {
            args: Prisma.AlquilerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          createMany: {
            args: Prisma.AlquilerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlquilerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>[]
          }
          delete: {
            args: Prisma.AlquilerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          update: {
            args: Prisma.AlquilerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          deleteMany: {
            args: Prisma.AlquilerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlquilerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlquilerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>[]
          }
          upsert: {
            args: Prisma.AlquilerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlquilerPayload>
          }
          aggregate: {
            args: Prisma.AlquilerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlquiler>
          }
          groupBy: {
            args: Prisma.AlquilerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlquilerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlquilerCountArgs<ExtArgs>
            result: $Utils.Optional<AlquilerCountAggregateOutputType> | number
          }
        }
      }
      PaqueteDetalle: {
        payload: Prisma.$PaqueteDetallePayload<ExtArgs>
        fields: Prisma.PaqueteDetalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaqueteDetalleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaqueteDetalleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          findFirst: {
            args: Prisma.PaqueteDetalleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaqueteDetalleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          findMany: {
            args: Prisma.PaqueteDetalleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>[]
          }
          create: {
            args: Prisma.PaqueteDetalleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          createMany: {
            args: Prisma.PaqueteDetalleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaqueteDetalleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>[]
          }
          delete: {
            args: Prisma.PaqueteDetalleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          update: {
            args: Prisma.PaqueteDetalleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          deleteMany: {
            args: Prisma.PaqueteDetalleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaqueteDetalleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaqueteDetalleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>[]
          }
          upsert: {
            args: Prisma.PaqueteDetalleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteDetallePayload>
          }
          aggregate: {
            args: Prisma.PaqueteDetalleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaqueteDetalle>
          }
          groupBy: {
            args: Prisma.PaqueteDetalleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaqueteDetalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaqueteDetalleCountArgs<ExtArgs>
            result: $Utils.Optional<PaqueteDetalleCountAggregateOutputType> | number
          }
        }
      }
      Carrito: {
        payload: Prisma.$CarritoPayload<ExtArgs>
        fields: Prisma.CarritoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarritoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarritoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          findFirst: {
            args: Prisma.CarritoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarritoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          findMany: {
            args: Prisma.CarritoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>[]
          }
          create: {
            args: Prisma.CarritoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          createMany: {
            args: Prisma.CarritoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarritoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>[]
          }
          delete: {
            args: Prisma.CarritoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          update: {
            args: Prisma.CarritoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          deleteMany: {
            args: Prisma.CarritoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarritoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarritoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>[]
          }
          upsert: {
            args: Prisma.CarritoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>
          }
          aggregate: {
            args: Prisma.CarritoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrito>
          }
          groupBy: {
            args: Prisma.CarritoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarritoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarritoCountArgs<ExtArgs>
            result: $Utils.Optional<CarritoCountAggregateOutputType> | number
          }
        }
      }
      CarritoItem: {
        payload: Prisma.$CarritoItemPayload<ExtArgs>
        fields: Prisma.CarritoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarritoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarritoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          findFirst: {
            args: Prisma.CarritoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarritoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          findMany: {
            args: Prisma.CarritoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>[]
          }
          create: {
            args: Prisma.CarritoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          createMany: {
            args: Prisma.CarritoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarritoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>[]
          }
          delete: {
            args: Prisma.CarritoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          update: {
            args: Prisma.CarritoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          deleteMany: {
            args: Prisma.CarritoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarritoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarritoItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>[]
          }
          upsert: {
            args: Prisma.CarritoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarritoItemPayload>
          }
          aggregate: {
            args: Prisma.CarritoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarritoItem>
          }
          groupBy: {
            args: Prisma.CarritoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarritoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarritoItemCountArgs<ExtArgs>
            result: $Utils.Optional<CarritoItemCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PedidoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      PedidoItem: {
        payload: Prisma.$PedidoItemPayload<ExtArgs>
        fields: Prisma.PedidoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findFirst: {
            args: Prisma.PedidoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findMany: {
            args: Prisma.PedidoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          create: {
            args: Prisma.PedidoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          createMany: {
            args: Prisma.PedidoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          delete: {
            args: Prisma.PedidoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          update: {
            args: Prisma.PedidoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          deleteMany: {
            args: Prisma.PedidoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PedidoItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          upsert: {
            args: Prisma.PedidoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          aggregate: {
            args: Prisma.PedidoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedidoItem>
          }
          groupBy: {
            args: Prisma.PedidoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoItemCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemCountAggregateOutputType> | number
          }
        }
      }
      Pago: {
        payload: Prisma.$PagoPayload<ExtArgs>
        fields: Prisma.PagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findFirst: {
            args: Prisma.PagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findMany: {
            args: Prisma.PagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          create: {
            args: Prisma.PagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          createMany: {
            args: Prisma.PagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          delete: {
            args: Prisma.PagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          update: {
            args: Prisma.PagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          deleteMany: {
            args: Prisma.PagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          upsert: {
            args: Prisma.PagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.PagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoCountArgs<ExtArgs>
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      ContactoInterno: {
        payload: Prisma.$ContactoInternoPayload<ExtArgs>
        fields: Prisma.ContactoInternoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactoInternoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactoInternoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          findFirst: {
            args: Prisma.ContactoInternoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactoInternoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          findMany: {
            args: Prisma.ContactoInternoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>[]
          }
          create: {
            args: Prisma.ContactoInternoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          createMany: {
            args: Prisma.ContactoInternoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactoInternoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>[]
          }
          delete: {
            args: Prisma.ContactoInternoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          update: {
            args: Prisma.ContactoInternoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          deleteMany: {
            args: Prisma.ContactoInternoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactoInternoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactoInternoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>[]
          }
          upsert: {
            args: Prisma.ContactoInternoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactoInternoPayload>
          }
          aggregate: {
            args: Prisma.ContactoInternoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactoInterno>
          }
          groupBy: {
            args: Prisma.ContactoInternoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactoInternoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactoInternoCountArgs<ExtArgs>
            result: $Utils.Optional<ContactoInternoCountAggregateOutputType> | number
          }
        }
      }
      Auto: {
        payload: Prisma.$AutoPayload<ExtArgs>
        fields: Prisma.AutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          findFirst: {
            args: Prisma.AutoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          findMany: {
            args: Prisma.AutoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>[]
          }
          create: {
            args: Prisma.AutoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          createMany: {
            args: Prisma.AutoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>[]
          }
          delete: {
            args: Prisma.AutoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          update: {
            args: Prisma.AutoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          deleteMany: {
            args: Prisma.AutoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>[]
          }
          upsert: {
            args: Prisma.AutoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPayload>
          }
          aggregate: {
            args: Prisma.AutoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuto>
          }
          groupBy: {
            args: Prisma.AutoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoCountArgs<ExtArgs>
            result: $Utils.Optional<AutoCountAggregateOutputType> | number
          }
        }
      }
      Venta: {
        payload: Prisma.$VentaPayload<ExtArgs>
        fields: Prisma.VentaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          findFirst: {
            args: Prisma.VentaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          findMany: {
            args: Prisma.VentaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>[]
          }
          create: {
            args: Prisma.VentaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          createMany: {
            args: Prisma.VentaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>[]
          }
          delete: {
            args: Prisma.VentaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          update: {
            args: Prisma.VentaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          deleteMany: {
            args: Prisma.VentaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VentaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>[]
          }
          upsert: {
            args: Prisma.VentaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentaPayload>
          }
          aggregate: {
            args: Prisma.VentaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenta>
          }
          groupBy: {
            args: Prisma.VentaGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentaGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentaCountArgs<ExtArgs>
            result: $Utils.Optional<VentaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cliente?: ClienteOmit
    rol?: RolOmit
    usuarioInterno?: UsuarioInternoOmit
    tipoProducto?: TipoProductoOmit
    producto?: ProductoOmit
    hospedaje?: HospedajeOmit
    pasaje?: PasajeOmit
    alquiler?: AlquilerOmit
    paqueteDetalle?: PaqueteDetalleOmit
    carrito?: CarritoOmit
    carritoItem?: CarritoItemOmit
    pedido?: PedidoOmit
    pedidoItem?: PedidoItemOmit
    pago?: PagoOmit
    contactoInterno?: ContactoInternoOmit
    auto?: AutoOmit
    venta?: VentaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    carritos: number
    pedidos: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carritos?: boolean | ClienteCountOutputTypeCountCarritosArgs
    pedidos?: boolean | ClienteCountOutputTypeCountPedidosArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountCarritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarritoWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    usuarios: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | RolCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioInternoWhereInput
  }


  /**
   * Count Type TipoProductoCountOutputType
   */

  export type TipoProductoCountOutputType = {
    productos: number
  }

  export type TipoProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | TipoProductoCountOutputTypeCountProductosArgs
  }

  // Custom InputTypes
  /**
   * TipoProductoCountOutputType without action
   */
  export type TipoProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProductoCountOutputType
     */
    select?: TipoProductoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoProductoCountOutputType without action
   */
  export type TipoProductoCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }


  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    carritoItems: number
    paqueteDetallesAsPaquete: number
    paqueteDetallesAsProducto: number
    pedidoItems: number
  }

  export type ProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carritoItems?: boolean | ProductoCountOutputTypeCountCarritoItemsArgs
    paqueteDetallesAsPaquete?: boolean | ProductoCountOutputTypeCountPaqueteDetallesAsPaqueteArgs
    paqueteDetallesAsProducto?: boolean | ProductoCountOutputTypeCountPaqueteDetallesAsProductoArgs
    pedidoItems?: boolean | ProductoCountOutputTypeCountPedidoItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountCarritoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarritoItemWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountPaqueteDetallesAsPaqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteDetalleWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountPaqueteDetallesAsProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteDetalleWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountPedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }


  /**
   * Count Type CarritoCountOutputType
   */

  export type CarritoCountOutputType = {
    items: number
  }

  export type CarritoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CarritoCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CarritoCountOutputType without action
   */
  export type CarritoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoCountOutputType
     */
    select?: CarritoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarritoCountOutputType without action
   */
  export type CarritoCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarritoItemWhereInput
  }


  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    pagos: number
    items: number
    ventas: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagos?: boolean | PedidoCountOutputTypeCountPagosArgs
    items?: boolean | PedidoCountOutputTypeCountItemsArgs
    ventas?: boolean | PedidoCountOutputTypeCountVentasArgs
  }

  // Custom InputTypes
  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountVentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id_cliente: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id_cliente: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id_cliente: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    contrasena: string | null
    telefono: string | null
    direccion: string | null
    fecha_registro: Date | null
    activo: boolean | null
    email_verificado: boolean | null
    token_verificacion_email: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    id_cliente: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    contrasena: string | null
    telefono: string | null
    direccion: string | null
    fecha_registro: Date | null
    activo: boolean | null
    email_verificado: boolean | null
    token_verificacion_email: string | null
  }

  export type ClienteCountAggregateOutputType = {
    id_cliente: number
    nombre: number
    apellido: number
    email: number
    contrasena: number
    telefono: number
    direccion: number
    fecha_registro: number
    activo: number
    email_verificado: number
    token_verificacion_email: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id_cliente?: true
  }

  export type ClienteSumAggregateInputType = {
    id_cliente?: true
  }

  export type ClienteMinAggregateInputType = {
    id_cliente?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    fecha_registro?: true
    activo?: true
    email_verificado?: true
    token_verificacion_email?: true
  }

  export type ClienteMaxAggregateInputType = {
    id_cliente?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    fecha_registro?: true
    activo?: true
    email_verificado?: true
    token_verificacion_email?: true
  }

  export type ClienteCountAggregateInputType = {
    id_cliente?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    fecha_registro?: true
    activo?: true
    email_verificado?: true
    token_verificacion_email?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id_cliente: number
    nombre: string
    apellido: string | null
    email: string
    contrasena: string
    telefono: string | null
    direccion: string | null
    fecha_registro: Date
    activo: boolean
    email_verificado: boolean
    token_verificacion_email: string | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cliente?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    fecha_registro?: boolean
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: boolean
    carritos?: boolean | Cliente$carritosArgs<ExtArgs>
    pedidos?: boolean | Cliente$pedidosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cliente?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    fecha_registro?: boolean
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cliente?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    fecha_registro?: boolean
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id_cliente?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    fecha_registro?: boolean
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: boolean
  }

  export type ClienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_cliente" | "nombre" | "apellido" | "email" | "contrasena" | "telefono" | "direccion" | "fecha_registro" | "activo" | "email_verificado" | "token_verificacion_email", ExtArgs["result"]["cliente"]>
  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carritos?: boolean | Cliente$carritosArgs<ExtArgs>
    pedidos?: boolean | Cliente$pedidosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      carritos: Prisma.$CarritoPayload<ExtArgs>[]
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_cliente: number
      nombre: string
      apellido: string | null
      email: string
      contrasena: string
      telefono: string | null
      direccion: string | null
      fecha_registro: Date
      activo: boolean
      email_verificado: boolean
      token_verificacion_email: string | null
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id_cliente`
     * const clienteWithId_clienteOnly = await prisma.cliente.findMany({ select: { id_cliente: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id_cliente`
     * const clienteWithId_clienteOnly = await prisma.cliente.createManyAndReturn({
     *   select: { id_cliente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes and returns the data updated in the database.
     * @param {ClienteUpdateManyAndReturnArgs} args - Arguments to update many Clientes.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clientes and only return the `id_cliente`
     * const clienteWithId_clienteOnly = await prisma.cliente.updateManyAndReturn({
     *   select: { id_cliente: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carritos<T extends Cliente$carritosArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$carritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pedidos<T extends Cliente$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */
  interface ClienteFieldRefs {
    readonly id_cliente: FieldRef<"Cliente", 'Int'>
    readonly nombre: FieldRef<"Cliente", 'String'>
    readonly apellido: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly contrasena: FieldRef<"Cliente", 'String'>
    readonly telefono: FieldRef<"Cliente", 'String'>
    readonly direccion: FieldRef<"Cliente", 'String'>
    readonly fecha_registro: FieldRef<"Cliente", 'DateTime'>
    readonly activo: FieldRef<"Cliente", 'Boolean'>
    readonly email_verificado: FieldRef<"Cliente", 'Boolean'>
    readonly token_verificacion_email: FieldRef<"Cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Cliente updateManyAndReturn
   */
  export type ClienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to delete.
     */
    limit?: number
  }

  /**
   * Cliente.carritos
   */
  export type Cliente$carritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    where?: CarritoWhereInput
    orderBy?: CarritoOrderByWithRelationInput | CarritoOrderByWithRelationInput[]
    cursor?: CarritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[]
  }

  /**
   * Cliente.pedidos
   */
  export type Cliente$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id_rol: number | null
  }

  export type RolSumAggregateOutputType = {
    id_rol: number | null
  }

  export type RolMinAggregateOutputType = {
    id_rol: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type RolMaxAggregateOutputType = {
    id_rol: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type RolCountAggregateOutputType = {
    id_rol: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id_rol?: true
  }

  export type RolSumAggregateInputType = {
    id_rol?: true
  }

  export type RolMinAggregateInputType = {
    id_rol?: true
    nombre?: true
    descripcion?: true
  }

  export type RolMaxAggregateInputType = {
    id_rol?: true
    nombre?: true
    descripcion?: true
  }

  export type RolCountAggregateInputType = {
    id_rol?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id_rol: number
    nombre: string
    descripcion: string | null
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    nombre?: boolean
    descripcion?: boolean
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id_rol?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type RolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_rol" | "nombre" | "descripcion", ExtArgs["result"]["rol"]>
  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      usuarios: Prisma.$UsuarioInternoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_rol: number
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id_rol`
     * const rolWithId_rolOnly = await prisma.rol.findMany({ select: { id_rol: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rols and returns the data saved in the database.
     * @param {RolCreateManyAndReturnArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rols and only return the `id_rol`
     * const rolWithId_rolOnly = await prisma.rol.createManyAndReturn({
     *   select: { id_rol: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolCreateManyAndReturnArgs>(args?: SelectSubset<T, RolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols and returns the data updated in the database.
     * @param {RolUpdateManyAndReturnArgs} args - Arguments to update many Rols.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rols and only return the `id_rol`
     * const rolWithId_rolOnly = await prisma.rol.updateManyAndReturn({
     *   select: { id_rol: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolUpdateManyAndReturnArgs>(args: SelectSubset<T, RolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends Rol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */
  interface RolFieldRefs {
    readonly id_rol: FieldRef<"Rol", 'Int'>
    readonly nombre: FieldRef<"Rol", 'String'>
    readonly descripcion: FieldRef<"Rol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol createManyAndReturn
   */
  export type RolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol updateManyAndReturn
   */
  export type RolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to delete.
     */
    limit?: number
  }

  /**
   * Rol.usuarios
   */
  export type Rol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    where?: UsuarioInternoWhereInput
    orderBy?: UsuarioInternoOrderByWithRelationInput | UsuarioInternoOrderByWithRelationInput[]
    cursor?: UsuarioInternoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioInternoScalarFieldEnum | UsuarioInternoScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model UsuarioInterno
   */

  export type AggregateUsuarioInterno = {
    _count: UsuarioInternoCountAggregateOutputType | null
    _avg: UsuarioInternoAvgAggregateOutputType | null
    _sum: UsuarioInternoSumAggregateOutputType | null
    _min: UsuarioInternoMinAggregateOutputType | null
    _max: UsuarioInternoMaxAggregateOutputType | null
  }

  export type UsuarioInternoAvgAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type UsuarioInternoSumAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type UsuarioInternoMinAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    contrasena: string | null
    telefono: string | null
    activo: boolean | null
    id_rol: number | null
  }

  export type UsuarioInternoMaxAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    contrasena: string | null
    telefono: string | null
    activo: boolean | null
    id_rol: number | null
  }

  export type UsuarioInternoCountAggregateOutputType = {
    id_usuario: number
    nombre: number
    apellido: number
    email: number
    contrasena: number
    telefono: number
    activo: number
    id_rol: number
    _all: number
  }


  export type UsuarioInternoAvgAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type UsuarioInternoSumAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type UsuarioInternoMinAggregateInputType = {
    id_usuario?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    activo?: true
    id_rol?: true
  }

  export type UsuarioInternoMaxAggregateInputType = {
    id_usuario?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    activo?: true
    id_rol?: true
  }

  export type UsuarioInternoCountAggregateInputType = {
    id_usuario?: true
    nombre?: true
    apellido?: true
    email?: true
    contrasena?: true
    telefono?: true
    activo?: true
    id_rol?: true
    _all?: true
  }

  export type UsuarioInternoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioInterno to aggregate.
     */
    where?: UsuarioInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioInternos to fetch.
     */
    orderBy?: UsuarioInternoOrderByWithRelationInput | UsuarioInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioInternos
    **/
    _count?: true | UsuarioInternoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioInternoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioInternoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioInternoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioInternoMaxAggregateInputType
  }

  export type GetUsuarioInternoAggregateType<T extends UsuarioInternoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioInterno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioInterno[P]>
      : GetScalarType<T[P], AggregateUsuarioInterno[P]>
  }




  export type UsuarioInternoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioInternoWhereInput
    orderBy?: UsuarioInternoOrderByWithAggregationInput | UsuarioInternoOrderByWithAggregationInput[]
    by: UsuarioInternoScalarFieldEnum[] | UsuarioInternoScalarFieldEnum
    having?: UsuarioInternoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioInternoCountAggregateInputType | true
    _avg?: UsuarioInternoAvgAggregateInputType
    _sum?: UsuarioInternoSumAggregateInputType
    _min?: UsuarioInternoMinAggregateInputType
    _max?: UsuarioInternoMaxAggregateInputType
  }

  export type UsuarioInternoGroupByOutputType = {
    id_usuario: number
    nombre: string
    apellido: string | null
    email: string
    contrasena: string
    telefono: string | null
    activo: boolean
    id_rol: number
    _count: UsuarioInternoCountAggregateOutputType | null
    _avg: UsuarioInternoAvgAggregateOutputType | null
    _sum: UsuarioInternoSumAggregateOutputType | null
    _min: UsuarioInternoMinAggregateOutputType | null
    _max: UsuarioInternoMaxAggregateOutputType | null
  }

  type GetUsuarioInternoGroupByPayload<T extends UsuarioInternoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioInternoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioInternoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioInternoGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioInternoGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioInternoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    activo?: boolean
    id_rol?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioInterno"]>

  export type UsuarioInternoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    activo?: boolean
    id_rol?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioInterno"]>

  export type UsuarioInternoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    activo?: boolean
    id_rol?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioInterno"]>

  export type UsuarioInternoSelectScalar = {
    id_usuario?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    contrasena?: boolean
    telefono?: boolean
    activo?: boolean
    id_rol?: boolean
  }

  export type UsuarioInternoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_usuario" | "nombre" | "apellido" | "email" | "contrasena" | "telefono" | "activo" | "id_rol", ExtArgs["result"]["usuarioInterno"]>
  export type UsuarioInternoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type UsuarioInternoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type UsuarioInternoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $UsuarioInternoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioInterno"
    objects: {
      rol: Prisma.$RolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      nombre: string
      apellido: string | null
      email: string
      contrasena: string
      telefono: string | null
      activo: boolean
      id_rol: number
    }, ExtArgs["result"]["usuarioInterno"]>
    composites: {}
  }

  type UsuarioInternoGetPayload<S extends boolean | null | undefined | UsuarioInternoDefaultArgs> = $Result.GetResult<Prisma.$UsuarioInternoPayload, S>

  type UsuarioInternoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioInternoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioInternoCountAggregateInputType | true
    }

  export interface UsuarioInternoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioInterno'], meta: { name: 'UsuarioInterno' } }
    /**
     * Find zero or one UsuarioInterno that matches the filter.
     * @param {UsuarioInternoFindUniqueArgs} args - Arguments to find a UsuarioInterno
     * @example
     * // Get one UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioInternoFindUniqueArgs>(args: SelectSubset<T, UsuarioInternoFindUniqueArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuarioInterno that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioInternoFindUniqueOrThrowArgs} args - Arguments to find a UsuarioInterno
     * @example
     * // Get one UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioInternoFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioInternoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioInterno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoFindFirstArgs} args - Arguments to find a UsuarioInterno
     * @example
     * // Get one UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioInternoFindFirstArgs>(args?: SelectSubset<T, UsuarioInternoFindFirstArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioInterno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoFindFirstOrThrowArgs} args - Arguments to find a UsuarioInterno
     * @example
     * // Get one UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioInternoFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioInternoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuarioInternos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioInternos
     * const usuarioInternos = await prisma.usuarioInterno.findMany()
     * 
     * // Get first 10 UsuarioInternos
     * const usuarioInternos = await prisma.usuarioInterno.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioInternoWithId_usuarioOnly = await prisma.usuarioInterno.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends UsuarioInternoFindManyArgs>(args?: SelectSubset<T, UsuarioInternoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuarioInterno.
     * @param {UsuarioInternoCreateArgs} args - Arguments to create a UsuarioInterno.
     * @example
     * // Create one UsuarioInterno
     * const UsuarioInterno = await prisma.usuarioInterno.create({
     *   data: {
     *     // ... data to create a UsuarioInterno
     *   }
     * })
     * 
     */
    create<T extends UsuarioInternoCreateArgs>(args: SelectSubset<T, UsuarioInternoCreateArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuarioInternos.
     * @param {UsuarioInternoCreateManyArgs} args - Arguments to create many UsuarioInternos.
     * @example
     * // Create many UsuarioInternos
     * const usuarioInterno = await prisma.usuarioInterno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioInternoCreateManyArgs>(args?: SelectSubset<T, UsuarioInternoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioInternos and returns the data saved in the database.
     * @param {UsuarioInternoCreateManyAndReturnArgs} args - Arguments to create many UsuarioInternos.
     * @example
     * // Create many UsuarioInternos
     * const usuarioInterno = await prisma.usuarioInterno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioInternos and only return the `id_usuario`
     * const usuarioInternoWithId_usuarioOnly = await prisma.usuarioInterno.createManyAndReturn({
     *   select: { id_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioInternoCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioInternoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuarioInterno.
     * @param {UsuarioInternoDeleteArgs} args - Arguments to delete one UsuarioInterno.
     * @example
     * // Delete one UsuarioInterno
     * const UsuarioInterno = await prisma.usuarioInterno.delete({
     *   where: {
     *     // ... filter to delete one UsuarioInterno
     *   }
     * })
     * 
     */
    delete<T extends UsuarioInternoDeleteArgs>(args: SelectSubset<T, UsuarioInternoDeleteArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuarioInterno.
     * @param {UsuarioInternoUpdateArgs} args - Arguments to update one UsuarioInterno.
     * @example
     * // Update one UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioInternoUpdateArgs>(args: SelectSubset<T, UsuarioInternoUpdateArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuarioInternos.
     * @param {UsuarioInternoDeleteManyArgs} args - Arguments to filter UsuarioInternos to delete.
     * @example
     * // Delete a few UsuarioInternos
     * const { count } = await prisma.usuarioInterno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioInternoDeleteManyArgs>(args?: SelectSubset<T, UsuarioInternoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioInternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioInternos
     * const usuarioInterno = await prisma.usuarioInterno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioInternoUpdateManyArgs>(args: SelectSubset<T, UsuarioInternoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioInternos and returns the data updated in the database.
     * @param {UsuarioInternoUpdateManyAndReturnArgs} args - Arguments to update many UsuarioInternos.
     * @example
     * // Update many UsuarioInternos
     * const usuarioInterno = await prisma.usuarioInterno.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuarioInternos and only return the `id_usuario`
     * const usuarioInternoWithId_usuarioOnly = await prisma.usuarioInterno.updateManyAndReturn({
     *   select: { id_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioInternoUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioInternoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuarioInterno.
     * @param {UsuarioInternoUpsertArgs} args - Arguments to update or create a UsuarioInterno.
     * @example
     * // Update or create a UsuarioInterno
     * const usuarioInterno = await prisma.usuarioInterno.upsert({
     *   create: {
     *     // ... data to create a UsuarioInterno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioInterno we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioInternoUpsertArgs>(args: SelectSubset<T, UsuarioInternoUpsertArgs<ExtArgs>>): Prisma__UsuarioInternoClient<$Result.GetResult<Prisma.$UsuarioInternoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuarioInternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoCountArgs} args - Arguments to filter UsuarioInternos to count.
     * @example
     * // Count the number of UsuarioInternos
     * const count = await prisma.usuarioInterno.count({
     *   where: {
     *     // ... the filter for the UsuarioInternos we want to count
     *   }
     * })
    **/
    count<T extends UsuarioInternoCountArgs>(
      args?: Subset<T, UsuarioInternoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioInternoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioInterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioInternoAggregateArgs>(args: Subset<T, UsuarioInternoAggregateArgs>): Prisma.PrismaPromise<GetUsuarioInternoAggregateType<T>>

    /**
     * Group by UsuarioInterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioInternoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioInternoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioInternoGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioInternoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioInternoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioInternoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioInterno model
   */
  readonly fields: UsuarioInternoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioInterno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioInternoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioInterno model
   */
  interface UsuarioInternoFieldRefs {
    readonly id_usuario: FieldRef<"UsuarioInterno", 'Int'>
    readonly nombre: FieldRef<"UsuarioInterno", 'String'>
    readonly apellido: FieldRef<"UsuarioInterno", 'String'>
    readonly email: FieldRef<"UsuarioInterno", 'String'>
    readonly contrasena: FieldRef<"UsuarioInterno", 'String'>
    readonly telefono: FieldRef<"UsuarioInterno", 'String'>
    readonly activo: FieldRef<"UsuarioInterno", 'Boolean'>
    readonly id_rol: FieldRef<"UsuarioInterno", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioInterno findUnique
   */
  export type UsuarioInternoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioInterno to fetch.
     */
    where: UsuarioInternoWhereUniqueInput
  }

  /**
   * UsuarioInterno findUniqueOrThrow
   */
  export type UsuarioInternoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioInterno to fetch.
     */
    where: UsuarioInternoWhereUniqueInput
  }

  /**
   * UsuarioInterno findFirst
   */
  export type UsuarioInternoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioInterno to fetch.
     */
    where?: UsuarioInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioInternos to fetch.
     */
    orderBy?: UsuarioInternoOrderByWithRelationInput | UsuarioInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioInternos.
     */
    cursor?: UsuarioInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioInternos.
     */
    distinct?: UsuarioInternoScalarFieldEnum | UsuarioInternoScalarFieldEnum[]
  }

  /**
   * UsuarioInterno findFirstOrThrow
   */
  export type UsuarioInternoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioInterno to fetch.
     */
    where?: UsuarioInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioInternos to fetch.
     */
    orderBy?: UsuarioInternoOrderByWithRelationInput | UsuarioInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioInternos.
     */
    cursor?: UsuarioInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioInternos.
     */
    distinct?: UsuarioInternoScalarFieldEnum | UsuarioInternoScalarFieldEnum[]
  }

  /**
   * UsuarioInterno findMany
   */
  export type UsuarioInternoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioInternos to fetch.
     */
    where?: UsuarioInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioInternos to fetch.
     */
    orderBy?: UsuarioInternoOrderByWithRelationInput | UsuarioInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioInternos.
     */
    cursor?: UsuarioInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioInternos.
     */
    skip?: number
    distinct?: UsuarioInternoScalarFieldEnum | UsuarioInternoScalarFieldEnum[]
  }

  /**
   * UsuarioInterno create
   */
  export type UsuarioInternoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioInterno.
     */
    data: XOR<UsuarioInternoCreateInput, UsuarioInternoUncheckedCreateInput>
  }

  /**
   * UsuarioInterno createMany
   */
  export type UsuarioInternoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioInternos.
     */
    data: UsuarioInternoCreateManyInput | UsuarioInternoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioInterno createManyAndReturn
   */
  export type UsuarioInternoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * The data used to create many UsuarioInternos.
     */
    data: UsuarioInternoCreateManyInput | UsuarioInternoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioInterno update
   */
  export type UsuarioInternoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioInterno.
     */
    data: XOR<UsuarioInternoUpdateInput, UsuarioInternoUncheckedUpdateInput>
    /**
     * Choose, which UsuarioInterno to update.
     */
    where: UsuarioInternoWhereUniqueInput
  }

  /**
   * UsuarioInterno updateMany
   */
  export type UsuarioInternoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioInternos.
     */
    data: XOR<UsuarioInternoUpdateManyMutationInput, UsuarioInternoUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioInternos to update
     */
    where?: UsuarioInternoWhereInput
    /**
     * Limit how many UsuarioInternos to update.
     */
    limit?: number
  }

  /**
   * UsuarioInterno updateManyAndReturn
   */
  export type UsuarioInternoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * The data used to update UsuarioInternos.
     */
    data: XOR<UsuarioInternoUpdateManyMutationInput, UsuarioInternoUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioInternos to update
     */
    where?: UsuarioInternoWhereInput
    /**
     * Limit how many UsuarioInternos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioInterno upsert
   */
  export type UsuarioInternoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioInterno to update in case it exists.
     */
    where: UsuarioInternoWhereUniqueInput
    /**
     * In case the UsuarioInterno found by the `where` argument doesn't exist, create a new UsuarioInterno with this data.
     */
    create: XOR<UsuarioInternoCreateInput, UsuarioInternoUncheckedCreateInput>
    /**
     * In case the UsuarioInterno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioInternoUpdateInput, UsuarioInternoUncheckedUpdateInput>
  }

  /**
   * UsuarioInterno delete
   */
  export type UsuarioInternoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
    /**
     * Filter which UsuarioInterno to delete.
     */
    where: UsuarioInternoWhereUniqueInput
  }

  /**
   * UsuarioInterno deleteMany
   */
  export type UsuarioInternoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioInternos to delete
     */
    where?: UsuarioInternoWhereInput
    /**
     * Limit how many UsuarioInternos to delete.
     */
    limit?: number
  }

  /**
   * UsuarioInterno without action
   */
  export type UsuarioInternoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioInterno
     */
    select?: UsuarioInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioInterno
     */
    omit?: UsuarioInternoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInternoInclude<ExtArgs> | null
  }


  /**
   * Model TipoProducto
   */

  export type AggregateTipoProducto = {
    _count: TipoProductoCountAggregateOutputType | null
    _avg: TipoProductoAvgAggregateOutputType | null
    _sum: TipoProductoSumAggregateOutputType | null
    _min: TipoProductoMinAggregateOutputType | null
    _max: TipoProductoMaxAggregateOutputType | null
  }

  export type TipoProductoAvgAggregateOutputType = {
    id_tipo: number | null
  }

  export type TipoProductoSumAggregateOutputType = {
    id_tipo: number | null
  }

  export type TipoProductoMinAggregateOutputType = {
    id_tipo: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type TipoProductoMaxAggregateOutputType = {
    id_tipo: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type TipoProductoCountAggregateOutputType = {
    id_tipo: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type TipoProductoAvgAggregateInputType = {
    id_tipo?: true
  }

  export type TipoProductoSumAggregateInputType = {
    id_tipo?: true
  }

  export type TipoProductoMinAggregateInputType = {
    id_tipo?: true
    nombre?: true
    descripcion?: true
  }

  export type TipoProductoMaxAggregateInputType = {
    id_tipo?: true
    nombre?: true
    descripcion?: true
  }

  export type TipoProductoCountAggregateInputType = {
    id_tipo?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type TipoProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoProducto to aggregate.
     */
    where?: TipoProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProductos to fetch.
     */
    orderBy?: TipoProductoOrderByWithRelationInput | TipoProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoProductos
    **/
    _count?: true | TipoProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoProductoMaxAggregateInputType
  }

  export type GetTipoProductoAggregateType<T extends TipoProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoProducto[P]>
      : GetScalarType<T[P], AggregateTipoProducto[P]>
  }




  export type TipoProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoProductoWhereInput
    orderBy?: TipoProductoOrderByWithAggregationInput | TipoProductoOrderByWithAggregationInput[]
    by: TipoProductoScalarFieldEnum[] | TipoProductoScalarFieldEnum
    having?: TipoProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoProductoCountAggregateInputType | true
    _avg?: TipoProductoAvgAggregateInputType
    _sum?: TipoProductoSumAggregateInputType
    _min?: TipoProductoMinAggregateInputType
    _max?: TipoProductoMaxAggregateInputType
  }

  export type TipoProductoGroupByOutputType = {
    id_tipo: number
    nombre: string
    descripcion: string | null
    _count: TipoProductoCountAggregateOutputType | null
    _avg: TipoProductoAvgAggregateOutputType | null
    _sum: TipoProductoSumAggregateOutputType | null
    _min: TipoProductoMinAggregateOutputType | null
    _max: TipoProductoMaxAggregateOutputType | null
  }

  type GetTipoProductoGroupByPayload<T extends TipoProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoProductoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoProductoGroupByOutputType[P]>
        }
      >
    >


  export type TipoProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
    productos?: boolean | TipoProducto$productosArgs<ExtArgs>
    _count?: boolean | TipoProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoProducto"]>

  export type TipoProductoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["tipoProducto"]>

  export type TipoProductoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["tipoProducto"]>

  export type TipoProductoSelectScalar = {
    id_tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type TipoProductoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tipo" | "nombre" | "descripcion", ExtArgs["result"]["tipoProducto"]>
  export type TipoProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | TipoProducto$productosArgs<ExtArgs>
    _count?: boolean | TipoProductoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoProductoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoProductoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoProducto"
    objects: {
      productos: Prisma.$ProductoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo: number
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["tipoProducto"]>
    composites: {}
  }

  type TipoProductoGetPayload<S extends boolean | null | undefined | TipoProductoDefaultArgs> = $Result.GetResult<Prisma.$TipoProductoPayload, S>

  type TipoProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoProductoCountAggregateInputType | true
    }

  export interface TipoProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoProducto'], meta: { name: 'TipoProducto' } }
    /**
     * Find zero or one TipoProducto that matches the filter.
     * @param {TipoProductoFindUniqueArgs} args - Arguments to find a TipoProducto
     * @example
     * // Get one TipoProducto
     * const tipoProducto = await prisma.tipoProducto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoProductoFindUniqueArgs>(args: SelectSubset<T, TipoProductoFindUniqueArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoProducto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoProductoFindUniqueOrThrowArgs} args - Arguments to find a TipoProducto
     * @example
     * // Get one TipoProducto
     * const tipoProducto = await prisma.tipoProducto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoProducto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoFindFirstArgs} args - Arguments to find a TipoProducto
     * @example
     * // Get one TipoProducto
     * const tipoProducto = await prisma.tipoProducto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoProductoFindFirstArgs>(args?: SelectSubset<T, TipoProductoFindFirstArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoProducto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoFindFirstOrThrowArgs} args - Arguments to find a TipoProducto
     * @example
     * // Get one TipoProducto
     * const tipoProducto = await prisma.tipoProducto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoProductos
     * const tipoProductos = await prisma.tipoProducto.findMany()
     * 
     * // Get first 10 TipoProductos
     * const tipoProductos = await prisma.tipoProducto.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo`
     * const tipoProductoWithId_tipoOnly = await prisma.tipoProducto.findMany({ select: { id_tipo: true } })
     * 
     */
    findMany<T extends TipoProductoFindManyArgs>(args?: SelectSubset<T, TipoProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoProducto.
     * @param {TipoProductoCreateArgs} args - Arguments to create a TipoProducto.
     * @example
     * // Create one TipoProducto
     * const TipoProducto = await prisma.tipoProducto.create({
     *   data: {
     *     // ... data to create a TipoProducto
     *   }
     * })
     * 
     */
    create<T extends TipoProductoCreateArgs>(args: SelectSubset<T, TipoProductoCreateArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoProductos.
     * @param {TipoProductoCreateManyArgs} args - Arguments to create many TipoProductos.
     * @example
     * // Create many TipoProductos
     * const tipoProducto = await prisma.tipoProducto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoProductoCreateManyArgs>(args?: SelectSubset<T, TipoProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoProductos and returns the data saved in the database.
     * @param {TipoProductoCreateManyAndReturnArgs} args - Arguments to create many TipoProductos.
     * @example
     * // Create many TipoProductos
     * const tipoProducto = await prisma.tipoProducto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoProductos and only return the `id_tipo`
     * const tipoProductoWithId_tipoOnly = await prisma.tipoProducto.createManyAndReturn({
     *   select: { id_tipo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoProductoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoProductoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoProducto.
     * @param {TipoProductoDeleteArgs} args - Arguments to delete one TipoProducto.
     * @example
     * // Delete one TipoProducto
     * const TipoProducto = await prisma.tipoProducto.delete({
     *   where: {
     *     // ... filter to delete one TipoProducto
     *   }
     * })
     * 
     */
    delete<T extends TipoProductoDeleteArgs>(args: SelectSubset<T, TipoProductoDeleteArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoProducto.
     * @param {TipoProductoUpdateArgs} args - Arguments to update one TipoProducto.
     * @example
     * // Update one TipoProducto
     * const tipoProducto = await prisma.tipoProducto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoProductoUpdateArgs>(args: SelectSubset<T, TipoProductoUpdateArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoProductos.
     * @param {TipoProductoDeleteManyArgs} args - Arguments to filter TipoProductos to delete.
     * @example
     * // Delete a few TipoProductos
     * const { count } = await prisma.tipoProducto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoProductoDeleteManyArgs>(args?: SelectSubset<T, TipoProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoProductos
     * const tipoProducto = await prisma.tipoProducto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoProductoUpdateManyArgs>(args: SelectSubset<T, TipoProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoProductos and returns the data updated in the database.
     * @param {TipoProductoUpdateManyAndReturnArgs} args - Arguments to update many TipoProductos.
     * @example
     * // Update many TipoProductos
     * const tipoProducto = await prisma.tipoProducto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoProductos and only return the `id_tipo`
     * const tipoProductoWithId_tipoOnly = await prisma.tipoProducto.updateManyAndReturn({
     *   select: { id_tipo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoProductoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoProductoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoProducto.
     * @param {TipoProductoUpsertArgs} args - Arguments to update or create a TipoProducto.
     * @example
     * // Update or create a TipoProducto
     * const tipoProducto = await prisma.tipoProducto.upsert({
     *   create: {
     *     // ... data to create a TipoProducto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoProducto we want to update
     *   }
     * })
     */
    upsert<T extends TipoProductoUpsertArgs>(args: SelectSubset<T, TipoProductoUpsertArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoCountArgs} args - Arguments to filter TipoProductos to count.
     * @example
     * // Count the number of TipoProductos
     * const count = await prisma.tipoProducto.count({
     *   where: {
     *     // ... the filter for the TipoProductos we want to count
     *   }
     * })
    **/
    count<T extends TipoProductoCountArgs>(
      args?: Subset<T, TipoProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoProductoAggregateArgs>(args: Subset<T, TipoProductoAggregateArgs>): Prisma.PrismaPromise<GetTipoProductoAggregateType<T>>

    /**
     * Group by TipoProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoProductoGroupByArgs['orderBy'] }
        : { orderBy?: TipoProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoProducto model
   */
  readonly fields: TipoProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoProducto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productos<T extends TipoProducto$productosArgs<ExtArgs> = {}>(args?: Subset<T, TipoProducto$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoProducto model
   */
  interface TipoProductoFieldRefs {
    readonly id_tipo: FieldRef<"TipoProducto", 'Int'>
    readonly nombre: FieldRef<"TipoProducto", 'String'>
    readonly descripcion: FieldRef<"TipoProducto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoProducto findUnique
   */
  export type TipoProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter, which TipoProducto to fetch.
     */
    where: TipoProductoWhereUniqueInput
  }

  /**
   * TipoProducto findUniqueOrThrow
   */
  export type TipoProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter, which TipoProducto to fetch.
     */
    where: TipoProductoWhereUniqueInput
  }

  /**
   * TipoProducto findFirst
   */
  export type TipoProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter, which TipoProducto to fetch.
     */
    where?: TipoProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProductos to fetch.
     */
    orderBy?: TipoProductoOrderByWithRelationInput | TipoProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoProductos.
     */
    cursor?: TipoProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoProductos.
     */
    distinct?: TipoProductoScalarFieldEnum | TipoProductoScalarFieldEnum[]
  }

  /**
   * TipoProducto findFirstOrThrow
   */
  export type TipoProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter, which TipoProducto to fetch.
     */
    where?: TipoProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProductos to fetch.
     */
    orderBy?: TipoProductoOrderByWithRelationInput | TipoProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoProductos.
     */
    cursor?: TipoProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoProductos.
     */
    distinct?: TipoProductoScalarFieldEnum | TipoProductoScalarFieldEnum[]
  }

  /**
   * TipoProducto findMany
   */
  export type TipoProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter, which TipoProductos to fetch.
     */
    where?: TipoProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProductos to fetch.
     */
    orderBy?: TipoProductoOrderByWithRelationInput | TipoProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoProductos.
     */
    cursor?: TipoProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProductos.
     */
    skip?: number
    distinct?: TipoProductoScalarFieldEnum | TipoProductoScalarFieldEnum[]
  }

  /**
   * TipoProducto create
   */
  export type TipoProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoProducto.
     */
    data: XOR<TipoProductoCreateInput, TipoProductoUncheckedCreateInput>
  }

  /**
   * TipoProducto createMany
   */
  export type TipoProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoProductos.
     */
    data: TipoProductoCreateManyInput | TipoProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoProducto createManyAndReturn
   */
  export type TipoProductoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoProductos.
     */
    data: TipoProductoCreateManyInput | TipoProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoProducto update
   */
  export type TipoProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoProducto.
     */
    data: XOR<TipoProductoUpdateInput, TipoProductoUncheckedUpdateInput>
    /**
     * Choose, which TipoProducto to update.
     */
    where: TipoProductoWhereUniqueInput
  }

  /**
   * TipoProducto updateMany
   */
  export type TipoProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoProductos.
     */
    data: XOR<TipoProductoUpdateManyMutationInput, TipoProductoUncheckedUpdateManyInput>
    /**
     * Filter which TipoProductos to update
     */
    where?: TipoProductoWhereInput
    /**
     * Limit how many TipoProductos to update.
     */
    limit?: number
  }

  /**
   * TipoProducto updateManyAndReturn
   */
  export type TipoProductoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * The data used to update TipoProductos.
     */
    data: XOR<TipoProductoUpdateManyMutationInput, TipoProductoUncheckedUpdateManyInput>
    /**
     * Filter which TipoProductos to update
     */
    where?: TipoProductoWhereInput
    /**
     * Limit how many TipoProductos to update.
     */
    limit?: number
  }

  /**
   * TipoProducto upsert
   */
  export type TipoProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoProducto to update in case it exists.
     */
    where: TipoProductoWhereUniqueInput
    /**
     * In case the TipoProducto found by the `where` argument doesn't exist, create a new TipoProducto with this data.
     */
    create: XOR<TipoProductoCreateInput, TipoProductoUncheckedCreateInput>
    /**
     * In case the TipoProducto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoProductoUpdateInput, TipoProductoUncheckedUpdateInput>
  }

  /**
   * TipoProducto delete
   */
  export type TipoProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    /**
     * Filter which TipoProducto to delete.
     */
    where: TipoProductoWhereUniqueInput
  }

  /**
   * TipoProducto deleteMany
   */
  export type TipoProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoProductos to delete
     */
    where?: TipoProductoWhereInput
    /**
     * Limit how many TipoProductos to delete.
     */
    limit?: number
  }

  /**
   * TipoProducto.productos
   */
  export type TipoProducto$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * TipoProducto without action
   */
  export type TipoProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
  }


  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id_producto: number | null
    precio: number | null
    stock: number | null
    id_tipo: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id_producto: number | null
    precio: number | null
    stock: number | null
    id_tipo: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id_producto: number | null
    nombre: string | null
    tipo: string | null
    descripcion: string | null
    precio: number | null
    stock: number | null
    activo: boolean | null
    id_tipo: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    id_producto: number | null
    nombre: string | null
    tipo: string | null
    descripcion: string | null
    precio: number | null
    stock: number | null
    activo: boolean | null
    id_tipo: number | null
  }

  export type ProductoCountAggregateOutputType = {
    id_producto: number
    nombre: number
    tipo: number
    descripcion: number
    precio: number
    stock: number
    activo: number
    id_tipo: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id_producto?: true
    precio?: true
    stock?: true
    id_tipo?: true
  }

  export type ProductoSumAggregateInputType = {
    id_producto?: true
    precio?: true
    stock?: true
    id_tipo?: true
  }

  export type ProductoMinAggregateInputType = {
    id_producto?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    precio?: true
    stock?: true
    activo?: true
    id_tipo?: true
  }

  export type ProductoMaxAggregateInputType = {
    id_producto?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    precio?: true
    stock?: true
    activo?: true
    id_tipo?: true
  }

  export type ProductoCountAggregateInputType = {
    id_producto?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    precio?: true
    stock?: true
    activo?: true
    id_tipo?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id_producto: number
    nombre: string
    tipo: string | null
    descripcion: string | null
    precio: number
    stock: number | null
    activo: boolean
    id_tipo: number | null
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    precio?: boolean
    stock?: boolean
    activo?: boolean
    id_tipo?: boolean
    alquiler?: boolean | Producto$alquilerArgs<ExtArgs>
    Auto?: boolean | Producto$AutoArgs<ExtArgs>
    carritoItems?: boolean | Producto$carritoItemsArgs<ExtArgs>
    hospedaje?: boolean | Producto$hospedajeArgs<ExtArgs>
    paqueteDetallesAsPaquete?: boolean | Producto$paqueteDetallesAsPaqueteArgs<ExtArgs>
    paqueteDetallesAsProducto?: boolean | Producto$paqueteDetallesAsProductoArgs<ExtArgs>
    pasaje?: boolean | Producto$pasajeArgs<ExtArgs>
    pedidoItems?: boolean | Producto$pedidoItemsArgs<ExtArgs>
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    precio?: boolean
    stock?: boolean
    activo?: boolean
    id_tipo?: boolean
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    precio?: boolean
    stock?: boolean
    activo?: boolean
    id_tipo?: boolean
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectScalar = {
    id_producto?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    precio?: boolean
    stock?: boolean
    activo?: boolean
    id_tipo?: boolean
  }

  export type ProductoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_producto" | "nombre" | "tipo" | "descripcion" | "precio" | "stock" | "activo" | "id_tipo", ExtArgs["result"]["producto"]>
  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alquiler?: boolean | Producto$alquilerArgs<ExtArgs>
    Auto?: boolean | Producto$AutoArgs<ExtArgs>
    carritoItems?: boolean | Producto$carritoItemsArgs<ExtArgs>
    hospedaje?: boolean | Producto$hospedajeArgs<ExtArgs>
    paqueteDetallesAsPaquete?: boolean | Producto$paqueteDetallesAsPaqueteArgs<ExtArgs>
    paqueteDetallesAsProducto?: boolean | Producto$paqueteDetallesAsProductoArgs<ExtArgs>
    pasaje?: boolean | Producto$pasajeArgs<ExtArgs>
    pedidoItems?: boolean | Producto$pedidoItemsArgs<ExtArgs>
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
  }
  export type ProductoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoProducto?: boolean | Producto$tipoProductoArgs<ExtArgs>
  }

  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      alquiler: Prisma.$AlquilerPayload<ExtArgs> | null
      Auto: Prisma.$AutoPayload<ExtArgs> | null
      carritoItems: Prisma.$CarritoItemPayload<ExtArgs>[]
      hospedaje: Prisma.$HospedajePayload<ExtArgs> | null
      paqueteDetallesAsPaquete: Prisma.$PaqueteDetallePayload<ExtArgs>[]
      paqueteDetallesAsProducto: Prisma.$PaqueteDetallePayload<ExtArgs>[]
      pasaje: Prisma.$PasajePayload<ExtArgs> | null
      pedidoItems: Prisma.$PedidoItemPayload<ExtArgs>[]
      tipoProducto: Prisma.$TipoProductoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_producto: number
      nombre: string
      tipo: string | null
      descripcion: string | null
      precio: number
      stock: number | null
      activo: boolean
      id_tipo: number | null
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }

  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoFindUniqueArgs>(args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Producto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoFindFirstArgs>(args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id_producto`
     * const productoWithId_productoOnly = await prisma.producto.findMany({ select: { id_producto: true } })
     * 
     */
    findMany<T extends ProductoFindManyArgs>(args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
     */
    create<T extends ProductoCreateArgs>(args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productos.
     * @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoCreateManyArgs>(args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos and returns the data saved in the database.
     * @param {ProductoCreateManyAndReturnArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos and only return the `id_producto`
     * const productoWithId_productoOnly = await prisma.producto.createManyAndReturn({
     *   select: { id_producto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
     */
    delete<T extends ProductoDeleteArgs>(args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoUpdateArgs>(args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoDeleteManyArgs>(args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoUpdateManyArgs>(args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos and returns the data updated in the database.
     * @param {ProductoUpdateManyAndReturnArgs} args - Arguments to update many Productos.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productos and only return the `id_producto`
     * const productoWithId_productoOnly = await prisma.producto.updateManyAndReturn({
     *   select: { id_producto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
     */
    upsert<T extends ProductoUpsertArgs>(args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alquiler<T extends Producto$alquilerArgs<ExtArgs> = {}>(args?: Subset<T, Producto$alquilerArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Auto<T extends Producto$AutoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$AutoArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    carritoItems<T extends Producto$carritoItemsArgs<ExtArgs> = {}>(args?: Subset<T, Producto$carritoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hospedaje<T extends Producto$hospedajeArgs<ExtArgs> = {}>(args?: Subset<T, Producto$hospedajeArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paqueteDetallesAsPaquete<T extends Producto$paqueteDetallesAsPaqueteArgs<ExtArgs> = {}>(args?: Subset<T, Producto$paqueteDetallesAsPaqueteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paqueteDetallesAsProducto<T extends Producto$paqueteDetallesAsProductoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$paqueteDetallesAsProductoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pasaje<T extends Producto$pasajeArgs<ExtArgs> = {}>(args?: Subset<T, Producto$pasajeArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pedidoItems<T extends Producto$pedidoItemsArgs<ExtArgs> = {}>(args?: Subset<T, Producto$pedidoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tipoProducto<T extends Producto$tipoProductoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$tipoProductoArgs<ExtArgs>>): Prisma__TipoProductoClient<$Result.GetResult<Prisma.$TipoProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Producto model
   */
  interface ProductoFieldRefs {
    readonly id_producto: FieldRef<"Producto", 'Int'>
    readonly nombre: FieldRef<"Producto", 'String'>
    readonly tipo: FieldRef<"Producto", 'String'>
    readonly descripcion: FieldRef<"Producto", 'String'>
    readonly precio: FieldRef<"Producto", 'Float'>
    readonly stock: FieldRef<"Producto", 'Int'>
    readonly activo: FieldRef<"Producto", 'Boolean'>
    readonly id_tipo: FieldRef<"Producto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }

  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Producto createManyAndReturn
   */
  export type ProductoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
    /**
     * Limit how many Productos to update.
     */
    limit?: number
  }

  /**
   * Producto updateManyAndReturn
   */
  export type ProductoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
    /**
     * Limit how many Productos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }

  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
    /**
     * Limit how many Productos to delete.
     */
    limit?: number
  }

  /**
   * Producto.alquiler
   */
  export type Producto$alquilerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    where?: AlquilerWhereInput
  }

  /**
   * Producto.Auto
   */
  export type Producto$AutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    where?: AutoWhereInput
  }

  /**
   * Producto.carritoItems
   */
  export type Producto$carritoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    where?: CarritoItemWhereInput
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    cursor?: CarritoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarritoItemScalarFieldEnum | CarritoItemScalarFieldEnum[]
  }

  /**
   * Producto.hospedaje
   */
  export type Producto$hospedajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    where?: HospedajeWhereInput
  }

  /**
   * Producto.paqueteDetallesAsPaquete
   */
  export type Producto$paqueteDetallesAsPaqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    where?: PaqueteDetalleWhereInput
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    cursor?: PaqueteDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteDetalleScalarFieldEnum | PaqueteDetalleScalarFieldEnum[]
  }

  /**
   * Producto.paqueteDetallesAsProducto
   */
  export type Producto$paqueteDetallesAsProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    where?: PaqueteDetalleWhereInput
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    cursor?: PaqueteDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteDetalleScalarFieldEnum | PaqueteDetalleScalarFieldEnum[]
  }

  /**
   * Producto.pasaje
   */
  export type Producto$pasajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    where?: PasajeWhereInput
  }

  /**
   * Producto.pedidoItems
   */
  export type Producto$pedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Producto.tipoProducto
   */
  export type Producto$tipoProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProducto
     */
    select?: TipoProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProducto
     */
    omit?: TipoProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoProductoInclude<ExtArgs> | null
    where?: TipoProductoWhereInput
  }

  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
  }


  /**
   * Model Hospedaje
   */

  export type AggregateHospedaje = {
    _count: HospedajeCountAggregateOutputType | null
    _avg: HospedajeAvgAggregateOutputType | null
    _sum: HospedajeSumAggregateOutputType | null
    _min: HospedajeMinAggregateOutputType | null
    _max: HospedajeMaxAggregateOutputType | null
  }

  export type HospedajeAvgAggregateOutputType = {
    id_hospedaje: number | null
    id_producto: number | null
    capacidad: number | null
  }

  export type HospedajeSumAggregateOutputType = {
    id_hospedaje: number | null
    id_producto: number | null
    capacidad: number | null
  }

  export type HospedajeMinAggregateOutputType = {
    id_hospedaje: number | null
    id_producto: number | null
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    capacidad: number | null
  }

  export type HospedajeMaxAggregateOutputType = {
    id_hospedaje: number | null
    id_producto: number | null
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    capacidad: number | null
  }

  export type HospedajeCountAggregateOutputType = {
    id_hospedaje: number
    id_producto: number
    ubicacion: number
    fecha_inicio: number
    fecha_fin: number
    capacidad: number
    _all: number
  }


  export type HospedajeAvgAggregateInputType = {
    id_hospedaje?: true
    id_producto?: true
    capacidad?: true
  }

  export type HospedajeSumAggregateInputType = {
    id_hospedaje?: true
    id_producto?: true
    capacidad?: true
  }

  export type HospedajeMinAggregateInputType = {
    id_hospedaje?: true
    id_producto?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    capacidad?: true
  }

  export type HospedajeMaxAggregateInputType = {
    id_hospedaje?: true
    id_producto?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    capacidad?: true
  }

  export type HospedajeCountAggregateInputType = {
    id_hospedaje?: true
    id_producto?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    capacidad?: true
    _all?: true
  }

  export type HospedajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospedaje to aggregate.
     */
    where?: HospedajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospedajes to fetch.
     */
    orderBy?: HospedajeOrderByWithRelationInput | HospedajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospedajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospedajes
    **/
    _count?: true | HospedajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospedajeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospedajeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospedajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospedajeMaxAggregateInputType
  }

  export type GetHospedajeAggregateType<T extends HospedajeAggregateArgs> = {
        [P in keyof T & keyof AggregateHospedaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospedaje[P]>
      : GetScalarType<T[P], AggregateHospedaje[P]>
  }




  export type HospedajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospedajeWhereInput
    orderBy?: HospedajeOrderByWithAggregationInput | HospedajeOrderByWithAggregationInput[]
    by: HospedajeScalarFieldEnum[] | HospedajeScalarFieldEnum
    having?: HospedajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospedajeCountAggregateInputType | true
    _avg?: HospedajeAvgAggregateInputType
    _sum?: HospedajeSumAggregateInputType
    _min?: HospedajeMinAggregateInputType
    _max?: HospedajeMaxAggregateInputType
  }

  export type HospedajeGroupByOutputType = {
    id_hospedaje: number
    id_producto: number
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    capacidad: number | null
    _count: HospedajeCountAggregateOutputType | null
    _avg: HospedajeAvgAggregateOutputType | null
    _sum: HospedajeSumAggregateOutputType | null
    _min: HospedajeMinAggregateOutputType | null
    _max: HospedajeMaxAggregateOutputType | null
  }

  type GetHospedajeGroupByPayload<T extends HospedajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospedajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospedajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospedajeGroupByOutputType[P]>
            : GetScalarType<T[P], HospedajeGroupByOutputType[P]>
        }
      >
    >


  export type HospedajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hospedaje?: boolean
    id_producto?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    capacidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospedaje"]>

  export type HospedajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hospedaje?: boolean
    id_producto?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    capacidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospedaje"]>

  export type HospedajeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hospedaje?: boolean
    id_producto?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    capacidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospedaje"]>

  export type HospedajeSelectScalar = {
    id_hospedaje?: boolean
    id_producto?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    capacidad?: boolean
  }

  export type HospedajeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_hospedaje" | "id_producto" | "ubicacion" | "fecha_inicio" | "fecha_fin" | "capacidad", ExtArgs["result"]["hospedaje"]>
  export type HospedajeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type HospedajeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type HospedajeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $HospedajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospedaje"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_hospedaje: number
      id_producto: number
      ubicacion: string | null
      fecha_inicio: Date | null
      fecha_fin: Date | null
      capacidad: number | null
    }, ExtArgs["result"]["hospedaje"]>
    composites: {}
  }

  type HospedajeGetPayload<S extends boolean | null | undefined | HospedajeDefaultArgs> = $Result.GetResult<Prisma.$HospedajePayload, S>

  type HospedajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospedajeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospedajeCountAggregateInputType | true
    }

  export interface HospedajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospedaje'], meta: { name: 'Hospedaje' } }
    /**
     * Find zero or one Hospedaje that matches the filter.
     * @param {HospedajeFindUniqueArgs} args - Arguments to find a Hospedaje
     * @example
     * // Get one Hospedaje
     * const hospedaje = await prisma.hospedaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospedajeFindUniqueArgs>(args: SelectSubset<T, HospedajeFindUniqueArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hospedaje that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospedajeFindUniqueOrThrowArgs} args - Arguments to find a Hospedaje
     * @example
     * // Get one Hospedaje
     * const hospedaje = await prisma.hospedaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospedajeFindUniqueOrThrowArgs>(args: SelectSubset<T, HospedajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospedaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeFindFirstArgs} args - Arguments to find a Hospedaje
     * @example
     * // Get one Hospedaje
     * const hospedaje = await prisma.hospedaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospedajeFindFirstArgs>(args?: SelectSubset<T, HospedajeFindFirstArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospedaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeFindFirstOrThrowArgs} args - Arguments to find a Hospedaje
     * @example
     * // Get one Hospedaje
     * const hospedaje = await prisma.hospedaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospedajeFindFirstOrThrowArgs>(args?: SelectSubset<T, HospedajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hospedajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospedajes
     * const hospedajes = await prisma.hospedaje.findMany()
     * 
     * // Get first 10 Hospedajes
     * const hospedajes = await prisma.hospedaje.findMany({ take: 10 })
     * 
     * // Only select the `id_hospedaje`
     * const hospedajeWithId_hospedajeOnly = await prisma.hospedaje.findMany({ select: { id_hospedaje: true } })
     * 
     */
    findMany<T extends HospedajeFindManyArgs>(args?: SelectSubset<T, HospedajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hospedaje.
     * @param {HospedajeCreateArgs} args - Arguments to create a Hospedaje.
     * @example
     * // Create one Hospedaje
     * const Hospedaje = await prisma.hospedaje.create({
     *   data: {
     *     // ... data to create a Hospedaje
     *   }
     * })
     * 
     */
    create<T extends HospedajeCreateArgs>(args: SelectSubset<T, HospedajeCreateArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hospedajes.
     * @param {HospedajeCreateManyArgs} args - Arguments to create many Hospedajes.
     * @example
     * // Create many Hospedajes
     * const hospedaje = await prisma.hospedaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospedajeCreateManyArgs>(args?: SelectSubset<T, HospedajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospedajes and returns the data saved in the database.
     * @param {HospedajeCreateManyAndReturnArgs} args - Arguments to create many Hospedajes.
     * @example
     * // Create many Hospedajes
     * const hospedaje = await prisma.hospedaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospedajes and only return the `id_hospedaje`
     * const hospedajeWithId_hospedajeOnly = await prisma.hospedaje.createManyAndReturn({
     *   select: { id_hospedaje: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospedajeCreateManyAndReturnArgs>(args?: SelectSubset<T, HospedajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hospedaje.
     * @param {HospedajeDeleteArgs} args - Arguments to delete one Hospedaje.
     * @example
     * // Delete one Hospedaje
     * const Hospedaje = await prisma.hospedaje.delete({
     *   where: {
     *     // ... filter to delete one Hospedaje
     *   }
     * })
     * 
     */
    delete<T extends HospedajeDeleteArgs>(args: SelectSubset<T, HospedajeDeleteArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hospedaje.
     * @param {HospedajeUpdateArgs} args - Arguments to update one Hospedaje.
     * @example
     * // Update one Hospedaje
     * const hospedaje = await prisma.hospedaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospedajeUpdateArgs>(args: SelectSubset<T, HospedajeUpdateArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hospedajes.
     * @param {HospedajeDeleteManyArgs} args - Arguments to filter Hospedajes to delete.
     * @example
     * // Delete a few Hospedajes
     * const { count } = await prisma.hospedaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospedajeDeleteManyArgs>(args?: SelectSubset<T, HospedajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospedajes
     * const hospedaje = await prisma.hospedaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospedajeUpdateManyArgs>(args: SelectSubset<T, HospedajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospedajes and returns the data updated in the database.
     * @param {HospedajeUpdateManyAndReturnArgs} args - Arguments to update many Hospedajes.
     * @example
     * // Update many Hospedajes
     * const hospedaje = await prisma.hospedaje.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hospedajes and only return the `id_hospedaje`
     * const hospedajeWithId_hospedajeOnly = await prisma.hospedaje.updateManyAndReturn({
     *   select: { id_hospedaje: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HospedajeUpdateManyAndReturnArgs>(args: SelectSubset<T, HospedajeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hospedaje.
     * @param {HospedajeUpsertArgs} args - Arguments to update or create a Hospedaje.
     * @example
     * // Update or create a Hospedaje
     * const hospedaje = await prisma.hospedaje.upsert({
     *   create: {
     *     // ... data to create a Hospedaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospedaje we want to update
     *   }
     * })
     */
    upsert<T extends HospedajeUpsertArgs>(args: SelectSubset<T, HospedajeUpsertArgs<ExtArgs>>): Prisma__HospedajeClient<$Result.GetResult<Prisma.$HospedajePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeCountArgs} args - Arguments to filter Hospedajes to count.
     * @example
     * // Count the number of Hospedajes
     * const count = await prisma.hospedaje.count({
     *   where: {
     *     // ... the filter for the Hospedajes we want to count
     *   }
     * })
    **/
    count<T extends HospedajeCountArgs>(
      args?: Subset<T, HospedajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospedajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospedaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospedajeAggregateArgs>(args: Subset<T, HospedajeAggregateArgs>): Prisma.PrismaPromise<GetHospedajeAggregateType<T>>

    /**
     * Group by Hospedaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospedajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospedajeGroupByArgs['orderBy'] }
        : { orderBy?: HospedajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospedajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospedajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospedaje model
   */
  readonly fields: HospedajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospedaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospedajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospedaje model
   */
  interface HospedajeFieldRefs {
    readonly id_hospedaje: FieldRef<"Hospedaje", 'Int'>
    readonly id_producto: FieldRef<"Hospedaje", 'Int'>
    readonly ubicacion: FieldRef<"Hospedaje", 'String'>
    readonly fecha_inicio: FieldRef<"Hospedaje", 'DateTime'>
    readonly fecha_fin: FieldRef<"Hospedaje", 'DateTime'>
    readonly capacidad: FieldRef<"Hospedaje", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Hospedaje findUnique
   */
  export type HospedajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter, which Hospedaje to fetch.
     */
    where: HospedajeWhereUniqueInput
  }

  /**
   * Hospedaje findUniqueOrThrow
   */
  export type HospedajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter, which Hospedaje to fetch.
     */
    where: HospedajeWhereUniqueInput
  }

  /**
   * Hospedaje findFirst
   */
  export type HospedajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter, which Hospedaje to fetch.
     */
    where?: HospedajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospedajes to fetch.
     */
    orderBy?: HospedajeOrderByWithRelationInput | HospedajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospedajes.
     */
    cursor?: HospedajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospedajes.
     */
    distinct?: HospedajeScalarFieldEnum | HospedajeScalarFieldEnum[]
  }

  /**
   * Hospedaje findFirstOrThrow
   */
  export type HospedajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter, which Hospedaje to fetch.
     */
    where?: HospedajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospedajes to fetch.
     */
    orderBy?: HospedajeOrderByWithRelationInput | HospedajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospedajes.
     */
    cursor?: HospedajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospedajes.
     */
    distinct?: HospedajeScalarFieldEnum | HospedajeScalarFieldEnum[]
  }

  /**
   * Hospedaje findMany
   */
  export type HospedajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter, which Hospedajes to fetch.
     */
    where?: HospedajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospedajes to fetch.
     */
    orderBy?: HospedajeOrderByWithRelationInput | HospedajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospedajes.
     */
    cursor?: HospedajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospedajes.
     */
    skip?: number
    distinct?: HospedajeScalarFieldEnum | HospedajeScalarFieldEnum[]
  }

  /**
   * Hospedaje create
   */
  export type HospedajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospedaje.
     */
    data: XOR<HospedajeCreateInput, HospedajeUncheckedCreateInput>
  }

  /**
   * Hospedaje createMany
   */
  export type HospedajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospedajes.
     */
    data: HospedajeCreateManyInput | HospedajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospedaje createManyAndReturn
   */
  export type HospedajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * The data used to create many Hospedajes.
     */
    data: HospedajeCreateManyInput | HospedajeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospedaje update
   */
  export type HospedajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospedaje.
     */
    data: XOR<HospedajeUpdateInput, HospedajeUncheckedUpdateInput>
    /**
     * Choose, which Hospedaje to update.
     */
    where: HospedajeWhereUniqueInput
  }

  /**
   * Hospedaje updateMany
   */
  export type HospedajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospedajes.
     */
    data: XOR<HospedajeUpdateManyMutationInput, HospedajeUncheckedUpdateManyInput>
    /**
     * Filter which Hospedajes to update
     */
    where?: HospedajeWhereInput
    /**
     * Limit how many Hospedajes to update.
     */
    limit?: number
  }

  /**
   * Hospedaje updateManyAndReturn
   */
  export type HospedajeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * The data used to update Hospedajes.
     */
    data: XOR<HospedajeUpdateManyMutationInput, HospedajeUncheckedUpdateManyInput>
    /**
     * Filter which Hospedajes to update
     */
    where?: HospedajeWhereInput
    /**
     * Limit how many Hospedajes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospedaje upsert
   */
  export type HospedajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospedaje to update in case it exists.
     */
    where: HospedajeWhereUniqueInput
    /**
     * In case the Hospedaje found by the `where` argument doesn't exist, create a new Hospedaje with this data.
     */
    create: XOR<HospedajeCreateInput, HospedajeUncheckedCreateInput>
    /**
     * In case the Hospedaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospedajeUpdateInput, HospedajeUncheckedUpdateInput>
  }

  /**
   * Hospedaje delete
   */
  export type HospedajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
    /**
     * Filter which Hospedaje to delete.
     */
    where: HospedajeWhereUniqueInput
  }

  /**
   * Hospedaje deleteMany
   */
  export type HospedajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospedajes to delete
     */
    where?: HospedajeWhereInput
    /**
     * Limit how many Hospedajes to delete.
     */
    limit?: number
  }

  /**
   * Hospedaje without action
   */
  export type HospedajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospedaje
     */
    select?: HospedajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospedaje
     */
    omit?: HospedajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospedajeInclude<ExtArgs> | null
  }


  /**
   * Model Pasaje
   */

  export type AggregatePasaje = {
    _count: PasajeCountAggregateOutputType | null
    _avg: PasajeAvgAggregateOutputType | null
    _sum: PasajeSumAggregateOutputType | null
    _min: PasajeMinAggregateOutputType | null
    _max: PasajeMaxAggregateOutputType | null
  }

  export type PasajeAvgAggregateOutputType = {
    id_pasaje: number | null
    id_producto: number | null
    asientos_disponibles: number | null
  }

  export type PasajeSumAggregateOutputType = {
    id_pasaje: number | null
    id_producto: number | null
    asientos_disponibles: number | null
  }

  export type PasajeMinAggregateOutputType = {
    id_pasaje: number | null
    id_producto: number | null
    origen: string | null
    destino: string | null
    fecha_salida: Date | null
    fecha_regreso: Date | null
    clase: string | null
    asientos_disponibles: number | null
    aerolinea: string | null
  }

  export type PasajeMaxAggregateOutputType = {
    id_pasaje: number | null
    id_producto: number | null
    origen: string | null
    destino: string | null
    fecha_salida: Date | null
    fecha_regreso: Date | null
    clase: string | null
    asientos_disponibles: number | null
    aerolinea: string | null
  }

  export type PasajeCountAggregateOutputType = {
    id_pasaje: number
    id_producto: number
    origen: number
    destino: number
    fecha_salida: number
    fecha_regreso: number
    clase: number
    asientos_disponibles: number
    aerolinea: number
    _all: number
  }


  export type PasajeAvgAggregateInputType = {
    id_pasaje?: true
    id_producto?: true
    asientos_disponibles?: true
  }

  export type PasajeSumAggregateInputType = {
    id_pasaje?: true
    id_producto?: true
    asientos_disponibles?: true
  }

  export type PasajeMinAggregateInputType = {
    id_pasaje?: true
    id_producto?: true
    origen?: true
    destino?: true
    fecha_salida?: true
    fecha_regreso?: true
    clase?: true
    asientos_disponibles?: true
    aerolinea?: true
  }

  export type PasajeMaxAggregateInputType = {
    id_pasaje?: true
    id_producto?: true
    origen?: true
    destino?: true
    fecha_salida?: true
    fecha_regreso?: true
    clase?: true
    asientos_disponibles?: true
    aerolinea?: true
  }

  export type PasajeCountAggregateInputType = {
    id_pasaje?: true
    id_producto?: true
    origen?: true
    destino?: true
    fecha_salida?: true
    fecha_regreso?: true
    clase?: true
    asientos_disponibles?: true
    aerolinea?: true
    _all?: true
  }

  export type PasajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pasaje to aggregate.
     */
    where?: PasajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pasajes to fetch.
     */
    orderBy?: PasajeOrderByWithRelationInput | PasajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pasajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pasajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pasajes
    **/
    _count?: true | PasajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasajeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasajeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasajeMaxAggregateInputType
  }

  export type GetPasajeAggregateType<T extends PasajeAggregateArgs> = {
        [P in keyof T & keyof AggregatePasaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasaje[P]>
      : GetScalarType<T[P], AggregatePasaje[P]>
  }




  export type PasajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasajeWhereInput
    orderBy?: PasajeOrderByWithAggregationInput | PasajeOrderByWithAggregationInput[]
    by: PasajeScalarFieldEnum[] | PasajeScalarFieldEnum
    having?: PasajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasajeCountAggregateInputType | true
    _avg?: PasajeAvgAggregateInputType
    _sum?: PasajeSumAggregateInputType
    _min?: PasajeMinAggregateInputType
    _max?: PasajeMaxAggregateInputType
  }

  export type PasajeGroupByOutputType = {
    id_pasaje: number
    id_producto: number
    origen: string | null
    destino: string | null
    fecha_salida: Date | null
    fecha_regreso: Date | null
    clase: string | null
    asientos_disponibles: number
    aerolinea: string | null
    _count: PasajeCountAggregateOutputType | null
    _avg: PasajeAvgAggregateOutputType | null
    _sum: PasajeSumAggregateOutputType | null
    _min: PasajeMinAggregateOutputType | null
    _max: PasajeMaxAggregateOutputType | null
  }

  type GetPasajeGroupByPayload<T extends PasajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasajeGroupByOutputType[P]>
            : GetScalarType<T[P], PasajeGroupByOutputType[P]>
        }
      >
    >


  export type PasajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pasaje?: boolean
    id_producto?: boolean
    origen?: boolean
    destino?: boolean
    fecha_salida?: boolean
    fecha_regreso?: boolean
    clase?: boolean
    asientos_disponibles?: boolean
    aerolinea?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pasaje"]>

  export type PasajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pasaje?: boolean
    id_producto?: boolean
    origen?: boolean
    destino?: boolean
    fecha_salida?: boolean
    fecha_regreso?: boolean
    clase?: boolean
    asientos_disponibles?: boolean
    aerolinea?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pasaje"]>

  export type PasajeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pasaje?: boolean
    id_producto?: boolean
    origen?: boolean
    destino?: boolean
    fecha_salida?: boolean
    fecha_regreso?: boolean
    clase?: boolean
    asientos_disponibles?: boolean
    aerolinea?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pasaje"]>

  export type PasajeSelectScalar = {
    id_pasaje?: boolean
    id_producto?: boolean
    origen?: boolean
    destino?: boolean
    fecha_salida?: boolean
    fecha_regreso?: boolean
    clase?: boolean
    asientos_disponibles?: boolean
    aerolinea?: boolean
  }

  export type PasajeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pasaje" | "id_producto" | "origen" | "destino" | "fecha_salida" | "fecha_regreso" | "clase" | "asientos_disponibles" | "aerolinea", ExtArgs["result"]["pasaje"]>
  export type PasajeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PasajeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PasajeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $PasajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pasaje"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pasaje: number
      id_producto: number
      origen: string | null
      destino: string | null
      fecha_salida: Date | null
      fecha_regreso: Date | null
      clase: string | null
      asientos_disponibles: number
      aerolinea: string | null
    }, ExtArgs["result"]["pasaje"]>
    composites: {}
  }

  type PasajeGetPayload<S extends boolean | null | undefined | PasajeDefaultArgs> = $Result.GetResult<Prisma.$PasajePayload, S>

  type PasajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasajeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasajeCountAggregateInputType | true
    }

  export interface PasajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pasaje'], meta: { name: 'Pasaje' } }
    /**
     * Find zero or one Pasaje that matches the filter.
     * @param {PasajeFindUniqueArgs} args - Arguments to find a Pasaje
     * @example
     * // Get one Pasaje
     * const pasaje = await prisma.pasaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasajeFindUniqueArgs>(args: SelectSubset<T, PasajeFindUniqueArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pasaje that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasajeFindUniqueOrThrowArgs} args - Arguments to find a Pasaje
     * @example
     * // Get one Pasaje
     * const pasaje = await prisma.pasaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasajeFindUniqueOrThrowArgs>(args: SelectSubset<T, PasajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pasaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeFindFirstArgs} args - Arguments to find a Pasaje
     * @example
     * // Get one Pasaje
     * const pasaje = await prisma.pasaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasajeFindFirstArgs>(args?: SelectSubset<T, PasajeFindFirstArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pasaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeFindFirstOrThrowArgs} args - Arguments to find a Pasaje
     * @example
     * // Get one Pasaje
     * const pasaje = await prisma.pasaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasajeFindFirstOrThrowArgs>(args?: SelectSubset<T, PasajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pasajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pasajes
     * const pasajes = await prisma.pasaje.findMany()
     * 
     * // Get first 10 Pasajes
     * const pasajes = await prisma.pasaje.findMany({ take: 10 })
     * 
     * // Only select the `id_pasaje`
     * const pasajeWithId_pasajeOnly = await prisma.pasaje.findMany({ select: { id_pasaje: true } })
     * 
     */
    findMany<T extends PasajeFindManyArgs>(args?: SelectSubset<T, PasajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pasaje.
     * @param {PasajeCreateArgs} args - Arguments to create a Pasaje.
     * @example
     * // Create one Pasaje
     * const Pasaje = await prisma.pasaje.create({
     *   data: {
     *     // ... data to create a Pasaje
     *   }
     * })
     * 
     */
    create<T extends PasajeCreateArgs>(args: SelectSubset<T, PasajeCreateArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pasajes.
     * @param {PasajeCreateManyArgs} args - Arguments to create many Pasajes.
     * @example
     * // Create many Pasajes
     * const pasaje = await prisma.pasaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasajeCreateManyArgs>(args?: SelectSubset<T, PasajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pasajes and returns the data saved in the database.
     * @param {PasajeCreateManyAndReturnArgs} args - Arguments to create many Pasajes.
     * @example
     * // Create many Pasajes
     * const pasaje = await prisma.pasaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pasajes and only return the `id_pasaje`
     * const pasajeWithId_pasajeOnly = await prisma.pasaje.createManyAndReturn({
     *   select: { id_pasaje: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasajeCreateManyAndReturnArgs>(args?: SelectSubset<T, PasajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pasaje.
     * @param {PasajeDeleteArgs} args - Arguments to delete one Pasaje.
     * @example
     * // Delete one Pasaje
     * const Pasaje = await prisma.pasaje.delete({
     *   where: {
     *     // ... filter to delete one Pasaje
     *   }
     * })
     * 
     */
    delete<T extends PasajeDeleteArgs>(args: SelectSubset<T, PasajeDeleteArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pasaje.
     * @param {PasajeUpdateArgs} args - Arguments to update one Pasaje.
     * @example
     * // Update one Pasaje
     * const pasaje = await prisma.pasaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasajeUpdateArgs>(args: SelectSubset<T, PasajeUpdateArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pasajes.
     * @param {PasajeDeleteManyArgs} args - Arguments to filter Pasajes to delete.
     * @example
     * // Delete a few Pasajes
     * const { count } = await prisma.pasaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasajeDeleteManyArgs>(args?: SelectSubset<T, PasajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pasajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pasajes
     * const pasaje = await prisma.pasaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasajeUpdateManyArgs>(args: SelectSubset<T, PasajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pasajes and returns the data updated in the database.
     * @param {PasajeUpdateManyAndReturnArgs} args - Arguments to update many Pasajes.
     * @example
     * // Update many Pasajes
     * const pasaje = await prisma.pasaje.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pasajes and only return the `id_pasaje`
     * const pasajeWithId_pasajeOnly = await prisma.pasaje.updateManyAndReturn({
     *   select: { id_pasaje: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasajeUpdateManyAndReturnArgs>(args: SelectSubset<T, PasajeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pasaje.
     * @param {PasajeUpsertArgs} args - Arguments to update or create a Pasaje.
     * @example
     * // Update or create a Pasaje
     * const pasaje = await prisma.pasaje.upsert({
     *   create: {
     *     // ... data to create a Pasaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pasaje we want to update
     *   }
     * })
     */
    upsert<T extends PasajeUpsertArgs>(args: SelectSubset<T, PasajeUpsertArgs<ExtArgs>>): Prisma__PasajeClient<$Result.GetResult<Prisma.$PasajePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pasajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeCountArgs} args - Arguments to filter Pasajes to count.
     * @example
     * // Count the number of Pasajes
     * const count = await prisma.pasaje.count({
     *   where: {
     *     // ... the filter for the Pasajes we want to count
     *   }
     * })
    **/
    count<T extends PasajeCountArgs>(
      args?: Subset<T, PasajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pasaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasajeAggregateArgs>(args: Subset<T, PasajeAggregateArgs>): Prisma.PrismaPromise<GetPasajeAggregateType<T>>

    /**
     * Group by Pasaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasajeGroupByArgs['orderBy'] }
        : { orderBy?: PasajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pasaje model
   */
  readonly fields: PasajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pasaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pasaje model
   */
  interface PasajeFieldRefs {
    readonly id_pasaje: FieldRef<"Pasaje", 'Int'>
    readonly id_producto: FieldRef<"Pasaje", 'Int'>
    readonly origen: FieldRef<"Pasaje", 'String'>
    readonly destino: FieldRef<"Pasaje", 'String'>
    readonly fecha_salida: FieldRef<"Pasaje", 'DateTime'>
    readonly fecha_regreso: FieldRef<"Pasaje", 'DateTime'>
    readonly clase: FieldRef<"Pasaje", 'String'>
    readonly asientos_disponibles: FieldRef<"Pasaje", 'Int'>
    readonly aerolinea: FieldRef<"Pasaje", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pasaje findUnique
   */
  export type PasajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter, which Pasaje to fetch.
     */
    where: PasajeWhereUniqueInput
  }

  /**
   * Pasaje findUniqueOrThrow
   */
  export type PasajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter, which Pasaje to fetch.
     */
    where: PasajeWhereUniqueInput
  }

  /**
   * Pasaje findFirst
   */
  export type PasajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter, which Pasaje to fetch.
     */
    where?: PasajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pasajes to fetch.
     */
    orderBy?: PasajeOrderByWithRelationInput | PasajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pasajes.
     */
    cursor?: PasajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pasajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pasajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pasajes.
     */
    distinct?: PasajeScalarFieldEnum | PasajeScalarFieldEnum[]
  }

  /**
   * Pasaje findFirstOrThrow
   */
  export type PasajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter, which Pasaje to fetch.
     */
    where?: PasajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pasajes to fetch.
     */
    orderBy?: PasajeOrderByWithRelationInput | PasajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pasajes.
     */
    cursor?: PasajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pasajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pasajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pasajes.
     */
    distinct?: PasajeScalarFieldEnum | PasajeScalarFieldEnum[]
  }

  /**
   * Pasaje findMany
   */
  export type PasajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter, which Pasajes to fetch.
     */
    where?: PasajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pasajes to fetch.
     */
    orderBy?: PasajeOrderByWithRelationInput | PasajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pasajes.
     */
    cursor?: PasajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pasajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pasajes.
     */
    skip?: number
    distinct?: PasajeScalarFieldEnum | PasajeScalarFieldEnum[]
  }

  /**
   * Pasaje create
   */
  export type PasajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * The data needed to create a Pasaje.
     */
    data: XOR<PasajeCreateInput, PasajeUncheckedCreateInput>
  }

  /**
   * Pasaje createMany
   */
  export type PasajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pasajes.
     */
    data: PasajeCreateManyInput | PasajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pasaje createManyAndReturn
   */
  export type PasajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * The data used to create many Pasajes.
     */
    data: PasajeCreateManyInput | PasajeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pasaje update
   */
  export type PasajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * The data needed to update a Pasaje.
     */
    data: XOR<PasajeUpdateInput, PasajeUncheckedUpdateInput>
    /**
     * Choose, which Pasaje to update.
     */
    where: PasajeWhereUniqueInput
  }

  /**
   * Pasaje updateMany
   */
  export type PasajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pasajes.
     */
    data: XOR<PasajeUpdateManyMutationInput, PasajeUncheckedUpdateManyInput>
    /**
     * Filter which Pasajes to update
     */
    where?: PasajeWhereInput
    /**
     * Limit how many Pasajes to update.
     */
    limit?: number
  }

  /**
   * Pasaje updateManyAndReturn
   */
  export type PasajeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * The data used to update Pasajes.
     */
    data: XOR<PasajeUpdateManyMutationInput, PasajeUncheckedUpdateManyInput>
    /**
     * Filter which Pasajes to update
     */
    where?: PasajeWhereInput
    /**
     * Limit how many Pasajes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pasaje upsert
   */
  export type PasajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * The filter to search for the Pasaje to update in case it exists.
     */
    where: PasajeWhereUniqueInput
    /**
     * In case the Pasaje found by the `where` argument doesn't exist, create a new Pasaje with this data.
     */
    create: XOR<PasajeCreateInput, PasajeUncheckedCreateInput>
    /**
     * In case the Pasaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasajeUpdateInput, PasajeUncheckedUpdateInput>
  }

  /**
   * Pasaje delete
   */
  export type PasajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
    /**
     * Filter which Pasaje to delete.
     */
    where: PasajeWhereUniqueInput
  }

  /**
   * Pasaje deleteMany
   */
  export type PasajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pasajes to delete
     */
    where?: PasajeWhereInput
    /**
     * Limit how many Pasajes to delete.
     */
    limit?: number
  }

  /**
   * Pasaje without action
   */
  export type PasajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pasaje
     */
    select?: PasajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pasaje
     */
    omit?: PasajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasajeInclude<ExtArgs> | null
  }


  /**
   * Model Alquiler
   */

  export type AggregateAlquiler = {
    _count: AlquilerCountAggregateOutputType | null
    _avg: AlquilerAvgAggregateOutputType | null
    _sum: AlquilerSumAggregateOutputType | null
    _min: AlquilerMinAggregateOutputType | null
    _max: AlquilerMaxAggregateOutputType | null
  }

  export type AlquilerAvgAggregateOutputType = {
    id_alquiler: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type AlquilerSumAggregateOutputType = {
    id_alquiler: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type AlquilerMinAggregateOutputType = {
    id_alquiler: number | null
    id_producto: number | null
    tipo_vehiculo: string | null
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    cantidad: number | null
  }

  export type AlquilerMaxAggregateOutputType = {
    id_alquiler: number | null
    id_producto: number | null
    tipo_vehiculo: string | null
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    cantidad: number | null
  }

  export type AlquilerCountAggregateOutputType = {
    id_alquiler: number
    id_producto: number
    tipo_vehiculo: number
    ubicacion: number
    fecha_inicio: number
    fecha_fin: number
    cantidad: number
    _all: number
  }


  export type AlquilerAvgAggregateInputType = {
    id_alquiler?: true
    id_producto?: true
    cantidad?: true
  }

  export type AlquilerSumAggregateInputType = {
    id_alquiler?: true
    id_producto?: true
    cantidad?: true
  }

  export type AlquilerMinAggregateInputType = {
    id_alquiler?: true
    id_producto?: true
    tipo_vehiculo?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    cantidad?: true
  }

  export type AlquilerMaxAggregateInputType = {
    id_alquiler?: true
    id_producto?: true
    tipo_vehiculo?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    cantidad?: true
  }

  export type AlquilerCountAggregateInputType = {
    id_alquiler?: true
    id_producto?: true
    tipo_vehiculo?: true
    ubicacion?: true
    fecha_inicio?: true
    fecha_fin?: true
    cantidad?: true
    _all?: true
  }

  export type AlquilerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alquiler to aggregate.
     */
    where?: AlquilerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alquilers to fetch.
     */
    orderBy?: AlquilerOrderByWithRelationInput | AlquilerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alquilers
    **/
    _count?: true | AlquilerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlquilerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlquilerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlquilerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlquilerMaxAggregateInputType
  }

  export type GetAlquilerAggregateType<T extends AlquilerAggregateArgs> = {
        [P in keyof T & keyof AggregateAlquiler]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlquiler[P]>
      : GetScalarType<T[P], AggregateAlquiler[P]>
  }




  export type AlquilerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlquilerWhereInput
    orderBy?: AlquilerOrderByWithAggregationInput | AlquilerOrderByWithAggregationInput[]
    by: AlquilerScalarFieldEnum[] | AlquilerScalarFieldEnum
    having?: AlquilerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlquilerCountAggregateInputType | true
    _avg?: AlquilerAvgAggregateInputType
    _sum?: AlquilerSumAggregateInputType
    _min?: AlquilerMinAggregateInputType
    _max?: AlquilerMaxAggregateInputType
  }

  export type AlquilerGroupByOutputType = {
    id_alquiler: number
    id_producto: number
    tipo_vehiculo: string | null
    ubicacion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    cantidad: number
    _count: AlquilerCountAggregateOutputType | null
    _avg: AlquilerAvgAggregateOutputType | null
    _sum: AlquilerSumAggregateOutputType | null
    _min: AlquilerMinAggregateOutputType | null
    _max: AlquilerMaxAggregateOutputType | null
  }

  type GetAlquilerGroupByPayload<T extends AlquilerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlquilerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlquilerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlquilerGroupByOutputType[P]>
            : GetScalarType<T[P], AlquilerGroupByOutputType[P]>
        }
      >
    >


  export type AlquilerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alquiler?: boolean
    id_producto?: boolean
    tipo_vehiculo?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    cantidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alquiler"]>

  export type AlquilerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alquiler?: boolean
    id_producto?: boolean
    tipo_vehiculo?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    cantidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alquiler"]>

  export type AlquilerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alquiler?: boolean
    id_producto?: boolean
    tipo_vehiculo?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    cantidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alquiler"]>

  export type AlquilerSelectScalar = {
    id_alquiler?: boolean
    id_producto?: boolean
    tipo_vehiculo?: boolean
    ubicacion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    cantidad?: boolean
  }

  export type AlquilerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_alquiler" | "id_producto" | "tipo_vehiculo" | "ubicacion" | "fecha_inicio" | "fecha_fin" | "cantidad", ExtArgs["result"]["alquiler"]>
  export type AlquilerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type AlquilerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type AlquilerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $AlquilerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alquiler"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alquiler: number
      id_producto: number
      tipo_vehiculo: string | null
      ubicacion: string | null
      fecha_inicio: Date | null
      fecha_fin: Date | null
      cantidad: number
    }, ExtArgs["result"]["alquiler"]>
    composites: {}
  }

  type AlquilerGetPayload<S extends boolean | null | undefined | AlquilerDefaultArgs> = $Result.GetResult<Prisma.$AlquilerPayload, S>

  type AlquilerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlquilerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlquilerCountAggregateInputType | true
    }

  export interface AlquilerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alquiler'], meta: { name: 'Alquiler' } }
    /**
     * Find zero or one Alquiler that matches the filter.
     * @param {AlquilerFindUniqueArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlquilerFindUniqueArgs>(args: SelectSubset<T, AlquilerFindUniqueArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alquiler that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlquilerFindUniqueOrThrowArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlquilerFindUniqueOrThrowArgs>(args: SelectSubset<T, AlquilerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alquiler that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerFindFirstArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlquilerFindFirstArgs>(args?: SelectSubset<T, AlquilerFindFirstArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alquiler that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerFindFirstOrThrowArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlquilerFindFirstOrThrowArgs>(args?: SelectSubset<T, AlquilerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alquilers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alquilers
     * const alquilers = await prisma.alquiler.findMany()
     * 
     * // Get first 10 Alquilers
     * const alquilers = await prisma.alquiler.findMany({ take: 10 })
     * 
     * // Only select the `id_alquiler`
     * const alquilerWithId_alquilerOnly = await prisma.alquiler.findMany({ select: { id_alquiler: true } })
     * 
     */
    findMany<T extends AlquilerFindManyArgs>(args?: SelectSubset<T, AlquilerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alquiler.
     * @param {AlquilerCreateArgs} args - Arguments to create a Alquiler.
     * @example
     * // Create one Alquiler
     * const Alquiler = await prisma.alquiler.create({
     *   data: {
     *     // ... data to create a Alquiler
     *   }
     * })
     * 
     */
    create<T extends AlquilerCreateArgs>(args: SelectSubset<T, AlquilerCreateArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alquilers.
     * @param {AlquilerCreateManyArgs} args - Arguments to create many Alquilers.
     * @example
     * // Create many Alquilers
     * const alquiler = await prisma.alquiler.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlquilerCreateManyArgs>(args?: SelectSubset<T, AlquilerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alquilers and returns the data saved in the database.
     * @param {AlquilerCreateManyAndReturnArgs} args - Arguments to create many Alquilers.
     * @example
     * // Create many Alquilers
     * const alquiler = await prisma.alquiler.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alquilers and only return the `id_alquiler`
     * const alquilerWithId_alquilerOnly = await prisma.alquiler.createManyAndReturn({
     *   select: { id_alquiler: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlquilerCreateManyAndReturnArgs>(args?: SelectSubset<T, AlquilerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alquiler.
     * @param {AlquilerDeleteArgs} args - Arguments to delete one Alquiler.
     * @example
     * // Delete one Alquiler
     * const Alquiler = await prisma.alquiler.delete({
     *   where: {
     *     // ... filter to delete one Alquiler
     *   }
     * })
     * 
     */
    delete<T extends AlquilerDeleteArgs>(args: SelectSubset<T, AlquilerDeleteArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alquiler.
     * @param {AlquilerUpdateArgs} args - Arguments to update one Alquiler.
     * @example
     * // Update one Alquiler
     * const alquiler = await prisma.alquiler.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlquilerUpdateArgs>(args: SelectSubset<T, AlquilerUpdateArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alquilers.
     * @param {AlquilerDeleteManyArgs} args - Arguments to filter Alquilers to delete.
     * @example
     * // Delete a few Alquilers
     * const { count } = await prisma.alquiler.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlquilerDeleteManyArgs>(args?: SelectSubset<T, AlquilerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alquilers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alquilers
     * const alquiler = await prisma.alquiler.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlquilerUpdateManyArgs>(args: SelectSubset<T, AlquilerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alquilers and returns the data updated in the database.
     * @param {AlquilerUpdateManyAndReturnArgs} args - Arguments to update many Alquilers.
     * @example
     * // Update many Alquilers
     * const alquiler = await prisma.alquiler.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alquilers and only return the `id_alquiler`
     * const alquilerWithId_alquilerOnly = await prisma.alquiler.updateManyAndReturn({
     *   select: { id_alquiler: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlquilerUpdateManyAndReturnArgs>(args: SelectSubset<T, AlquilerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alquiler.
     * @param {AlquilerUpsertArgs} args - Arguments to update or create a Alquiler.
     * @example
     * // Update or create a Alquiler
     * const alquiler = await prisma.alquiler.upsert({
     *   create: {
     *     // ... data to create a Alquiler
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alquiler we want to update
     *   }
     * })
     */
    upsert<T extends AlquilerUpsertArgs>(args: SelectSubset<T, AlquilerUpsertArgs<ExtArgs>>): Prisma__AlquilerClient<$Result.GetResult<Prisma.$AlquilerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alquilers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerCountArgs} args - Arguments to filter Alquilers to count.
     * @example
     * // Count the number of Alquilers
     * const count = await prisma.alquiler.count({
     *   where: {
     *     // ... the filter for the Alquilers we want to count
     *   }
     * })
    **/
    count<T extends AlquilerCountArgs>(
      args?: Subset<T, AlquilerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlquilerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alquiler.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlquilerAggregateArgs>(args: Subset<T, AlquilerAggregateArgs>): Prisma.PrismaPromise<GetAlquilerAggregateType<T>>

    /**
     * Group by Alquiler.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlquilerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlquilerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlquilerGroupByArgs['orderBy'] }
        : { orderBy?: AlquilerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlquilerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlquilerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alquiler model
   */
  readonly fields: AlquilerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alquiler.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlquilerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alquiler model
   */
  interface AlquilerFieldRefs {
    readonly id_alquiler: FieldRef<"Alquiler", 'Int'>
    readonly id_producto: FieldRef<"Alquiler", 'Int'>
    readonly tipo_vehiculo: FieldRef<"Alquiler", 'String'>
    readonly ubicacion: FieldRef<"Alquiler", 'String'>
    readonly fecha_inicio: FieldRef<"Alquiler", 'DateTime'>
    readonly fecha_fin: FieldRef<"Alquiler", 'DateTime'>
    readonly cantidad: FieldRef<"Alquiler", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Alquiler findUnique
   */
  export type AlquilerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter, which Alquiler to fetch.
     */
    where: AlquilerWhereUniqueInput
  }

  /**
   * Alquiler findUniqueOrThrow
   */
  export type AlquilerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter, which Alquiler to fetch.
     */
    where: AlquilerWhereUniqueInput
  }

  /**
   * Alquiler findFirst
   */
  export type AlquilerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter, which Alquiler to fetch.
     */
    where?: AlquilerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alquilers to fetch.
     */
    orderBy?: AlquilerOrderByWithRelationInput | AlquilerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alquilers.
     */
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alquilers.
     */
    distinct?: AlquilerScalarFieldEnum | AlquilerScalarFieldEnum[]
  }

  /**
   * Alquiler findFirstOrThrow
   */
  export type AlquilerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter, which Alquiler to fetch.
     */
    where?: AlquilerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alquilers to fetch.
     */
    orderBy?: AlquilerOrderByWithRelationInput | AlquilerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alquilers.
     */
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alquilers.
     */
    distinct?: AlquilerScalarFieldEnum | AlquilerScalarFieldEnum[]
  }

  /**
   * Alquiler findMany
   */
  export type AlquilerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter, which Alquilers to fetch.
     */
    where?: AlquilerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alquilers to fetch.
     */
    orderBy?: AlquilerOrderByWithRelationInput | AlquilerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alquilers.
     */
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
     */
    skip?: number
    distinct?: AlquilerScalarFieldEnum | AlquilerScalarFieldEnum[]
  }

  /**
   * Alquiler create
   */
  export type AlquilerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * The data needed to create a Alquiler.
     */
    data: XOR<AlquilerCreateInput, AlquilerUncheckedCreateInput>
  }

  /**
   * Alquiler createMany
   */
  export type AlquilerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alquilers.
     */
    data: AlquilerCreateManyInput | AlquilerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alquiler createManyAndReturn
   */
  export type AlquilerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * The data used to create many Alquilers.
     */
    data: AlquilerCreateManyInput | AlquilerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alquiler update
   */
  export type AlquilerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * The data needed to update a Alquiler.
     */
    data: XOR<AlquilerUpdateInput, AlquilerUncheckedUpdateInput>
    /**
     * Choose, which Alquiler to update.
     */
    where: AlquilerWhereUniqueInput
  }

  /**
   * Alquiler updateMany
   */
  export type AlquilerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alquilers.
     */
    data: XOR<AlquilerUpdateManyMutationInput, AlquilerUncheckedUpdateManyInput>
    /**
     * Filter which Alquilers to update
     */
    where?: AlquilerWhereInput
    /**
     * Limit how many Alquilers to update.
     */
    limit?: number
  }

  /**
   * Alquiler updateManyAndReturn
   */
  export type AlquilerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * The data used to update Alquilers.
     */
    data: XOR<AlquilerUpdateManyMutationInput, AlquilerUncheckedUpdateManyInput>
    /**
     * Filter which Alquilers to update
     */
    where?: AlquilerWhereInput
    /**
     * Limit how many Alquilers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alquiler upsert
   */
  export type AlquilerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * The filter to search for the Alquiler to update in case it exists.
     */
    where: AlquilerWhereUniqueInput
    /**
     * In case the Alquiler found by the `where` argument doesn't exist, create a new Alquiler with this data.
     */
    create: XOR<AlquilerCreateInput, AlquilerUncheckedCreateInput>
    /**
     * In case the Alquiler was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlquilerUpdateInput, AlquilerUncheckedUpdateInput>
  }

  /**
   * Alquiler delete
   */
  export type AlquilerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
    /**
     * Filter which Alquiler to delete.
     */
    where: AlquilerWhereUniqueInput
  }

  /**
   * Alquiler deleteMany
   */
  export type AlquilerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alquilers to delete
     */
    where?: AlquilerWhereInput
    /**
     * Limit how many Alquilers to delete.
     */
    limit?: number
  }

  /**
   * Alquiler without action
   */
  export type AlquilerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alquiler
     */
    select?: AlquilerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alquiler
     */
    omit?: AlquilerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlquilerInclude<ExtArgs> | null
  }


  /**
   * Model PaqueteDetalle
   */

  export type AggregatePaqueteDetalle = {
    _count: PaqueteDetalleCountAggregateOutputType | null
    _avg: PaqueteDetalleAvgAggregateOutputType | null
    _sum: PaqueteDetalleSumAggregateOutputType | null
    _min: PaqueteDetalleMinAggregateOutputType | null
    _max: PaqueteDetalleMaxAggregateOutputType | null
  }

  export type PaqueteDetalleAvgAggregateOutputType = {
    id_detalle: number | null
    id_paquete: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type PaqueteDetalleSumAggregateOutputType = {
    id_detalle: number | null
    id_paquete: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type PaqueteDetalleMinAggregateOutputType = {
    id_detalle: number | null
    id_paquete: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type PaqueteDetalleMaxAggregateOutputType = {
    id_detalle: number | null
    id_paquete: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type PaqueteDetalleCountAggregateOutputType = {
    id_detalle: number
    id_paquete: number
    id_producto: number
    cantidad: number
    _all: number
  }


  export type PaqueteDetalleAvgAggregateInputType = {
    id_detalle?: true
    id_paquete?: true
    id_producto?: true
    cantidad?: true
  }

  export type PaqueteDetalleSumAggregateInputType = {
    id_detalle?: true
    id_paquete?: true
    id_producto?: true
    cantidad?: true
  }

  export type PaqueteDetalleMinAggregateInputType = {
    id_detalle?: true
    id_paquete?: true
    id_producto?: true
    cantidad?: true
  }

  export type PaqueteDetalleMaxAggregateInputType = {
    id_detalle?: true
    id_paquete?: true
    id_producto?: true
    cantidad?: true
  }

  export type PaqueteDetalleCountAggregateInputType = {
    id_detalle?: true
    id_paquete?: true
    id_producto?: true
    cantidad?: true
    _all?: true
  }

  export type PaqueteDetalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteDetalle to aggregate.
     */
    where?: PaqueteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteDetalles to fetch.
     */
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaqueteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaqueteDetalles
    **/
    _count?: true | PaqueteDetalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteDetalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteDetalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteDetalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteDetalleMaxAggregateInputType
  }

  export type GetPaqueteDetalleAggregateType<T extends PaqueteDetalleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaqueteDetalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaqueteDetalle[P]>
      : GetScalarType<T[P], AggregatePaqueteDetalle[P]>
  }




  export type PaqueteDetalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteDetalleWhereInput
    orderBy?: PaqueteDetalleOrderByWithAggregationInput | PaqueteDetalleOrderByWithAggregationInput[]
    by: PaqueteDetalleScalarFieldEnum[] | PaqueteDetalleScalarFieldEnum
    having?: PaqueteDetalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteDetalleCountAggregateInputType | true
    _avg?: PaqueteDetalleAvgAggregateInputType
    _sum?: PaqueteDetalleSumAggregateInputType
    _min?: PaqueteDetalleMinAggregateInputType
    _max?: PaqueteDetalleMaxAggregateInputType
  }

  export type PaqueteDetalleGroupByOutputType = {
    id_detalle: number
    id_paquete: number
    id_producto: number
    cantidad: number
    _count: PaqueteDetalleCountAggregateOutputType | null
    _avg: PaqueteDetalleAvgAggregateOutputType | null
    _sum: PaqueteDetalleSumAggregateOutputType | null
    _min: PaqueteDetalleMinAggregateOutputType | null
    _max: PaqueteDetalleMaxAggregateOutputType | null
  }

  type GetPaqueteDetalleGroupByPayload<T extends PaqueteDetalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaqueteDetalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaqueteDetalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaqueteDetalleGroupByOutputType[P]>
            : GetScalarType<T[P], PaqueteDetalleGroupByOutputType[P]>
        }
      >
    >


  export type PaqueteDetalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_paquete?: boolean
    id_producto?: boolean
    cantidad?: boolean
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteDetalle"]>

  export type PaqueteDetalleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_paquete?: boolean
    id_producto?: boolean
    cantidad?: boolean
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteDetalle"]>

  export type PaqueteDetalleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_paquete?: boolean
    id_producto?: boolean
    cantidad?: boolean
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteDetalle"]>

  export type PaqueteDetalleSelectScalar = {
    id_detalle?: boolean
    id_paquete?: boolean
    id_producto?: boolean
    cantidad?: boolean
  }

  export type PaqueteDetalleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_detalle" | "id_paquete" | "id_producto" | "cantidad", ExtArgs["result"]["paqueteDetalle"]>
  export type PaqueteDetalleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PaqueteDetalleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PaqueteDetalleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | ProductoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $PaqueteDetallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaqueteDetalle"
    objects: {
      paquete: Prisma.$ProductoPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_detalle: number
      id_paquete: number
      id_producto: number
      cantidad: number
    }, ExtArgs["result"]["paqueteDetalle"]>
    composites: {}
  }

  type PaqueteDetalleGetPayload<S extends boolean | null | undefined | PaqueteDetalleDefaultArgs> = $Result.GetResult<Prisma.$PaqueteDetallePayload, S>

  type PaqueteDetalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaqueteDetalleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaqueteDetalleCountAggregateInputType | true
    }

  export interface PaqueteDetalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaqueteDetalle'], meta: { name: 'PaqueteDetalle' } }
    /**
     * Find zero or one PaqueteDetalle that matches the filter.
     * @param {PaqueteDetalleFindUniqueArgs} args - Arguments to find a PaqueteDetalle
     * @example
     * // Get one PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaqueteDetalleFindUniqueArgs>(args: SelectSubset<T, PaqueteDetalleFindUniqueArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaqueteDetalle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaqueteDetalleFindUniqueOrThrowArgs} args - Arguments to find a PaqueteDetalle
     * @example
     * // Get one PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaqueteDetalleFindUniqueOrThrowArgs>(args: SelectSubset<T, PaqueteDetalleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteDetalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleFindFirstArgs} args - Arguments to find a PaqueteDetalle
     * @example
     * // Get one PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaqueteDetalleFindFirstArgs>(args?: SelectSubset<T, PaqueteDetalleFindFirstArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteDetalle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleFindFirstOrThrowArgs} args - Arguments to find a PaqueteDetalle
     * @example
     * // Get one PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaqueteDetalleFindFirstOrThrowArgs>(args?: SelectSubset<T, PaqueteDetalleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaqueteDetalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaqueteDetalles
     * const paqueteDetalles = await prisma.paqueteDetalle.findMany()
     * 
     * // Get first 10 PaqueteDetalles
     * const paqueteDetalles = await prisma.paqueteDetalle.findMany({ take: 10 })
     * 
     * // Only select the `id_detalle`
     * const paqueteDetalleWithId_detalleOnly = await prisma.paqueteDetalle.findMany({ select: { id_detalle: true } })
     * 
     */
    findMany<T extends PaqueteDetalleFindManyArgs>(args?: SelectSubset<T, PaqueteDetalleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaqueteDetalle.
     * @param {PaqueteDetalleCreateArgs} args - Arguments to create a PaqueteDetalle.
     * @example
     * // Create one PaqueteDetalle
     * const PaqueteDetalle = await prisma.paqueteDetalle.create({
     *   data: {
     *     // ... data to create a PaqueteDetalle
     *   }
     * })
     * 
     */
    create<T extends PaqueteDetalleCreateArgs>(args: SelectSubset<T, PaqueteDetalleCreateArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaqueteDetalles.
     * @param {PaqueteDetalleCreateManyArgs} args - Arguments to create many PaqueteDetalles.
     * @example
     * // Create many PaqueteDetalles
     * const paqueteDetalle = await prisma.paqueteDetalle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaqueteDetalleCreateManyArgs>(args?: SelectSubset<T, PaqueteDetalleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaqueteDetalles and returns the data saved in the database.
     * @param {PaqueteDetalleCreateManyAndReturnArgs} args - Arguments to create many PaqueteDetalles.
     * @example
     * // Create many PaqueteDetalles
     * const paqueteDetalle = await prisma.paqueteDetalle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaqueteDetalles and only return the `id_detalle`
     * const paqueteDetalleWithId_detalleOnly = await prisma.paqueteDetalle.createManyAndReturn({
     *   select: { id_detalle: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaqueteDetalleCreateManyAndReturnArgs>(args?: SelectSubset<T, PaqueteDetalleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaqueteDetalle.
     * @param {PaqueteDetalleDeleteArgs} args - Arguments to delete one PaqueteDetalle.
     * @example
     * // Delete one PaqueteDetalle
     * const PaqueteDetalle = await prisma.paqueteDetalle.delete({
     *   where: {
     *     // ... filter to delete one PaqueteDetalle
     *   }
     * })
     * 
     */
    delete<T extends PaqueteDetalleDeleteArgs>(args: SelectSubset<T, PaqueteDetalleDeleteArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaqueteDetalle.
     * @param {PaqueteDetalleUpdateArgs} args - Arguments to update one PaqueteDetalle.
     * @example
     * // Update one PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaqueteDetalleUpdateArgs>(args: SelectSubset<T, PaqueteDetalleUpdateArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaqueteDetalles.
     * @param {PaqueteDetalleDeleteManyArgs} args - Arguments to filter PaqueteDetalles to delete.
     * @example
     * // Delete a few PaqueteDetalles
     * const { count } = await prisma.paqueteDetalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaqueteDetalleDeleteManyArgs>(args?: SelectSubset<T, PaqueteDetalleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaqueteDetalles
     * const paqueteDetalle = await prisma.paqueteDetalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaqueteDetalleUpdateManyArgs>(args: SelectSubset<T, PaqueteDetalleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteDetalles and returns the data updated in the database.
     * @param {PaqueteDetalleUpdateManyAndReturnArgs} args - Arguments to update many PaqueteDetalles.
     * @example
     * // Update many PaqueteDetalles
     * const paqueteDetalle = await prisma.paqueteDetalle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaqueteDetalles and only return the `id_detalle`
     * const paqueteDetalleWithId_detalleOnly = await prisma.paqueteDetalle.updateManyAndReturn({
     *   select: { id_detalle: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaqueteDetalleUpdateManyAndReturnArgs>(args: SelectSubset<T, PaqueteDetalleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaqueteDetalle.
     * @param {PaqueteDetalleUpsertArgs} args - Arguments to update or create a PaqueteDetalle.
     * @example
     * // Update or create a PaqueteDetalle
     * const paqueteDetalle = await prisma.paqueteDetalle.upsert({
     *   create: {
     *     // ... data to create a PaqueteDetalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaqueteDetalle we want to update
     *   }
     * })
     */
    upsert<T extends PaqueteDetalleUpsertArgs>(args: SelectSubset<T, PaqueteDetalleUpsertArgs<ExtArgs>>): Prisma__PaqueteDetalleClient<$Result.GetResult<Prisma.$PaqueteDetallePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaqueteDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleCountArgs} args - Arguments to filter PaqueteDetalles to count.
     * @example
     * // Count the number of PaqueteDetalles
     * const count = await prisma.paqueteDetalle.count({
     *   where: {
     *     // ... the filter for the PaqueteDetalles we want to count
     *   }
     * })
    **/
    count<T extends PaqueteDetalleCountArgs>(
      args?: Subset<T, PaqueteDetalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteDetalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaqueteDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteDetalleAggregateArgs>(args: Subset<T, PaqueteDetalleAggregateArgs>): Prisma.PrismaPromise<GetPaqueteDetalleAggregateType<T>>

    /**
     * Group by PaqueteDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteDetalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteDetalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteDetalleGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteDetalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteDetalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteDetalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaqueteDetalle model
   */
  readonly fields: PaqueteDetalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaqueteDetalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaqueteDetalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paquete<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaqueteDetalle model
   */
  interface PaqueteDetalleFieldRefs {
    readonly id_detalle: FieldRef<"PaqueteDetalle", 'Int'>
    readonly id_paquete: FieldRef<"PaqueteDetalle", 'Int'>
    readonly id_producto: FieldRef<"PaqueteDetalle", 'Int'>
    readonly cantidad: FieldRef<"PaqueteDetalle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PaqueteDetalle findUnique
   */
  export type PaqueteDetalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteDetalle to fetch.
     */
    where: PaqueteDetalleWhereUniqueInput
  }

  /**
   * PaqueteDetalle findUniqueOrThrow
   */
  export type PaqueteDetalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteDetalle to fetch.
     */
    where: PaqueteDetalleWhereUniqueInput
  }

  /**
   * PaqueteDetalle findFirst
   */
  export type PaqueteDetalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteDetalle to fetch.
     */
    where?: PaqueteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteDetalles to fetch.
     */
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteDetalles.
     */
    cursor?: PaqueteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteDetalles.
     */
    distinct?: PaqueteDetalleScalarFieldEnum | PaqueteDetalleScalarFieldEnum[]
  }

  /**
   * PaqueteDetalle findFirstOrThrow
   */
  export type PaqueteDetalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteDetalle to fetch.
     */
    where?: PaqueteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteDetalles to fetch.
     */
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteDetalles.
     */
    cursor?: PaqueteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteDetalles.
     */
    distinct?: PaqueteDetalleScalarFieldEnum | PaqueteDetalleScalarFieldEnum[]
  }

  /**
   * PaqueteDetalle findMany
   */
  export type PaqueteDetalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteDetalles to fetch.
     */
    where?: PaqueteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteDetalles to fetch.
     */
    orderBy?: PaqueteDetalleOrderByWithRelationInput | PaqueteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaqueteDetalles.
     */
    cursor?: PaqueteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteDetalles.
     */
    skip?: number
    distinct?: PaqueteDetalleScalarFieldEnum | PaqueteDetalleScalarFieldEnum[]
  }

  /**
   * PaqueteDetalle create
   */
  export type PaqueteDetalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * The data needed to create a PaqueteDetalle.
     */
    data: XOR<PaqueteDetalleCreateInput, PaqueteDetalleUncheckedCreateInput>
  }

  /**
   * PaqueteDetalle createMany
   */
  export type PaqueteDetalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaqueteDetalles.
     */
    data: PaqueteDetalleCreateManyInput | PaqueteDetalleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaqueteDetalle createManyAndReturn
   */
  export type PaqueteDetalleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * The data used to create many PaqueteDetalles.
     */
    data: PaqueteDetalleCreateManyInput | PaqueteDetalleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteDetalle update
   */
  export type PaqueteDetalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * The data needed to update a PaqueteDetalle.
     */
    data: XOR<PaqueteDetalleUpdateInput, PaqueteDetalleUncheckedUpdateInput>
    /**
     * Choose, which PaqueteDetalle to update.
     */
    where: PaqueteDetalleWhereUniqueInput
  }

  /**
   * PaqueteDetalle updateMany
   */
  export type PaqueteDetalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaqueteDetalles.
     */
    data: XOR<PaqueteDetalleUpdateManyMutationInput, PaqueteDetalleUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteDetalles to update
     */
    where?: PaqueteDetalleWhereInput
    /**
     * Limit how many PaqueteDetalles to update.
     */
    limit?: number
  }

  /**
   * PaqueteDetalle updateManyAndReturn
   */
  export type PaqueteDetalleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * The data used to update PaqueteDetalles.
     */
    data: XOR<PaqueteDetalleUpdateManyMutationInput, PaqueteDetalleUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteDetalles to update
     */
    where?: PaqueteDetalleWhereInput
    /**
     * Limit how many PaqueteDetalles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteDetalle upsert
   */
  export type PaqueteDetalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * The filter to search for the PaqueteDetalle to update in case it exists.
     */
    where: PaqueteDetalleWhereUniqueInput
    /**
     * In case the PaqueteDetalle found by the `where` argument doesn't exist, create a new PaqueteDetalle with this data.
     */
    create: XOR<PaqueteDetalleCreateInput, PaqueteDetalleUncheckedCreateInput>
    /**
     * In case the PaqueteDetalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaqueteDetalleUpdateInput, PaqueteDetalleUncheckedUpdateInput>
  }

  /**
   * PaqueteDetalle delete
   */
  export type PaqueteDetalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
    /**
     * Filter which PaqueteDetalle to delete.
     */
    where: PaqueteDetalleWhereUniqueInput
  }

  /**
   * PaqueteDetalle deleteMany
   */
  export type PaqueteDetalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteDetalles to delete
     */
    where?: PaqueteDetalleWhereInput
    /**
     * Limit how many PaqueteDetalles to delete.
     */
    limit?: number
  }

  /**
   * PaqueteDetalle without action
   */
  export type PaqueteDetalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteDetalle
     */
    select?: PaqueteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteDetalle
     */
    omit?: PaqueteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteDetalleInclude<ExtArgs> | null
  }


  /**
   * Model Carrito
   */

  export type AggregateCarrito = {
    _count: CarritoCountAggregateOutputType | null
    _avg: CarritoAvgAggregateOutputType | null
    _sum: CarritoSumAggregateOutputType | null
    _min: CarritoMinAggregateOutputType | null
    _max: CarritoMaxAggregateOutputType | null
  }

  export type CarritoAvgAggregateOutputType = {
    id_carrito: number | null
    id_cliente: number | null
  }

  export type CarritoSumAggregateOutputType = {
    id_carrito: number | null
    id_cliente: number | null
  }

  export type CarritoMinAggregateOutputType = {
    id_carrito: number | null
    id_cliente: number | null
    fecha_creacion: Date | null
  }

  export type CarritoMaxAggregateOutputType = {
    id_carrito: number | null
    id_cliente: number | null
    fecha_creacion: Date | null
  }

  export type CarritoCountAggregateOutputType = {
    id_carrito: number
    id_cliente: number
    fecha_creacion: number
    _all: number
  }


  export type CarritoAvgAggregateInputType = {
    id_carrito?: true
    id_cliente?: true
  }

  export type CarritoSumAggregateInputType = {
    id_carrito?: true
    id_cliente?: true
  }

  export type CarritoMinAggregateInputType = {
    id_carrito?: true
    id_cliente?: true
    fecha_creacion?: true
  }

  export type CarritoMaxAggregateInputType = {
    id_carrito?: true
    id_cliente?: true
    fecha_creacion?: true
  }

  export type CarritoCountAggregateInputType = {
    id_carrito?: true
    id_cliente?: true
    fecha_creacion?: true
    _all?: true
  }

  export type CarritoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carrito to aggregate.
     */
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     */
    orderBy?: CarritoOrderByWithRelationInput | CarritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carritos
    **/
    _count?: true | CarritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarritoMaxAggregateInputType
  }

  export type GetCarritoAggregateType<T extends CarritoAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrito[P]>
      : GetScalarType<T[P], AggregateCarrito[P]>
  }




  export type CarritoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarritoWhereInput
    orderBy?: CarritoOrderByWithAggregationInput | CarritoOrderByWithAggregationInput[]
    by: CarritoScalarFieldEnum[] | CarritoScalarFieldEnum
    having?: CarritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarritoCountAggregateInputType | true
    _avg?: CarritoAvgAggregateInputType
    _sum?: CarritoSumAggregateInputType
    _min?: CarritoMinAggregateInputType
    _max?: CarritoMaxAggregateInputType
  }

  export type CarritoGroupByOutputType = {
    id_carrito: number
    id_cliente: number
    fecha_creacion: Date
    _count: CarritoCountAggregateOutputType | null
    _avg: CarritoAvgAggregateOutputType | null
    _sum: CarritoSumAggregateOutputType | null
    _min: CarritoMinAggregateOutputType | null
    _max: CarritoMaxAggregateOutputType | null
  }

  type GetCarritoGroupByPayload<T extends CarritoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarritoGroupByOutputType[P]>
            : GetScalarType<T[P], CarritoGroupByOutputType[P]>
        }
      >
    >


  export type CarritoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carrito?: boolean
    id_cliente?: boolean
    fecha_creacion?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | Carrito$itemsArgs<ExtArgs>
    _count?: boolean | CarritoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrito"]>

  export type CarritoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carrito?: boolean
    id_cliente?: boolean
    fecha_creacion?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrito"]>

  export type CarritoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carrito?: boolean
    id_cliente?: boolean
    fecha_creacion?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrito"]>

  export type CarritoSelectScalar = {
    id_carrito?: boolean
    id_cliente?: boolean
    fecha_creacion?: boolean
  }

  export type CarritoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_carrito" | "id_cliente" | "fecha_creacion", ExtArgs["result"]["carrito"]>
  export type CarritoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | Carrito$itemsArgs<ExtArgs>
    _count?: boolean | CarritoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarritoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type CarritoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $CarritoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carrito"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      items: Prisma.$CarritoItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_carrito: number
      id_cliente: number
      fecha_creacion: Date
    }, ExtArgs["result"]["carrito"]>
    composites: {}
  }

  type CarritoGetPayload<S extends boolean | null | undefined | CarritoDefaultArgs> = $Result.GetResult<Prisma.$CarritoPayload, S>

  type CarritoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarritoCountAggregateInputType | true
    }

  export interface CarritoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carrito'], meta: { name: 'Carrito' } }
    /**
     * Find zero or one Carrito that matches the filter.
     * @param {CarritoFindUniqueArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarritoFindUniqueArgs>(args: SelectSubset<T, CarritoFindUniqueArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carrito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarritoFindUniqueOrThrowArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarritoFindUniqueOrThrowArgs>(args: SelectSubset<T, CarritoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindFirstArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarritoFindFirstArgs>(args?: SelectSubset<T, CarritoFindFirstArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carrito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindFirstOrThrowArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarritoFindFirstOrThrowArgs>(args?: SelectSubset<T, CarritoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carritos
     * const carritos = await prisma.carrito.findMany()
     * 
     * // Get first 10 Carritos
     * const carritos = await prisma.carrito.findMany({ take: 10 })
     * 
     * // Only select the `id_carrito`
     * const carritoWithId_carritoOnly = await prisma.carrito.findMany({ select: { id_carrito: true } })
     * 
     */
    findMany<T extends CarritoFindManyArgs>(args?: SelectSubset<T, CarritoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carrito.
     * @param {CarritoCreateArgs} args - Arguments to create a Carrito.
     * @example
     * // Create one Carrito
     * const Carrito = await prisma.carrito.create({
     *   data: {
     *     // ... data to create a Carrito
     *   }
     * })
     * 
     */
    create<T extends CarritoCreateArgs>(args: SelectSubset<T, CarritoCreateArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carritos.
     * @param {CarritoCreateManyArgs} args - Arguments to create many Carritos.
     * @example
     * // Create many Carritos
     * const carrito = await prisma.carrito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarritoCreateManyArgs>(args?: SelectSubset<T, CarritoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carritos and returns the data saved in the database.
     * @param {CarritoCreateManyAndReturnArgs} args - Arguments to create many Carritos.
     * @example
     * // Create many Carritos
     * const carrito = await prisma.carrito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carritos and only return the `id_carrito`
     * const carritoWithId_carritoOnly = await prisma.carrito.createManyAndReturn({
     *   select: { id_carrito: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarritoCreateManyAndReturnArgs>(args?: SelectSubset<T, CarritoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carrito.
     * @param {CarritoDeleteArgs} args - Arguments to delete one Carrito.
     * @example
     * // Delete one Carrito
     * const Carrito = await prisma.carrito.delete({
     *   where: {
     *     // ... filter to delete one Carrito
     *   }
     * })
     * 
     */
    delete<T extends CarritoDeleteArgs>(args: SelectSubset<T, CarritoDeleteArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carrito.
     * @param {CarritoUpdateArgs} args - Arguments to update one Carrito.
     * @example
     * // Update one Carrito
     * const carrito = await prisma.carrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarritoUpdateArgs>(args: SelectSubset<T, CarritoUpdateArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carritos.
     * @param {CarritoDeleteManyArgs} args - Arguments to filter Carritos to delete.
     * @example
     * // Delete a few Carritos
     * const { count } = await prisma.carrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarritoDeleteManyArgs>(args?: SelectSubset<T, CarritoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carritos
     * const carrito = await prisma.carrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarritoUpdateManyArgs>(args: SelectSubset<T, CarritoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carritos and returns the data updated in the database.
     * @param {CarritoUpdateManyAndReturnArgs} args - Arguments to update many Carritos.
     * @example
     * // Update many Carritos
     * const carrito = await prisma.carrito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carritos and only return the `id_carrito`
     * const carritoWithId_carritoOnly = await prisma.carrito.updateManyAndReturn({
     *   select: { id_carrito: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarritoUpdateManyAndReturnArgs>(args: SelectSubset<T, CarritoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carrito.
     * @param {CarritoUpsertArgs} args - Arguments to update or create a Carrito.
     * @example
     * // Update or create a Carrito
     * const carrito = await prisma.carrito.upsert({
     *   create: {
     *     // ... data to create a Carrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrito we want to update
     *   }
     * })
     */
    upsert<T extends CarritoUpsertArgs>(args: SelectSubset<T, CarritoUpsertArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoCountArgs} args - Arguments to filter Carritos to count.
     * @example
     * // Count the number of Carritos
     * const count = await prisma.carrito.count({
     *   where: {
     *     // ... the filter for the Carritos we want to count
     *   }
     * })
    **/
    count<T extends CarritoCountArgs>(
      args?: Subset<T, CarritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarritoAggregateArgs>(args: Subset<T, CarritoAggregateArgs>): Prisma.PrismaPromise<GetCarritoAggregateType<T>>

    /**
     * Group by Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarritoGroupByArgs['orderBy'] }
        : { orderBy?: CarritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarritoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carrito model
   */
  readonly fields: CarritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarritoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Carrito$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Carrito$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carrito model
   */
  interface CarritoFieldRefs {
    readonly id_carrito: FieldRef<"Carrito", 'Int'>
    readonly id_cliente: FieldRef<"Carrito", 'Int'>
    readonly fecha_creacion: FieldRef<"Carrito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Carrito findUnique
   */
  export type CarritoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter, which Carrito to fetch.
     */
    where: CarritoWhereUniqueInput
  }

  /**
   * Carrito findUniqueOrThrow
   */
  export type CarritoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter, which Carrito to fetch.
     */
    where: CarritoWhereUniqueInput
  }

  /**
   * Carrito findFirst
   */
  export type CarritoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter, which Carrito to fetch.
     */
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     */
    orderBy?: CarritoOrderByWithRelationInput | CarritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carritos.
     */
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carritos.
     */
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[]
  }

  /**
   * Carrito findFirstOrThrow
   */
  export type CarritoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter, which Carrito to fetch.
     */
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     */
    orderBy?: CarritoOrderByWithRelationInput | CarritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carritos.
     */
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carritos.
     */
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[]
  }

  /**
   * Carrito findMany
   */
  export type CarritoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter, which Carritos to fetch.
     */
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     */
    orderBy?: CarritoOrderByWithRelationInput | CarritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carritos.
     */
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     */
    skip?: number
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[]
  }

  /**
   * Carrito create
   */
  export type CarritoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * The data needed to create a Carrito.
     */
    data: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>
  }

  /**
   * Carrito createMany
   */
  export type CarritoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carritos.
     */
    data: CarritoCreateManyInput | CarritoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carrito createManyAndReturn
   */
  export type CarritoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * The data used to create many Carritos.
     */
    data: CarritoCreateManyInput | CarritoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carrito update
   */
  export type CarritoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * The data needed to update a Carrito.
     */
    data: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>
    /**
     * Choose, which Carrito to update.
     */
    where: CarritoWhereUniqueInput
  }

  /**
   * Carrito updateMany
   */
  export type CarritoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carritos.
     */
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyInput>
    /**
     * Filter which Carritos to update
     */
    where?: CarritoWhereInput
    /**
     * Limit how many Carritos to update.
     */
    limit?: number
  }

  /**
   * Carrito updateManyAndReturn
   */
  export type CarritoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * The data used to update Carritos.
     */
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyInput>
    /**
     * Filter which Carritos to update
     */
    where?: CarritoWhereInput
    /**
     * Limit how many Carritos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carrito upsert
   */
  export type CarritoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * The filter to search for the Carrito to update in case it exists.
     */
    where: CarritoWhereUniqueInput
    /**
     * In case the Carrito found by the `where` argument doesn't exist, create a new Carrito with this data.
     */
    create: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>
    /**
     * In case the Carrito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>
  }

  /**
   * Carrito delete
   */
  export type CarritoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
    /**
     * Filter which Carrito to delete.
     */
    where: CarritoWhereUniqueInput
  }

  /**
   * Carrito deleteMany
   */
  export type CarritoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carritos to delete
     */
    where?: CarritoWhereInput
    /**
     * Limit how many Carritos to delete.
     */
    limit?: number
  }

  /**
   * Carrito.items
   */
  export type Carrito$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    where?: CarritoItemWhereInput
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    cursor?: CarritoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarritoItemScalarFieldEnum | CarritoItemScalarFieldEnum[]
  }

  /**
   * Carrito without action
   */
  export type CarritoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null
  }


  /**
   * Model CarritoItem
   */

  export type AggregateCarritoItem = {
    _count: CarritoItemCountAggregateOutputType | null
    _avg: CarritoItemAvgAggregateOutputType | null
    _sum: CarritoItemSumAggregateOutputType | null
    _min: CarritoItemMinAggregateOutputType | null
    _max: CarritoItemMaxAggregateOutputType | null
  }

  export type CarritoItemAvgAggregateOutputType = {
    id_item: number | null
    id_carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemSumAggregateOutputType = {
    id_item: number | null
    id_carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemMinAggregateOutputType = {
    id_item: number | null
    id_carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemMaxAggregateOutputType = {
    id_item: number | null
    id_carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemCountAggregateOutputType = {
    id_item: number
    id_carrito: number
    id_producto: number
    cantidad: number
    _all: number
  }


  export type CarritoItemAvgAggregateInputType = {
    id_item?: true
    id_carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemSumAggregateInputType = {
    id_item?: true
    id_carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemMinAggregateInputType = {
    id_item?: true
    id_carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemMaxAggregateInputType = {
    id_item?: true
    id_carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemCountAggregateInputType = {
    id_item?: true
    id_carrito?: true
    id_producto?: true
    cantidad?: true
    _all?: true
  }

  export type CarritoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarritoItem to aggregate.
     */
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     */
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarritoItems
    **/
    _count?: true | CarritoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarritoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarritoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarritoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarritoItemMaxAggregateInputType
  }

  export type GetCarritoItemAggregateType<T extends CarritoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCarritoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarritoItem[P]>
      : GetScalarType<T[P], AggregateCarritoItem[P]>
  }




  export type CarritoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarritoItemWhereInput
    orderBy?: CarritoItemOrderByWithAggregationInput | CarritoItemOrderByWithAggregationInput[]
    by: CarritoItemScalarFieldEnum[] | CarritoItemScalarFieldEnum
    having?: CarritoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarritoItemCountAggregateInputType | true
    _avg?: CarritoItemAvgAggregateInputType
    _sum?: CarritoItemSumAggregateInputType
    _min?: CarritoItemMinAggregateInputType
    _max?: CarritoItemMaxAggregateInputType
  }

  export type CarritoItemGroupByOutputType = {
    id_item: number
    id_carrito: number
    id_producto: number
    cantidad: number
    _count: CarritoItemCountAggregateOutputType | null
    _avg: CarritoItemAvgAggregateOutputType | null
    _sum: CarritoItemSumAggregateOutputType | null
    _min: CarritoItemMinAggregateOutputType | null
    _max: CarritoItemMaxAggregateOutputType | null
  }

  type GetCarritoItemGroupByPayload<T extends CarritoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarritoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarritoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarritoItemGroupByOutputType[P]>
            : GetScalarType<T[P], CarritoItemGroupByOutputType[P]>
        }
      >
    >


  export type CarritoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_item?: boolean
    id_carrito?: boolean
    id_producto?: boolean
    cantidad?: boolean
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carritoItem"]>

  export type CarritoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_item?: boolean
    id_carrito?: boolean
    id_producto?: boolean
    cantidad?: boolean
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carritoItem"]>

  export type CarritoItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_item?: boolean
    id_carrito?: boolean
    id_producto?: boolean
    cantidad?: boolean
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carritoItem"]>

  export type CarritoItemSelectScalar = {
    id_item?: boolean
    id_carrito?: boolean
    id_producto?: boolean
    cantidad?: boolean
  }

  export type CarritoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_item" | "id_carrito" | "id_producto" | "cantidad", ExtArgs["result"]["carritoItem"]>
  export type CarritoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type CarritoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type CarritoItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $CarritoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarritoItem"
    objects: {
      carrito: Prisma.$CarritoPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_item: number
      id_carrito: number
      id_producto: number
      cantidad: number
    }, ExtArgs["result"]["carritoItem"]>
    composites: {}
  }

  type CarritoItemGetPayload<S extends boolean | null | undefined | CarritoItemDefaultArgs> = $Result.GetResult<Prisma.$CarritoItemPayload, S>

  type CarritoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarritoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarritoItemCountAggregateInputType | true
    }

  export interface CarritoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarritoItem'], meta: { name: 'CarritoItem' } }
    /**
     * Find zero or one CarritoItem that matches the filter.
     * @param {CarritoItemFindUniqueArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarritoItemFindUniqueArgs>(args: SelectSubset<T, CarritoItemFindUniqueArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CarritoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarritoItemFindUniqueOrThrowArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarritoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CarritoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarritoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemFindFirstArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarritoItemFindFirstArgs>(args?: SelectSubset<T, CarritoItemFindFirstArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarritoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemFindFirstOrThrowArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarritoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CarritoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CarritoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarritoItems
     * const carritoItems = await prisma.carritoItem.findMany()
     * 
     * // Get first 10 CarritoItems
     * const carritoItems = await prisma.carritoItem.findMany({ take: 10 })
     * 
     * // Only select the `id_item`
     * const carritoItemWithId_itemOnly = await prisma.carritoItem.findMany({ select: { id_item: true } })
     * 
     */
    findMany<T extends CarritoItemFindManyArgs>(args?: SelectSubset<T, CarritoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CarritoItem.
     * @param {CarritoItemCreateArgs} args - Arguments to create a CarritoItem.
     * @example
     * // Create one CarritoItem
     * const CarritoItem = await prisma.carritoItem.create({
     *   data: {
     *     // ... data to create a CarritoItem
     *   }
     * })
     * 
     */
    create<T extends CarritoItemCreateArgs>(args: SelectSubset<T, CarritoItemCreateArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CarritoItems.
     * @param {CarritoItemCreateManyArgs} args - Arguments to create many CarritoItems.
     * @example
     * // Create many CarritoItems
     * const carritoItem = await prisma.carritoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarritoItemCreateManyArgs>(args?: SelectSubset<T, CarritoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarritoItems and returns the data saved in the database.
     * @param {CarritoItemCreateManyAndReturnArgs} args - Arguments to create many CarritoItems.
     * @example
     * // Create many CarritoItems
     * const carritoItem = await prisma.carritoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarritoItems and only return the `id_item`
     * const carritoItemWithId_itemOnly = await prisma.carritoItem.createManyAndReturn({
     *   select: { id_item: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarritoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CarritoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CarritoItem.
     * @param {CarritoItemDeleteArgs} args - Arguments to delete one CarritoItem.
     * @example
     * // Delete one CarritoItem
     * const CarritoItem = await prisma.carritoItem.delete({
     *   where: {
     *     // ... filter to delete one CarritoItem
     *   }
     * })
     * 
     */
    delete<T extends CarritoItemDeleteArgs>(args: SelectSubset<T, CarritoItemDeleteArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CarritoItem.
     * @param {CarritoItemUpdateArgs} args - Arguments to update one CarritoItem.
     * @example
     * // Update one CarritoItem
     * const carritoItem = await prisma.carritoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarritoItemUpdateArgs>(args: SelectSubset<T, CarritoItemUpdateArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CarritoItems.
     * @param {CarritoItemDeleteManyArgs} args - Arguments to filter CarritoItems to delete.
     * @example
     * // Delete a few CarritoItems
     * const { count } = await prisma.carritoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarritoItemDeleteManyArgs>(args?: SelectSubset<T, CarritoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarritoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarritoItems
     * const carritoItem = await prisma.carritoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarritoItemUpdateManyArgs>(args: SelectSubset<T, CarritoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarritoItems and returns the data updated in the database.
     * @param {CarritoItemUpdateManyAndReturnArgs} args - Arguments to update many CarritoItems.
     * @example
     * // Update many CarritoItems
     * const carritoItem = await prisma.carritoItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CarritoItems and only return the `id_item`
     * const carritoItemWithId_itemOnly = await prisma.carritoItem.updateManyAndReturn({
     *   select: { id_item: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarritoItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CarritoItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CarritoItem.
     * @param {CarritoItemUpsertArgs} args - Arguments to update or create a CarritoItem.
     * @example
     * // Update or create a CarritoItem
     * const carritoItem = await prisma.carritoItem.upsert({
     *   create: {
     *     // ... data to create a CarritoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarritoItem we want to update
     *   }
     * })
     */
    upsert<T extends CarritoItemUpsertArgs>(args: SelectSubset<T, CarritoItemUpsertArgs<ExtArgs>>): Prisma__CarritoItemClient<$Result.GetResult<Prisma.$CarritoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CarritoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemCountArgs} args - Arguments to filter CarritoItems to count.
     * @example
     * // Count the number of CarritoItems
     * const count = await prisma.carritoItem.count({
     *   where: {
     *     // ... the filter for the CarritoItems we want to count
     *   }
     * })
    **/
    count<T extends CarritoItemCountArgs>(
      args?: Subset<T, CarritoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarritoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarritoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarritoItemAggregateArgs>(args: Subset<T, CarritoItemAggregateArgs>): Prisma.PrismaPromise<GetCarritoItemAggregateType<T>>

    /**
     * Group by CarritoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarritoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarritoItemGroupByArgs['orderBy'] }
        : { orderBy?: CarritoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarritoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarritoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarritoItem model
   */
  readonly fields: CarritoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarritoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarritoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carrito<T extends CarritoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarritoDefaultArgs<ExtArgs>>): Prisma__CarritoClient<$Result.GetResult<Prisma.$CarritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarritoItem model
   */
  interface CarritoItemFieldRefs {
    readonly id_item: FieldRef<"CarritoItem", 'Int'>
    readonly id_carrito: FieldRef<"CarritoItem", 'Int'>
    readonly id_producto: FieldRef<"CarritoItem", 'Int'>
    readonly cantidad: FieldRef<"CarritoItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CarritoItem findUnique
   */
  export type CarritoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter, which CarritoItem to fetch.
     */
    where: CarritoItemWhereUniqueInput
  }

  /**
   * CarritoItem findUniqueOrThrow
   */
  export type CarritoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter, which CarritoItem to fetch.
     */
    where: CarritoItemWhereUniqueInput
  }

  /**
   * CarritoItem findFirst
   */
  export type CarritoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter, which CarritoItem to fetch.
     */
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     */
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarritoItems.
     */
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarritoItems.
     */
    distinct?: CarritoItemScalarFieldEnum | CarritoItemScalarFieldEnum[]
  }

  /**
   * CarritoItem findFirstOrThrow
   */
  export type CarritoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter, which CarritoItem to fetch.
     */
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     */
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarritoItems.
     */
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarritoItems.
     */
    distinct?: CarritoItemScalarFieldEnum | CarritoItemScalarFieldEnum[]
  }

  /**
   * CarritoItem findMany
   */
  export type CarritoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter, which CarritoItems to fetch.
     */
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     */
    orderBy?: CarritoItemOrderByWithRelationInput | CarritoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarritoItems.
     */
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     */
    skip?: number
    distinct?: CarritoItemScalarFieldEnum | CarritoItemScalarFieldEnum[]
  }

  /**
   * CarritoItem create
   */
  export type CarritoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CarritoItem.
     */
    data: XOR<CarritoItemCreateInput, CarritoItemUncheckedCreateInput>
  }

  /**
   * CarritoItem createMany
   */
  export type CarritoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarritoItems.
     */
    data: CarritoItemCreateManyInput | CarritoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarritoItem createManyAndReturn
   */
  export type CarritoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * The data used to create many CarritoItems.
     */
    data: CarritoItemCreateManyInput | CarritoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarritoItem update
   */
  export type CarritoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CarritoItem.
     */
    data: XOR<CarritoItemUpdateInput, CarritoItemUncheckedUpdateInput>
    /**
     * Choose, which CarritoItem to update.
     */
    where: CarritoItemWhereUniqueInput
  }

  /**
   * CarritoItem updateMany
   */
  export type CarritoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarritoItems.
     */
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyInput>
    /**
     * Filter which CarritoItems to update
     */
    where?: CarritoItemWhereInput
    /**
     * Limit how many CarritoItems to update.
     */
    limit?: number
  }

  /**
   * CarritoItem updateManyAndReturn
   */
  export type CarritoItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * The data used to update CarritoItems.
     */
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyInput>
    /**
     * Filter which CarritoItems to update
     */
    where?: CarritoItemWhereInput
    /**
     * Limit how many CarritoItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarritoItem upsert
   */
  export type CarritoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CarritoItem to update in case it exists.
     */
    where: CarritoItemWhereUniqueInput
    /**
     * In case the CarritoItem found by the `where` argument doesn't exist, create a new CarritoItem with this data.
     */
    create: XOR<CarritoItemCreateInput, CarritoItemUncheckedCreateInput>
    /**
     * In case the CarritoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarritoItemUpdateInput, CarritoItemUncheckedUpdateInput>
  }

  /**
   * CarritoItem delete
   */
  export type CarritoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
    /**
     * Filter which CarritoItem to delete.
     */
    where: CarritoItemWhereUniqueInput
  }

  /**
   * CarritoItem deleteMany
   */
  export type CarritoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarritoItems to delete
     */
    where?: CarritoItemWhereInput
    /**
     * Limit how many CarritoItems to delete.
     */
    limit?: number
  }

  /**
   * CarritoItem without action
   */
  export type CarritoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarritoItem
     */
    select?: CarritoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarritoItem
     */
    omit?: CarritoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoItemInclude<ExtArgs> | null
  }


  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id_pedido: number | null
    total: Decimal | null
    id_cliente: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id_pedido: number | null
    total: Decimal | null
    id_cliente: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id_pedido: number | null
    total: Decimal | null
    estado: string | null
    fecha_pedido: Date | null
    id_cliente: number | null
  }

  export type PedidoMaxAggregateOutputType = {
    id_pedido: number | null
    total: Decimal | null
    estado: string | null
    fecha_pedido: Date | null
    id_cliente: number | null
  }

  export type PedidoCountAggregateOutputType = {
    id_pedido: number
    total: number
    estado: number
    fecha_pedido: number
    id_cliente: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id_pedido?: true
    total?: true
    id_cliente?: true
  }

  export type PedidoSumAggregateInputType = {
    id_pedido?: true
    total?: true
    id_cliente?: true
  }

  export type PedidoMinAggregateInputType = {
    id_pedido?: true
    total?: true
    estado?: true
    fecha_pedido?: true
    id_cliente?: true
  }

  export type PedidoMaxAggregateInputType = {
    id_pedido?: true
    total?: true
    estado?: true
    fecha_pedido?: true
    id_cliente?: true
  }

  export type PedidoCountAggregateInputType = {
    id_pedido?: true
    total?: true
    estado?: true
    fecha_pedido?: true
    id_cliente?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id_pedido: number
    total: Decimal
    estado: string
    fecha_pedido: Date
    id_cliente: number
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    total?: boolean
    estado?: boolean
    fecha_pedido?: boolean
    id_cliente?: boolean
    pagos?: boolean | Pedido$pagosArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | Pedido$itemsArgs<ExtArgs>
    ventas?: boolean | Pedido$ventasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    total?: boolean
    estado?: boolean
    fecha_pedido?: boolean
    id_cliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    total?: boolean
    estado?: boolean
    fecha_pedido?: boolean
    id_cliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    id_pedido?: boolean
    total?: boolean
    estado?: boolean
    fecha_pedido?: boolean
    id_cliente?: boolean
  }

  export type PedidoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pedido" | "total" | "estado" | "fecha_pedido" | "id_cliente", ExtArgs["result"]["pedido"]>
  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagos?: boolean | Pedido$pagosArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | Pedido$itemsArgs<ExtArgs>
    ventas?: boolean | Pedido$ventasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PedidoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type PedidoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      pagos: Prisma.$PagoPayload<ExtArgs>[]
      cliente: Prisma.$ClientePayload<ExtArgs>
      items: Prisma.$PedidoItemPayload<ExtArgs>[]
      ventas: Prisma.$VentaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pedido: number
      total: Prisma.Decimal
      estado: string
      fecha_pedido: Date
      id_cliente: number
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }

  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoFindUniqueArgs>(args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pedido that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoFindFirstArgs>(args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.findMany({ select: { id_pedido: true } })
     * 
     */
    findMany<T extends PedidoFindManyArgs>(args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
     */
    create<T extends PedidoCreateArgs>(args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pedidos.
     * @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoCreateManyArgs>(args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pedidos and returns the data saved in the database.
     * @param {PedidoCreateManyAndReturnArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pedidos and only return the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.createManyAndReturn({
     *   select: { id_pedido: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
     */
    delete<T extends PedidoDeleteArgs>(args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoUpdateArgs>(args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoDeleteManyArgs>(args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoUpdateManyArgs>(args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos and returns the data updated in the database.
     * @param {PedidoUpdateManyAndReturnArgs} args - Arguments to update many Pedidos.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pedidos and only return the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.updateManyAndReturn({
     *   select: { id_pedido: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PedidoUpdateManyAndReturnArgs>(args: SelectSubset<T, PedidoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
     */
    upsert<T extends PedidoUpsertArgs>(args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pagos<T extends Pedido$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Pedido$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ventas<T extends Pedido$ventasArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$ventasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pedido model
   */
  interface PedidoFieldRefs {
    readonly id_pedido: FieldRef<"Pedido", 'Int'>
    readonly total: FieldRef<"Pedido", 'Decimal'>
    readonly estado: FieldRef<"Pedido", 'String'>
    readonly fecha_pedido: FieldRef<"Pedido", 'DateTime'>
    readonly id_cliente: FieldRef<"Pedido", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }

  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pedido createManyAndReturn
   */
  export type PedidoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
    /**
     * Limit how many Pedidos to update.
     */
    limit?: number
  }

  /**
   * Pedido updateManyAndReturn
   */
  export type PedidoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
    /**
     * Limit how many Pedidos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }

  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
    /**
     * Limit how many Pedidos to delete.
     */
    limit?: number
  }

  /**
   * Pedido.pagos
   */
  export type Pedido$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    cursor?: PagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pedido.items
   */
  export type Pedido$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Pedido.ventas
   */
  export type Pedido$ventasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    where?: VentaWhereInput
    orderBy?: VentaOrderByWithRelationInput | VentaOrderByWithRelationInput[]
    cursor?: VentaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentaScalarFieldEnum | VentaScalarFieldEnum[]
  }

  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
  }


  /**
   * Model PedidoItem
   */

  export type AggregatePedidoItem = {
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  export type PedidoItemAvgAggregateOutputType = {
    id_detalle: number | null
    id_pedido: number | null
    id_producto: number | null
    cantidad: number | null
    precio: Decimal | null
  }

  export type PedidoItemSumAggregateOutputType = {
    id_detalle: number | null
    id_pedido: number | null
    id_producto: number | null
    cantidad: number | null
    precio: Decimal | null
  }

  export type PedidoItemMinAggregateOutputType = {
    id_detalle: number | null
    id_pedido: number | null
    id_producto: number | null
    cantidad: number | null
    precio: Decimal | null
  }

  export type PedidoItemMaxAggregateOutputType = {
    id_detalle: number | null
    id_pedido: number | null
    id_producto: number | null
    cantidad: number | null
    precio: Decimal | null
  }

  export type PedidoItemCountAggregateOutputType = {
    id_detalle: number
    id_pedido: number
    id_producto: number
    cantidad: number
    precio: number
    _all: number
  }


  export type PedidoItemAvgAggregateInputType = {
    id_detalle?: true
    id_pedido?: true
    id_producto?: true
    cantidad?: true
    precio?: true
  }

  export type PedidoItemSumAggregateInputType = {
    id_detalle?: true
    id_pedido?: true
    id_producto?: true
    cantidad?: true
    precio?: true
  }

  export type PedidoItemMinAggregateInputType = {
    id_detalle?: true
    id_pedido?: true
    id_producto?: true
    cantidad?: true
    precio?: true
  }

  export type PedidoItemMaxAggregateInputType = {
    id_detalle?: true
    id_pedido?: true
    id_producto?: true
    cantidad?: true
    precio?: true
  }

  export type PedidoItemCountAggregateInputType = {
    id_detalle?: true
    id_pedido?: true
    id_producto?: true
    cantidad?: true
    precio?: true
    _all?: true
  }

  export type PedidoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItem to aggregate.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoItems
    **/
    _count?: true | PedidoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoItemMaxAggregateInputType
  }

  export type GetPedidoItemAggregateType<T extends PedidoItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoItem[P]>
      : GetScalarType<T[P], AggregatePedidoItem[P]>
  }




  export type PedidoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithAggregationInput | PedidoItemOrderByWithAggregationInput[]
    by: PedidoItemScalarFieldEnum[] | PedidoItemScalarFieldEnum
    having?: PedidoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoItemCountAggregateInputType | true
    _avg?: PedidoItemAvgAggregateInputType
    _sum?: PedidoItemSumAggregateInputType
    _min?: PedidoItemMinAggregateInputType
    _max?: PedidoItemMaxAggregateInputType
  }

  export type PedidoItemGroupByOutputType = {
    id_detalle: number
    id_pedido: number
    id_producto: number
    cantidad: number
    precio: Decimal
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  type GetPedidoItemGroupByPayload<T extends PedidoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
        }
      >
    >


  export type PedidoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_pedido?: boolean
    id_producto?: boolean
    cantidad?: boolean
    precio?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>

  export type PedidoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_pedido?: boolean
    id_producto?: boolean
    cantidad?: boolean
    precio?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>

  export type PedidoItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_pedido?: boolean
    id_producto?: boolean
    cantidad?: boolean
    precio?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>

  export type PedidoItemSelectScalar = {
    id_detalle?: boolean
    id_pedido?: boolean
    id_producto?: boolean
    cantidad?: boolean
    precio?: boolean
  }

  export type PedidoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_detalle" | "id_pedido" | "id_producto" | "cantidad" | "precio", ExtArgs["result"]["pedidoItem"]>
  export type PedidoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PedidoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type PedidoItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $PedidoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoItem"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_detalle: number
      id_pedido: number
      id_producto: number
      cantidad: number
      precio: Prisma.Decimal
    }, ExtArgs["result"]["pedidoItem"]>
    composites: {}
  }

  type PedidoItemGetPayload<S extends boolean | null | undefined | PedidoItemDefaultArgs> = $Result.GetResult<Prisma.$PedidoItemPayload, S>

  type PedidoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PedidoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoItemCountAggregateInputType | true
    }

  export interface PedidoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoItem'], meta: { name: 'PedidoItem' } }
    /**
     * Find zero or one PedidoItem that matches the filter.
     * @param {PedidoItemFindUniqueArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoItemFindUniqueArgs>(args: SelectSubset<T, PedidoItemFindUniqueArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PedidoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PedidoItemFindUniqueOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PedidoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoItemFindFirstArgs>(args?: SelectSubset<T, PedidoItemFindFirstArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PedidoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PedidoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany()
     * 
     * // Get first 10 PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany({ take: 10 })
     * 
     * // Only select the `id_detalle`
     * const pedidoItemWithId_detalleOnly = await prisma.pedidoItem.findMany({ select: { id_detalle: true } })
     * 
     */
    findMany<T extends PedidoItemFindManyArgs>(args?: SelectSubset<T, PedidoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PedidoItem.
     * @param {PedidoItemCreateArgs} args - Arguments to create a PedidoItem.
     * @example
     * // Create one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.create({
     *   data: {
     *     // ... data to create a PedidoItem
     *   }
     * })
     * 
     */
    create<T extends PedidoItemCreateArgs>(args: SelectSubset<T, PedidoItemCreateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PedidoItems.
     * @param {PedidoItemCreateManyArgs} args - Arguments to create many PedidoItems.
     * @example
     * // Create many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoItemCreateManyArgs>(args?: SelectSubset<T, PedidoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PedidoItems and returns the data saved in the database.
     * @param {PedidoItemCreateManyAndReturnArgs} args - Arguments to create many PedidoItems.
     * @example
     * // Create many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PedidoItems and only return the `id_detalle`
     * const pedidoItemWithId_detalleOnly = await prisma.pedidoItem.createManyAndReturn({
     *   select: { id_detalle: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PedidoItem.
     * @param {PedidoItemDeleteArgs} args - Arguments to delete one PedidoItem.
     * @example
     * // Delete one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.delete({
     *   where: {
     *     // ... filter to delete one PedidoItem
     *   }
     * })
     * 
     */
    delete<T extends PedidoItemDeleteArgs>(args: SelectSubset<T, PedidoItemDeleteArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PedidoItem.
     * @param {PedidoItemUpdateArgs} args - Arguments to update one PedidoItem.
     * @example
     * // Update one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoItemUpdateArgs>(args: SelectSubset<T, PedidoItemUpdateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PedidoItems.
     * @param {PedidoItemDeleteManyArgs} args - Arguments to filter PedidoItems to delete.
     * @example
     * // Delete a few PedidoItems
     * const { count } = await prisma.pedidoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoItemDeleteManyArgs>(args?: SelectSubset<T, PedidoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoItemUpdateManyArgs>(args: SelectSubset<T, PedidoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoItems and returns the data updated in the database.
     * @param {PedidoItemUpdateManyAndReturnArgs} args - Arguments to update many PedidoItems.
     * @example
     * // Update many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PedidoItems and only return the `id_detalle`
     * const pedidoItemWithId_detalleOnly = await prisma.pedidoItem.updateManyAndReturn({
     *   select: { id_detalle: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PedidoItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PedidoItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PedidoItem.
     * @param {PedidoItemUpsertArgs} args - Arguments to update or create a PedidoItem.
     * @example
     * // Update or create a PedidoItem
     * const pedidoItem = await prisma.pedidoItem.upsert({
     *   create: {
     *     // ... data to create a PedidoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoItem we want to update
     *   }
     * })
     */
    upsert<T extends PedidoItemUpsertArgs>(args: SelectSubset<T, PedidoItemUpsertArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemCountArgs} args - Arguments to filter PedidoItems to count.
     * @example
     * // Count the number of PedidoItems
     * const count = await prisma.pedidoItem.count({
     *   where: {
     *     // ... the filter for the PedidoItems we want to count
     *   }
     * })
    **/
    count<T extends PedidoItemCountArgs>(
      args?: Subset<T, PedidoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoItemAggregateArgs>(args: Subset<T, PedidoItemAggregateArgs>): Prisma.PrismaPromise<GetPedidoItemAggregateType<T>>

    /**
     * Group by PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoItemGroupByArgs['orderBy'] }
        : { orderBy?: PedidoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoItem model
   */
  readonly fields: PedidoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PedidoItem model
   */
  interface PedidoItemFieldRefs {
    readonly id_detalle: FieldRef<"PedidoItem", 'Int'>
    readonly id_pedido: FieldRef<"PedidoItem", 'Int'>
    readonly id_producto: FieldRef<"PedidoItem", 'Int'>
    readonly cantidad: FieldRef<"PedidoItem", 'Int'>
    readonly precio: FieldRef<"PedidoItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PedidoItem findUnique
   */
  export type PedidoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findUniqueOrThrow
   */
  export type PedidoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findFirst
   */
  export type PedidoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findFirstOrThrow
   */
  export type PedidoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findMany
   */
  export type PedidoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItems to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem create
   */
  export type PedidoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoItem.
     */
    data: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
  }

  /**
   * PedidoItem createMany
   */
  export type PedidoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoItems.
     */
    data: PedidoItemCreateManyInput | PedidoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PedidoItem createManyAndReturn
   */
  export type PedidoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * The data used to create many PedidoItems.
     */
    data: PedidoItemCreateManyInput | PedidoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoItem update
   */
  export type PedidoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoItem.
     */
    data: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
    /**
     * Choose, which PedidoItem to update.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem updateMany
   */
  export type PedidoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoItems.
     */
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyInput>
    /**
     * Filter which PedidoItems to update
     */
    where?: PedidoItemWhereInput
    /**
     * Limit how many PedidoItems to update.
     */
    limit?: number
  }

  /**
   * PedidoItem updateManyAndReturn
   */
  export type PedidoItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * The data used to update PedidoItems.
     */
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyInput>
    /**
     * Filter which PedidoItems to update
     */
    where?: PedidoItemWhereInput
    /**
     * Limit how many PedidoItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoItem upsert
   */
  export type PedidoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoItem to update in case it exists.
     */
    where: PedidoItemWhereUniqueInput
    /**
     * In case the PedidoItem found by the `where` argument doesn't exist, create a new PedidoItem with this data.
     */
    create: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
    /**
     * In case the PedidoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
  }

  /**
   * PedidoItem delete
   */
  export type PedidoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter which PedidoItem to delete.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem deleteMany
   */
  export type PedidoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItems to delete
     */
    where?: PedidoItemWhereInput
    /**
     * Limit how many PedidoItems to delete.
     */
    limit?: number
  }

  /**
   * PedidoItem without action
   */
  export type PedidoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
  }


  /**
   * Model Pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    id_pago: number | null
    id_pedido: number | null
    monto: Decimal | null
  }

  export type PagoSumAggregateOutputType = {
    id_pago: number | null
    id_pedido: number | null
    monto: Decimal | null
  }

  export type PagoMinAggregateOutputType = {
    id_pago: number | null
    id_pedido: number | null
    fecha_pago: Date | null
    monto: Decimal | null
    metodo: string | null
    estado: string | null
  }

  export type PagoMaxAggregateOutputType = {
    id_pago: number | null
    id_pedido: number | null
    fecha_pago: Date | null
    monto: Decimal | null
    metodo: string | null
    estado: string | null
  }

  export type PagoCountAggregateOutputType = {
    id_pago: number
    id_pedido: number
    fecha_pago: number
    monto: number
    metodo: number
    estado: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    id_pago?: true
    id_pedido?: true
    monto?: true
  }

  export type PagoSumAggregateInputType = {
    id_pago?: true
    id_pedido?: true
    monto?: true
  }

  export type PagoMinAggregateInputType = {
    id_pago?: true
    id_pedido?: true
    fecha_pago?: true
    monto?: true
    metodo?: true
    estado?: true
  }

  export type PagoMaxAggregateInputType = {
    id_pago?: true
    id_pedido?: true
    fecha_pago?: true
    monto?: true
    metodo?: true
    estado?: true
  }

  export type PagoCountAggregateInputType = {
    id_pago?: true
    id_pedido?: true
    fecha_pago?: true
    monto?: true
    metodo?: true
    estado?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pago to aggregate.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type PagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithAggregationInput | PagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: PagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    id_pago: number
    id_pedido: number
    fecha_pago: Date
    monto: Decimal
    metodo: string | null
    estado: string
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends PagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type PagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_pedido?: boolean
    fecha_pago?: boolean
    monto?: boolean
    metodo?: boolean
    estado?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_pedido?: boolean
    fecha_pago?: boolean
    monto?: boolean
    metodo?: boolean
    estado?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_pedido?: boolean
    fecha_pago?: boolean
    monto?: boolean
    metodo?: boolean
    estado?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectScalar = {
    id_pago?: boolean
    id_pedido?: boolean
    fecha_pago?: boolean
    monto?: boolean
    metodo?: boolean
    estado?: boolean
  }

  export type PagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pago" | "id_pedido" | "fecha_pago" | "monto" | "metodo" | "estado", ExtArgs["result"]["pago"]>
  export type PagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }
  export type PagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }
  export type PagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }

  export type $PagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pago"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pago: number
      id_pedido: number
      fecha_pago: Date
      monto: Prisma.Decimal
      metodo: string | null
      estado: string
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }

  type PagoGetPayload<S extends boolean | null | undefined | PagoDefaultArgs> = $Result.GetResult<Prisma.$PagoPayload, S>

  type PagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoCountAggregateInputType | true
    }

  export interface PagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pago'], meta: { name: 'Pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {PagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoFindUniqueArgs>(args: SelectSubset<T, PagoFindUniqueArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoFindFirstArgs>(args?: SelectSubset<T, PagoFindFirstArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.findMany({ select: { id_pago: true } })
     * 
     */
    findMany<T extends PagoFindManyArgs>(args?: SelectSubset<T, PagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pago.
     * @param {PagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
     */
    create<T extends PagoCreateArgs>(args: SelectSubset<T, PagoCreateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagos.
     * @param {PagoCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoCreateManyArgs>(args?: SelectSubset<T, PagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagos and returns the data saved in the database.
     * @param {PagoCreateManyAndReturnArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagos and only return the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.createManyAndReturn({
     *   select: { id_pago: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pago.
     * @param {PagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
     */
    delete<T extends PagoDeleteArgs>(args: SelectSubset<T, PagoDeleteArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pago.
     * @param {PagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoUpdateArgs>(args: SelectSubset<T, PagoUpdateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagos.
     * @param {PagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDeleteManyArgs>(args?: SelectSubset<T, PagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoUpdateManyArgs>(args: SelectSubset<T, PagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos and returns the data updated in the database.
     * @param {PagoUpdateManyAndReturnArgs} args - Arguments to update many Pagos.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagos and only return the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.updateManyAndReturn({
     *   select: { id_pago: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagoUpdateManyAndReturnArgs>(args: SelectSubset<T, PagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pago.
     * @param {PagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
     */
    upsert<T extends PagoUpsertArgs>(args: SelectSubset<T, PagoUpsertArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends PagoCountArgs>(
      args?: Subset<T, PagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoGroupByArgs['orderBy'] }
        : { orderBy?: PagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pago model
   */
  readonly fields: PagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pago model
   */
  interface PagoFieldRefs {
    readonly id_pago: FieldRef<"Pago", 'Int'>
    readonly id_pedido: FieldRef<"Pago", 'Int'>
    readonly fecha_pago: FieldRef<"Pago", 'DateTime'>
    readonly monto: FieldRef<"Pago", 'Decimal'>
    readonly metodo: FieldRef<"Pago", 'String'>
    readonly estado: FieldRef<"Pago", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pago findUnique
   */
  export type PagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findUniqueOrThrow
   */
  export type PagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findFirst
   */
  export type PagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findFirstOrThrow
   */
  export type PagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findMany
   */
  export type PagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago create
   */
  export type PagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pago.
     */
    data: XOR<PagoCreateInput, PagoUncheckedCreateInput>
  }

  /**
   * Pago createMany
   */
  export type PagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pago createManyAndReturn
   */
  export type PagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago update
   */
  export type PagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pago.
     */
    data: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
    /**
     * Choose, which Pago to update.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago updateMany
   */
  export type PagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
  }

  /**
   * Pago updateManyAndReturn
   */
  export type PagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago upsert
   */
  export type PagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pago to update in case it exists.
     */
    where: PagoWhereUniqueInput
    /**
     * In case the Pago found by the `where` argument doesn't exist, create a new Pago with this data.
     */
    create: XOR<PagoCreateInput, PagoUncheckedCreateInput>
    /**
     * In case the Pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
  }

  /**
   * Pago delete
   */
  export type PagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter which Pago to delete.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago deleteMany
   */
  export type PagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to delete
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to delete.
     */
    limit?: number
  }

  /**
   * Pago without action
   */
  export type PagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
  }


  /**
   * Model ContactoInterno
   */

  export type AggregateContactoInterno = {
    _count: ContactoInternoCountAggregateOutputType | null
    _avg: ContactoInternoAvgAggregateOutputType | null
    _sum: ContactoInternoSumAggregateOutputType | null
    _min: ContactoInternoMinAggregateOutputType | null
    _max: ContactoInternoMaxAggregateOutputType | null
  }

  export type ContactoInternoAvgAggregateOutputType = {
    id_contacto: number | null
  }

  export type ContactoInternoSumAggregateOutputType = {
    id_contacto: number | null
  }

  export type ContactoInternoMinAggregateOutputType = {
    id_contacto: number | null
    nombre: string | null
    email: string | null
    telefono: string | null
    cargo: string | null
  }

  export type ContactoInternoMaxAggregateOutputType = {
    id_contacto: number | null
    nombre: string | null
    email: string | null
    telefono: string | null
    cargo: string | null
  }

  export type ContactoInternoCountAggregateOutputType = {
    id_contacto: number
    nombre: number
    email: number
    telefono: number
    cargo: number
    _all: number
  }


  export type ContactoInternoAvgAggregateInputType = {
    id_contacto?: true
  }

  export type ContactoInternoSumAggregateInputType = {
    id_contacto?: true
  }

  export type ContactoInternoMinAggregateInputType = {
    id_contacto?: true
    nombre?: true
    email?: true
    telefono?: true
    cargo?: true
  }

  export type ContactoInternoMaxAggregateInputType = {
    id_contacto?: true
    nombre?: true
    email?: true
    telefono?: true
    cargo?: true
  }

  export type ContactoInternoCountAggregateInputType = {
    id_contacto?: true
    nombre?: true
    email?: true
    telefono?: true
    cargo?: true
    _all?: true
  }

  export type ContactoInternoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactoInterno to aggregate.
     */
    where?: ContactoInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactoInternos to fetch.
     */
    orderBy?: ContactoInternoOrderByWithRelationInput | ContactoInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactoInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactoInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactoInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactoInternos
    **/
    _count?: true | ContactoInternoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactoInternoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactoInternoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactoInternoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactoInternoMaxAggregateInputType
  }

  export type GetContactoInternoAggregateType<T extends ContactoInternoAggregateArgs> = {
        [P in keyof T & keyof AggregateContactoInterno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactoInterno[P]>
      : GetScalarType<T[P], AggregateContactoInterno[P]>
  }




  export type ContactoInternoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactoInternoWhereInput
    orderBy?: ContactoInternoOrderByWithAggregationInput | ContactoInternoOrderByWithAggregationInput[]
    by: ContactoInternoScalarFieldEnum[] | ContactoInternoScalarFieldEnum
    having?: ContactoInternoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactoInternoCountAggregateInputType | true
    _avg?: ContactoInternoAvgAggregateInputType
    _sum?: ContactoInternoSumAggregateInputType
    _min?: ContactoInternoMinAggregateInputType
    _max?: ContactoInternoMaxAggregateInputType
  }

  export type ContactoInternoGroupByOutputType = {
    id_contacto: number
    nombre: string
    email: string
    telefono: string | null
    cargo: string | null
    _count: ContactoInternoCountAggregateOutputType | null
    _avg: ContactoInternoAvgAggregateOutputType | null
    _sum: ContactoInternoSumAggregateOutputType | null
    _min: ContactoInternoMinAggregateOutputType | null
    _max: ContactoInternoMaxAggregateOutputType | null
  }

  type GetContactoInternoGroupByPayload<T extends ContactoInternoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactoInternoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactoInternoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactoInternoGroupByOutputType[P]>
            : GetScalarType<T[P], ContactoInternoGroupByOutputType[P]>
        }
      >
    >


  export type ContactoInternoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contacto?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    cargo?: boolean
  }, ExtArgs["result"]["contactoInterno"]>

  export type ContactoInternoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contacto?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    cargo?: boolean
  }, ExtArgs["result"]["contactoInterno"]>

  export type ContactoInternoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contacto?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    cargo?: boolean
  }, ExtArgs["result"]["contactoInterno"]>

  export type ContactoInternoSelectScalar = {
    id_contacto?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    cargo?: boolean
  }

  export type ContactoInternoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_contacto" | "nombre" | "email" | "telefono" | "cargo", ExtArgs["result"]["contactoInterno"]>

  export type $ContactoInternoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactoInterno"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_contacto: number
      nombre: string
      email: string
      telefono: string | null
      cargo: string | null
    }, ExtArgs["result"]["contactoInterno"]>
    composites: {}
  }

  type ContactoInternoGetPayload<S extends boolean | null | undefined | ContactoInternoDefaultArgs> = $Result.GetResult<Prisma.$ContactoInternoPayload, S>

  type ContactoInternoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactoInternoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactoInternoCountAggregateInputType | true
    }

  export interface ContactoInternoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactoInterno'], meta: { name: 'ContactoInterno' } }
    /**
     * Find zero or one ContactoInterno that matches the filter.
     * @param {ContactoInternoFindUniqueArgs} args - Arguments to find a ContactoInterno
     * @example
     * // Get one ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactoInternoFindUniqueArgs>(args: SelectSubset<T, ContactoInternoFindUniqueArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactoInterno that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactoInternoFindUniqueOrThrowArgs} args - Arguments to find a ContactoInterno
     * @example
     * // Get one ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactoInternoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactoInternoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactoInterno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoFindFirstArgs} args - Arguments to find a ContactoInterno
     * @example
     * // Get one ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactoInternoFindFirstArgs>(args?: SelectSubset<T, ContactoInternoFindFirstArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactoInterno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoFindFirstOrThrowArgs} args - Arguments to find a ContactoInterno
     * @example
     * // Get one ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactoInternoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactoInternoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactoInternos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactoInternos
     * const contactoInternos = await prisma.contactoInterno.findMany()
     * 
     * // Get first 10 ContactoInternos
     * const contactoInternos = await prisma.contactoInterno.findMany({ take: 10 })
     * 
     * // Only select the `id_contacto`
     * const contactoInternoWithId_contactoOnly = await prisma.contactoInterno.findMany({ select: { id_contacto: true } })
     * 
     */
    findMany<T extends ContactoInternoFindManyArgs>(args?: SelectSubset<T, ContactoInternoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactoInterno.
     * @param {ContactoInternoCreateArgs} args - Arguments to create a ContactoInterno.
     * @example
     * // Create one ContactoInterno
     * const ContactoInterno = await prisma.contactoInterno.create({
     *   data: {
     *     // ... data to create a ContactoInterno
     *   }
     * })
     * 
     */
    create<T extends ContactoInternoCreateArgs>(args: SelectSubset<T, ContactoInternoCreateArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactoInternos.
     * @param {ContactoInternoCreateManyArgs} args - Arguments to create many ContactoInternos.
     * @example
     * // Create many ContactoInternos
     * const contactoInterno = await prisma.contactoInterno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactoInternoCreateManyArgs>(args?: SelectSubset<T, ContactoInternoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactoInternos and returns the data saved in the database.
     * @param {ContactoInternoCreateManyAndReturnArgs} args - Arguments to create many ContactoInternos.
     * @example
     * // Create many ContactoInternos
     * const contactoInterno = await prisma.contactoInterno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactoInternos and only return the `id_contacto`
     * const contactoInternoWithId_contactoOnly = await prisma.contactoInterno.createManyAndReturn({
     *   select: { id_contacto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactoInternoCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactoInternoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactoInterno.
     * @param {ContactoInternoDeleteArgs} args - Arguments to delete one ContactoInterno.
     * @example
     * // Delete one ContactoInterno
     * const ContactoInterno = await prisma.contactoInterno.delete({
     *   where: {
     *     // ... filter to delete one ContactoInterno
     *   }
     * })
     * 
     */
    delete<T extends ContactoInternoDeleteArgs>(args: SelectSubset<T, ContactoInternoDeleteArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactoInterno.
     * @param {ContactoInternoUpdateArgs} args - Arguments to update one ContactoInterno.
     * @example
     * // Update one ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactoInternoUpdateArgs>(args: SelectSubset<T, ContactoInternoUpdateArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactoInternos.
     * @param {ContactoInternoDeleteManyArgs} args - Arguments to filter ContactoInternos to delete.
     * @example
     * // Delete a few ContactoInternos
     * const { count } = await prisma.contactoInterno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactoInternoDeleteManyArgs>(args?: SelectSubset<T, ContactoInternoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactoInternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactoInternos
     * const contactoInterno = await prisma.contactoInterno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactoInternoUpdateManyArgs>(args: SelectSubset<T, ContactoInternoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactoInternos and returns the data updated in the database.
     * @param {ContactoInternoUpdateManyAndReturnArgs} args - Arguments to update many ContactoInternos.
     * @example
     * // Update many ContactoInternos
     * const contactoInterno = await prisma.contactoInterno.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactoInternos and only return the `id_contacto`
     * const contactoInternoWithId_contactoOnly = await prisma.contactoInterno.updateManyAndReturn({
     *   select: { id_contacto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactoInternoUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactoInternoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactoInterno.
     * @param {ContactoInternoUpsertArgs} args - Arguments to update or create a ContactoInterno.
     * @example
     * // Update or create a ContactoInterno
     * const contactoInterno = await prisma.contactoInterno.upsert({
     *   create: {
     *     // ... data to create a ContactoInterno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactoInterno we want to update
     *   }
     * })
     */
    upsert<T extends ContactoInternoUpsertArgs>(args: SelectSubset<T, ContactoInternoUpsertArgs<ExtArgs>>): Prisma__ContactoInternoClient<$Result.GetResult<Prisma.$ContactoInternoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactoInternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoCountArgs} args - Arguments to filter ContactoInternos to count.
     * @example
     * // Count the number of ContactoInternos
     * const count = await prisma.contactoInterno.count({
     *   where: {
     *     // ... the filter for the ContactoInternos we want to count
     *   }
     * })
    **/
    count<T extends ContactoInternoCountArgs>(
      args?: Subset<T, ContactoInternoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactoInternoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactoInterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactoInternoAggregateArgs>(args: Subset<T, ContactoInternoAggregateArgs>): Prisma.PrismaPromise<GetContactoInternoAggregateType<T>>

    /**
     * Group by ContactoInterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoInternoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactoInternoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactoInternoGroupByArgs['orderBy'] }
        : { orderBy?: ContactoInternoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactoInternoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactoInternoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactoInterno model
   */
  readonly fields: ContactoInternoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactoInterno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactoInternoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactoInterno model
   */
  interface ContactoInternoFieldRefs {
    readonly id_contacto: FieldRef<"ContactoInterno", 'Int'>
    readonly nombre: FieldRef<"ContactoInterno", 'String'>
    readonly email: FieldRef<"ContactoInterno", 'String'>
    readonly telefono: FieldRef<"ContactoInterno", 'String'>
    readonly cargo: FieldRef<"ContactoInterno", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactoInterno findUnique
   */
  export type ContactoInternoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter, which ContactoInterno to fetch.
     */
    where: ContactoInternoWhereUniqueInput
  }

  /**
   * ContactoInterno findUniqueOrThrow
   */
  export type ContactoInternoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter, which ContactoInterno to fetch.
     */
    where: ContactoInternoWhereUniqueInput
  }

  /**
   * ContactoInterno findFirst
   */
  export type ContactoInternoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter, which ContactoInterno to fetch.
     */
    where?: ContactoInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactoInternos to fetch.
     */
    orderBy?: ContactoInternoOrderByWithRelationInput | ContactoInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactoInternos.
     */
    cursor?: ContactoInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactoInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactoInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactoInternos.
     */
    distinct?: ContactoInternoScalarFieldEnum | ContactoInternoScalarFieldEnum[]
  }

  /**
   * ContactoInterno findFirstOrThrow
   */
  export type ContactoInternoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter, which ContactoInterno to fetch.
     */
    where?: ContactoInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactoInternos to fetch.
     */
    orderBy?: ContactoInternoOrderByWithRelationInput | ContactoInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactoInternos.
     */
    cursor?: ContactoInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactoInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactoInternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactoInternos.
     */
    distinct?: ContactoInternoScalarFieldEnum | ContactoInternoScalarFieldEnum[]
  }

  /**
   * ContactoInterno findMany
   */
  export type ContactoInternoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter, which ContactoInternos to fetch.
     */
    where?: ContactoInternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactoInternos to fetch.
     */
    orderBy?: ContactoInternoOrderByWithRelationInput | ContactoInternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactoInternos.
     */
    cursor?: ContactoInternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactoInternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactoInternos.
     */
    skip?: number
    distinct?: ContactoInternoScalarFieldEnum | ContactoInternoScalarFieldEnum[]
  }

  /**
   * ContactoInterno create
   */
  export type ContactoInternoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactoInterno.
     */
    data: XOR<ContactoInternoCreateInput, ContactoInternoUncheckedCreateInput>
  }

  /**
   * ContactoInterno createMany
   */
  export type ContactoInternoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactoInternos.
     */
    data: ContactoInternoCreateManyInput | ContactoInternoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactoInterno createManyAndReturn
   */
  export type ContactoInternoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * The data used to create many ContactoInternos.
     */
    data: ContactoInternoCreateManyInput | ContactoInternoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactoInterno update
   */
  export type ContactoInternoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactoInterno.
     */
    data: XOR<ContactoInternoUpdateInput, ContactoInternoUncheckedUpdateInput>
    /**
     * Choose, which ContactoInterno to update.
     */
    where: ContactoInternoWhereUniqueInput
  }

  /**
   * ContactoInterno updateMany
   */
  export type ContactoInternoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactoInternos.
     */
    data: XOR<ContactoInternoUpdateManyMutationInput, ContactoInternoUncheckedUpdateManyInput>
    /**
     * Filter which ContactoInternos to update
     */
    where?: ContactoInternoWhereInput
    /**
     * Limit how many ContactoInternos to update.
     */
    limit?: number
  }

  /**
   * ContactoInterno updateManyAndReturn
   */
  export type ContactoInternoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * The data used to update ContactoInternos.
     */
    data: XOR<ContactoInternoUpdateManyMutationInput, ContactoInternoUncheckedUpdateManyInput>
    /**
     * Filter which ContactoInternos to update
     */
    where?: ContactoInternoWhereInput
    /**
     * Limit how many ContactoInternos to update.
     */
    limit?: number
  }

  /**
   * ContactoInterno upsert
   */
  export type ContactoInternoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactoInterno to update in case it exists.
     */
    where: ContactoInternoWhereUniqueInput
    /**
     * In case the ContactoInterno found by the `where` argument doesn't exist, create a new ContactoInterno with this data.
     */
    create: XOR<ContactoInternoCreateInput, ContactoInternoUncheckedCreateInput>
    /**
     * In case the ContactoInterno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactoInternoUpdateInput, ContactoInternoUncheckedUpdateInput>
  }

  /**
   * ContactoInterno delete
   */
  export type ContactoInternoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
    /**
     * Filter which ContactoInterno to delete.
     */
    where: ContactoInternoWhereUniqueInput
  }

  /**
   * ContactoInterno deleteMany
   */
  export type ContactoInternoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactoInternos to delete
     */
    where?: ContactoInternoWhereInput
    /**
     * Limit how many ContactoInternos to delete.
     */
    limit?: number
  }

  /**
   * ContactoInterno without action
   */
  export type ContactoInternoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoInterno
     */
    select?: ContactoInternoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactoInterno
     */
    omit?: ContactoInternoOmit<ExtArgs> | null
  }


  /**
   * Model Auto
   */

  export type AggregateAuto = {
    _count: AutoCountAggregateOutputType | null
    _avg: AutoAvgAggregateOutputType | null
    _sum: AutoSumAggregateOutputType | null
    _min: AutoMinAggregateOutputType | null
    _max: AutoMaxAggregateOutputType | null
  }

  export type AutoAvgAggregateOutputType = {
    id_auto: number | null
    id_producto: number | null
    capacidad: number | null
  }

  export type AutoSumAggregateOutputType = {
    id_auto: number | null
    id_producto: number | null
    capacidad: number | null
  }

  export type AutoMinAggregateOutputType = {
    id_auto: number | null
    id_producto: number | null
    modelo: string | null
    marca: string | null
    capacidad: number | null
    ubicacion_actual: string | null
    estado: string | null
  }

  export type AutoMaxAggregateOutputType = {
    id_auto: number | null
    id_producto: number | null
    modelo: string | null
    marca: string | null
    capacidad: number | null
    ubicacion_actual: string | null
    estado: string | null
  }

  export type AutoCountAggregateOutputType = {
    id_auto: number
    id_producto: number
    modelo: number
    marca: number
    capacidad: number
    ubicacion_actual: number
    estado: number
    _all: number
  }


  export type AutoAvgAggregateInputType = {
    id_auto?: true
    id_producto?: true
    capacidad?: true
  }

  export type AutoSumAggregateInputType = {
    id_auto?: true
    id_producto?: true
    capacidad?: true
  }

  export type AutoMinAggregateInputType = {
    id_auto?: true
    id_producto?: true
    modelo?: true
    marca?: true
    capacidad?: true
    ubicacion_actual?: true
    estado?: true
  }

  export type AutoMaxAggregateInputType = {
    id_auto?: true
    id_producto?: true
    modelo?: true
    marca?: true
    capacidad?: true
    ubicacion_actual?: true
    estado?: true
  }

  export type AutoCountAggregateInputType = {
    id_auto?: true
    id_producto?: true
    modelo?: true
    marca?: true
    capacidad?: true
    ubicacion_actual?: true
    estado?: true
    _all?: true
  }

  export type AutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auto to aggregate.
     */
    where?: AutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autos to fetch.
     */
    orderBy?: AutoOrderByWithRelationInput | AutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Autos
    **/
    _count?: true | AutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoMaxAggregateInputType
  }

  export type GetAutoAggregateType<T extends AutoAggregateArgs> = {
        [P in keyof T & keyof AggregateAuto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuto[P]>
      : GetScalarType<T[P], AggregateAuto[P]>
  }




  export type AutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoWhereInput
    orderBy?: AutoOrderByWithAggregationInput | AutoOrderByWithAggregationInput[]
    by: AutoScalarFieldEnum[] | AutoScalarFieldEnum
    having?: AutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoCountAggregateInputType | true
    _avg?: AutoAvgAggregateInputType
    _sum?: AutoSumAggregateInputType
    _min?: AutoMinAggregateInputType
    _max?: AutoMaxAggregateInputType
  }

  export type AutoGroupByOutputType = {
    id_auto: number
    id_producto: number
    modelo: string | null
    marca: string | null
    capacidad: number | null
    ubicacion_actual: string | null
    estado: string
    _count: AutoCountAggregateOutputType | null
    _avg: AutoAvgAggregateOutputType | null
    _sum: AutoSumAggregateOutputType | null
    _min: AutoMinAggregateOutputType | null
    _max: AutoMaxAggregateOutputType | null
  }

  type GetAutoGroupByPayload<T extends AutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoGroupByOutputType[P]>
            : GetScalarType<T[P], AutoGroupByOutputType[P]>
        }
      >
    >


  export type AutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_auto?: boolean
    id_producto?: boolean
    modelo?: boolean
    marca?: boolean
    capacidad?: boolean
    ubicacion_actual?: boolean
    estado?: boolean
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auto"]>

  export type AutoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_auto?: boolean
    id_producto?: boolean
    modelo?: boolean
    marca?: boolean
    capacidad?: boolean
    ubicacion_actual?: boolean
    estado?: boolean
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auto"]>

  export type AutoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_auto?: boolean
    id_producto?: boolean
    modelo?: boolean
    marca?: boolean
    capacidad?: boolean
    ubicacion_actual?: boolean
    estado?: boolean
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auto"]>

  export type AutoSelectScalar = {
    id_auto?: boolean
    id_producto?: boolean
    modelo?: boolean
    marca?: boolean
    capacidad?: boolean
    ubicacion_actual?: boolean
    estado?: boolean
  }

  export type AutoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_auto" | "id_producto" | "modelo" | "marca" | "capacidad" | "ubicacion_actual" | "estado", ExtArgs["result"]["auto"]>
  export type AutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type AutoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }
  export type AutoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $AutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auto"
    objects: {
      Producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_auto: number
      id_producto: number
      modelo: string | null
      marca: string | null
      capacidad: number | null
      ubicacion_actual: string | null
      estado: string
    }, ExtArgs["result"]["auto"]>
    composites: {}
  }

  type AutoGetPayload<S extends boolean | null | undefined | AutoDefaultArgs> = $Result.GetResult<Prisma.$AutoPayload, S>

  type AutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoCountAggregateInputType | true
    }

  export interface AutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auto'], meta: { name: 'Auto' } }
    /**
     * Find zero or one Auto that matches the filter.
     * @param {AutoFindUniqueArgs} args - Arguments to find a Auto
     * @example
     * // Get one Auto
     * const auto = await prisma.auto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoFindUniqueArgs>(args: SelectSubset<T, AutoFindUniqueArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoFindUniqueOrThrowArgs} args - Arguments to find a Auto
     * @example
     * // Get one Auto
     * const auto = await prisma.auto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoFindFirstArgs} args - Arguments to find a Auto
     * @example
     * // Get one Auto
     * const auto = await prisma.auto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoFindFirstArgs>(args?: SelectSubset<T, AutoFindFirstArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoFindFirstOrThrowArgs} args - Arguments to find a Auto
     * @example
     * // Get one Auto
     * const auto = await prisma.auto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos
     * const autos = await prisma.auto.findMany()
     * 
     * // Get first 10 Autos
     * const autos = await prisma.auto.findMany({ take: 10 })
     * 
     * // Only select the `id_auto`
     * const autoWithId_autoOnly = await prisma.auto.findMany({ select: { id_auto: true } })
     * 
     */
    findMany<T extends AutoFindManyArgs>(args?: SelectSubset<T, AutoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auto.
     * @param {AutoCreateArgs} args - Arguments to create a Auto.
     * @example
     * // Create one Auto
     * const Auto = await prisma.auto.create({
     *   data: {
     *     // ... data to create a Auto
     *   }
     * })
     * 
     */
    create<T extends AutoCreateArgs>(args: SelectSubset<T, AutoCreateArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Autos.
     * @param {AutoCreateManyArgs} args - Arguments to create many Autos.
     * @example
     * // Create many Autos
     * const auto = await prisma.auto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoCreateManyArgs>(args?: SelectSubset<T, AutoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Autos and returns the data saved in the database.
     * @param {AutoCreateManyAndReturnArgs} args - Arguments to create many Autos.
     * @example
     * // Create many Autos
     * const auto = await prisma.auto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Autos and only return the `id_auto`
     * const autoWithId_autoOnly = await prisma.auto.createManyAndReturn({
     *   select: { id_auto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auto.
     * @param {AutoDeleteArgs} args - Arguments to delete one Auto.
     * @example
     * // Delete one Auto
     * const Auto = await prisma.auto.delete({
     *   where: {
     *     // ... filter to delete one Auto
     *   }
     * })
     * 
     */
    delete<T extends AutoDeleteArgs>(args: SelectSubset<T, AutoDeleteArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auto.
     * @param {AutoUpdateArgs} args - Arguments to update one Auto.
     * @example
     * // Update one Auto
     * const auto = await prisma.auto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoUpdateArgs>(args: SelectSubset<T, AutoUpdateArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Autos.
     * @param {AutoDeleteManyArgs} args - Arguments to filter Autos to delete.
     * @example
     * // Delete a few Autos
     * const { count } = await prisma.auto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoDeleteManyArgs>(args?: SelectSubset<T, AutoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos
     * const auto = await prisma.auto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoUpdateManyArgs>(args: SelectSubset<T, AutoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos and returns the data updated in the database.
     * @param {AutoUpdateManyAndReturnArgs} args - Arguments to update many Autos.
     * @example
     * // Update many Autos
     * const auto = await prisma.auto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Autos and only return the `id_auto`
     * const autoWithId_autoOnly = await prisma.auto.updateManyAndReturn({
     *   select: { id_auto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutoUpdateManyAndReturnArgs>(args: SelectSubset<T, AutoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auto.
     * @param {AutoUpsertArgs} args - Arguments to update or create a Auto.
     * @example
     * // Update or create a Auto
     * const auto = await prisma.auto.upsert({
     *   create: {
     *     // ... data to create a Auto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auto we want to update
     *   }
     * })
     */
    upsert<T extends AutoUpsertArgs>(args: SelectSubset<T, AutoUpsertArgs<ExtArgs>>): Prisma__AutoClient<$Result.GetResult<Prisma.$AutoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoCountArgs} args - Arguments to filter Autos to count.
     * @example
     * // Count the number of Autos
     * const count = await prisma.auto.count({
     *   where: {
     *     // ... the filter for the Autos we want to count
     *   }
     * })
    **/
    count<T extends AutoCountArgs>(
      args?: Subset<T, AutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoAggregateArgs>(args: Subset<T, AutoAggregateArgs>): Prisma.PrismaPromise<GetAutoAggregateType<T>>

    /**
     * Group by Auto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoGroupByArgs['orderBy'] }
        : { orderBy?: AutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auto model
   */
  readonly fields: AutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auto model
   */
  interface AutoFieldRefs {
    readonly id_auto: FieldRef<"Auto", 'Int'>
    readonly id_producto: FieldRef<"Auto", 'Int'>
    readonly modelo: FieldRef<"Auto", 'String'>
    readonly marca: FieldRef<"Auto", 'String'>
    readonly capacidad: FieldRef<"Auto", 'Int'>
    readonly ubicacion_actual: FieldRef<"Auto", 'String'>
    readonly estado: FieldRef<"Auto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Auto findUnique
   */
  export type AutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter, which Auto to fetch.
     */
    where: AutoWhereUniqueInput
  }

  /**
   * Auto findUniqueOrThrow
   */
  export type AutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter, which Auto to fetch.
     */
    where: AutoWhereUniqueInput
  }

  /**
   * Auto findFirst
   */
  export type AutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter, which Auto to fetch.
     */
    where?: AutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autos to fetch.
     */
    orderBy?: AutoOrderByWithRelationInput | AutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Autos.
     */
    cursor?: AutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Autos.
     */
    distinct?: AutoScalarFieldEnum | AutoScalarFieldEnum[]
  }

  /**
   * Auto findFirstOrThrow
   */
  export type AutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter, which Auto to fetch.
     */
    where?: AutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autos to fetch.
     */
    orderBy?: AutoOrderByWithRelationInput | AutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Autos.
     */
    cursor?: AutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Autos.
     */
    distinct?: AutoScalarFieldEnum | AutoScalarFieldEnum[]
  }

  /**
   * Auto findMany
   */
  export type AutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter, which Autos to fetch.
     */
    where?: AutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autos to fetch.
     */
    orderBy?: AutoOrderByWithRelationInput | AutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Autos.
     */
    cursor?: AutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autos.
     */
    skip?: number
    distinct?: AutoScalarFieldEnum | AutoScalarFieldEnum[]
  }

  /**
   * Auto create
   */
  export type AutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * The data needed to create a Auto.
     */
    data: XOR<AutoCreateInput, AutoUncheckedCreateInput>
  }

  /**
   * Auto createMany
   */
  export type AutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Autos.
     */
    data: AutoCreateManyInput | AutoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auto createManyAndReturn
   */
  export type AutoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * The data used to create many Autos.
     */
    data: AutoCreateManyInput | AutoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auto update
   */
  export type AutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * The data needed to update a Auto.
     */
    data: XOR<AutoUpdateInput, AutoUncheckedUpdateInput>
    /**
     * Choose, which Auto to update.
     */
    where: AutoWhereUniqueInput
  }

  /**
   * Auto updateMany
   */
  export type AutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Autos.
     */
    data: XOR<AutoUpdateManyMutationInput, AutoUncheckedUpdateManyInput>
    /**
     * Filter which Autos to update
     */
    where?: AutoWhereInput
    /**
     * Limit how many Autos to update.
     */
    limit?: number
  }

  /**
   * Auto updateManyAndReturn
   */
  export type AutoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * The data used to update Autos.
     */
    data: XOR<AutoUpdateManyMutationInput, AutoUncheckedUpdateManyInput>
    /**
     * Filter which Autos to update
     */
    where?: AutoWhereInput
    /**
     * Limit how many Autos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auto upsert
   */
  export type AutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * The filter to search for the Auto to update in case it exists.
     */
    where: AutoWhereUniqueInput
    /**
     * In case the Auto found by the `where` argument doesn't exist, create a new Auto with this data.
     */
    create: XOR<AutoCreateInput, AutoUncheckedCreateInput>
    /**
     * In case the Auto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoUpdateInput, AutoUncheckedUpdateInput>
  }

  /**
   * Auto delete
   */
  export type AutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
    /**
     * Filter which Auto to delete.
     */
    where: AutoWhereUniqueInput
  }

  /**
   * Auto deleteMany
   */
  export type AutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Autos to delete
     */
    where?: AutoWhereInput
    /**
     * Limit how many Autos to delete.
     */
    limit?: number
  }

  /**
   * Auto without action
   */
  export type AutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auto
     */
    select?: AutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auto
     */
    omit?: AutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoInclude<ExtArgs> | null
  }


  /**
   * Model Venta
   */

  export type AggregateVenta = {
    _count: VentaCountAggregateOutputType | null
    _avg: VentaAvgAggregateOutputType | null
    _sum: VentaSumAggregateOutputType | null
    _min: VentaMinAggregateOutputType | null
    _max: VentaMaxAggregateOutputType | null
  }

  export type VentaAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    monto: number | null
  }

  export type VentaSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    monto: number | null
  }

  export type VentaMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    monto: number | null
    fecha: Date | null
  }

  export type VentaMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    monto: number | null
    fecha: Date | null
  }

  export type VentaCountAggregateOutputType = {
    id: number
    pedidoId: number
    monto: number
    fecha: number
    _all: number
  }


  export type VentaAvgAggregateInputType = {
    id?: true
    pedidoId?: true
    monto?: true
  }

  export type VentaSumAggregateInputType = {
    id?: true
    pedidoId?: true
    monto?: true
  }

  export type VentaMinAggregateInputType = {
    id?: true
    pedidoId?: true
    monto?: true
    fecha?: true
  }

  export type VentaMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    monto?: true
    fecha?: true
  }

  export type VentaCountAggregateInputType = {
    id?: true
    pedidoId?: true
    monto?: true
    fecha?: true
    _all?: true
  }

  export type VentaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venta to aggregate.
     */
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentaOrderByWithRelationInput | VentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventas
    **/
    _count?: true | VentaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VentaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VentaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentaMaxAggregateInputType
  }

  export type GetVentaAggregateType<T extends VentaAggregateArgs> = {
        [P in keyof T & keyof AggregateVenta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenta[P]>
      : GetScalarType<T[P], AggregateVenta[P]>
  }




  export type VentaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentaWhereInput
    orderBy?: VentaOrderByWithAggregationInput | VentaOrderByWithAggregationInput[]
    by: VentaScalarFieldEnum[] | VentaScalarFieldEnum
    having?: VentaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentaCountAggregateInputType | true
    _avg?: VentaAvgAggregateInputType
    _sum?: VentaSumAggregateInputType
    _min?: VentaMinAggregateInputType
    _max?: VentaMaxAggregateInputType
  }

  export type VentaGroupByOutputType = {
    id: number
    pedidoId: number
    monto: number
    fecha: Date
    _count: VentaCountAggregateOutputType | null
    _avg: VentaAvgAggregateOutputType | null
    _sum: VentaSumAggregateOutputType | null
    _min: VentaMinAggregateOutputType | null
    _max: VentaMaxAggregateOutputType | null
  }

  type GetVentaGroupByPayload<T extends VentaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentaGroupByOutputType[P]>
            : GetScalarType<T[P], VentaGroupByOutputType[P]>
        }
      >
    >


  export type VentaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    monto?: boolean
    fecha?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venta"]>

  export type VentaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    monto?: boolean
    fecha?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venta"]>

  export type VentaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    monto?: boolean
    fecha?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venta"]>

  export type VentaSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    monto?: boolean
    fecha?: boolean
  }

  export type VentaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pedidoId" | "monto" | "fecha", ExtArgs["result"]["venta"]>
  export type VentaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }
  export type VentaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }
  export type VentaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }

  export type $VentaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venta"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number
      monto: number
      fecha: Date
    }, ExtArgs["result"]["venta"]>
    composites: {}
  }

  type VentaGetPayload<S extends boolean | null | undefined | VentaDefaultArgs> = $Result.GetResult<Prisma.$VentaPayload, S>

  type VentaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VentaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VentaCountAggregateInputType | true
    }

  export interface VentaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venta'], meta: { name: 'Venta' } }
    /**
     * Find zero or one Venta that matches the filter.
     * @param {VentaFindUniqueArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentaFindUniqueArgs>(args: SelectSubset<T, VentaFindUniqueArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VentaFindUniqueOrThrowArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentaFindUniqueOrThrowArgs>(args: SelectSubset<T, VentaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaFindFirstArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentaFindFirstArgs>(args?: SelectSubset<T, VentaFindFirstArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaFindFirstOrThrowArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentaFindFirstOrThrowArgs>(args?: SelectSubset<T, VentaFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventas
     * const ventas = await prisma.venta.findMany()
     * 
     * // Get first 10 Ventas
     * const ventas = await prisma.venta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventaWithIdOnly = await prisma.venta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentaFindManyArgs>(args?: SelectSubset<T, VentaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venta.
     * @param {VentaCreateArgs} args - Arguments to create a Venta.
     * @example
     * // Create one Venta
     * const Venta = await prisma.venta.create({
     *   data: {
     *     // ... data to create a Venta
     *   }
     * })
     * 
     */
    create<T extends VentaCreateArgs>(args: SelectSubset<T, VentaCreateArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ventas.
     * @param {VentaCreateManyArgs} args - Arguments to create many Ventas.
     * @example
     * // Create many Ventas
     * const venta = await prisma.venta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentaCreateManyArgs>(args?: SelectSubset<T, VentaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ventas and returns the data saved in the database.
     * @param {VentaCreateManyAndReturnArgs} args - Arguments to create many Ventas.
     * @example
     * // Create many Ventas
     * const venta = await prisma.venta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ventas and only return the `id`
     * const ventaWithIdOnly = await prisma.venta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentaCreateManyAndReturnArgs>(args?: SelectSubset<T, VentaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Venta.
     * @param {VentaDeleteArgs} args - Arguments to delete one Venta.
     * @example
     * // Delete one Venta
     * const Venta = await prisma.venta.delete({
     *   where: {
     *     // ... filter to delete one Venta
     *   }
     * })
     * 
     */
    delete<T extends VentaDeleteArgs>(args: SelectSubset<T, VentaDeleteArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venta.
     * @param {VentaUpdateArgs} args - Arguments to update one Venta.
     * @example
     * // Update one Venta
     * const venta = await prisma.venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentaUpdateArgs>(args: SelectSubset<T, VentaUpdateArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ventas.
     * @param {VentaDeleteManyArgs} args - Arguments to filter Ventas to delete.
     * @example
     * // Delete a few Ventas
     * const { count } = await prisma.venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentaDeleteManyArgs>(args?: SelectSubset<T, VentaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventas
     * const venta = await prisma.venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentaUpdateManyArgs>(args: SelectSubset<T, VentaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventas and returns the data updated in the database.
     * @param {VentaUpdateManyAndReturnArgs} args - Arguments to update many Ventas.
     * @example
     * // Update many Ventas
     * const venta = await prisma.venta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ventas and only return the `id`
     * const ventaWithIdOnly = await prisma.venta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VentaUpdateManyAndReturnArgs>(args: SelectSubset<T, VentaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Venta.
     * @param {VentaUpsertArgs} args - Arguments to update or create a Venta.
     * @example
     * // Update or create a Venta
     * const venta = await prisma.venta.upsert({
     *   create: {
     *     // ... data to create a Venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venta we want to update
     *   }
     * })
     */
    upsert<T extends VentaUpsertArgs>(args: SelectSubset<T, VentaUpsertArgs<ExtArgs>>): Prisma__VentaClient<$Result.GetResult<Prisma.$VentaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaCountArgs} args - Arguments to filter Ventas to count.
     * @example
     * // Count the number of Ventas
     * const count = await prisma.venta.count({
     *   where: {
     *     // ... the filter for the Ventas we want to count
     *   }
     * })
    **/
    count<T extends VentaCountArgs>(
      args?: Subset<T, VentaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentaAggregateArgs>(args: Subset<T, VentaAggregateArgs>): Prisma.PrismaPromise<GetVentaAggregateType<T>>

    /**
     * Group by Venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentaGroupByArgs['orderBy'] }
        : { orderBy?: VentaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venta model
   */
  readonly fields: VentaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venta model
   */
  interface VentaFieldRefs {
    readonly id: FieldRef<"Venta", 'Int'>
    readonly pedidoId: FieldRef<"Venta", 'Int'>
    readonly monto: FieldRef<"Venta", 'Float'>
    readonly fecha: FieldRef<"Venta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venta findUnique
   */
  export type VentaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter, which Venta to fetch.
     */
    where: VentaWhereUniqueInput
  }

  /**
   * Venta findUniqueOrThrow
   */
  export type VentaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter, which Venta to fetch.
     */
    where: VentaWhereUniqueInput
  }

  /**
   * Venta findFirst
   */
  export type VentaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter, which Venta to fetch.
     */
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentaOrderByWithRelationInput | VentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventas.
     */
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventas.
     */
    distinct?: VentaScalarFieldEnum | VentaScalarFieldEnum[]
  }

  /**
   * Venta findFirstOrThrow
   */
  export type VentaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter, which Venta to fetch.
     */
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentaOrderByWithRelationInput | VentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventas.
     */
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventas.
     */
    distinct?: VentaScalarFieldEnum | VentaScalarFieldEnum[]
  }

  /**
   * Venta findMany
   */
  export type VentaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentaOrderByWithRelationInput | VentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventas.
     */
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    distinct?: VentaScalarFieldEnum | VentaScalarFieldEnum[]
  }

  /**
   * Venta create
   */
  export type VentaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * The data needed to create a Venta.
     */
    data: XOR<VentaCreateInput, VentaUncheckedCreateInput>
  }

  /**
   * Venta createMany
   */
  export type VentaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ventas.
     */
    data: VentaCreateManyInput | VentaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venta createManyAndReturn
   */
  export type VentaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * The data used to create many Ventas.
     */
    data: VentaCreateManyInput | VentaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venta update
   */
  export type VentaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * The data needed to update a Venta.
     */
    data: XOR<VentaUpdateInput, VentaUncheckedUpdateInput>
    /**
     * Choose, which Venta to update.
     */
    where: VentaWhereUniqueInput
  }

  /**
   * Venta updateMany
   */
  export type VentaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ventas.
     */
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyInput>
    /**
     * Filter which Ventas to update
     */
    where?: VentaWhereInput
    /**
     * Limit how many Ventas to update.
     */
    limit?: number
  }

  /**
   * Venta updateManyAndReturn
   */
  export type VentaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * The data used to update Ventas.
     */
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyInput>
    /**
     * Filter which Ventas to update
     */
    where?: VentaWhereInput
    /**
     * Limit how many Ventas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venta upsert
   */
  export type VentaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * The filter to search for the Venta to update in case it exists.
     */
    where: VentaWhereUniqueInput
    /**
     * In case the Venta found by the `where` argument doesn't exist, create a new Venta with this data.
     */
    create: XOR<VentaCreateInput, VentaUncheckedCreateInput>
    /**
     * In case the Venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentaUpdateInput, VentaUncheckedUpdateInput>
  }

  /**
   * Venta delete
   */
  export type VentaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
    /**
     * Filter which Venta to delete.
     */
    where: VentaWhereUniqueInput
  }

  /**
   * Venta deleteMany
   */
  export type VentaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventas to delete
     */
    where?: VentaWhereInput
    /**
     * Limit how many Ventas to delete.
     */
    limit?: number
  }

  /**
   * Venta without action
   */
  export type VentaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venta
     */
    select?: VentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venta
     */
    omit?: VentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClienteScalarFieldEnum: {
    id_cliente: 'id_cliente',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    contrasena: 'contrasena',
    telefono: 'telefono',
    direccion: 'direccion',
    fecha_registro: 'fecha_registro',
    activo: 'activo',
    email_verificado: 'email_verificado',
    token_verificacion_email: 'token_verificacion_email'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id_rol: 'id_rol',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const UsuarioInternoScalarFieldEnum: {
    id_usuario: 'id_usuario',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    contrasena: 'contrasena',
    telefono: 'telefono',
    activo: 'activo',
    id_rol: 'id_rol'
  };

  export type UsuarioInternoScalarFieldEnum = (typeof UsuarioInternoScalarFieldEnum)[keyof typeof UsuarioInternoScalarFieldEnum]


  export const TipoProductoScalarFieldEnum: {
    id_tipo: 'id_tipo',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type TipoProductoScalarFieldEnum = (typeof TipoProductoScalarFieldEnum)[keyof typeof TipoProductoScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id_producto: 'id_producto',
    nombre: 'nombre',
    tipo: 'tipo',
    descripcion: 'descripcion',
    precio: 'precio',
    stock: 'stock',
    activo: 'activo',
    id_tipo: 'id_tipo'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const HospedajeScalarFieldEnum: {
    id_hospedaje: 'id_hospedaje',
    id_producto: 'id_producto',
    ubicacion: 'ubicacion',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    capacidad: 'capacidad'
  };

  export type HospedajeScalarFieldEnum = (typeof HospedajeScalarFieldEnum)[keyof typeof HospedajeScalarFieldEnum]


  export const PasajeScalarFieldEnum: {
    id_pasaje: 'id_pasaje',
    id_producto: 'id_producto',
    origen: 'origen',
    destino: 'destino',
    fecha_salida: 'fecha_salida',
    fecha_regreso: 'fecha_regreso',
    clase: 'clase',
    asientos_disponibles: 'asientos_disponibles',
    aerolinea: 'aerolinea'
  };

  export type PasajeScalarFieldEnum = (typeof PasajeScalarFieldEnum)[keyof typeof PasajeScalarFieldEnum]


  export const AlquilerScalarFieldEnum: {
    id_alquiler: 'id_alquiler',
    id_producto: 'id_producto',
    tipo_vehiculo: 'tipo_vehiculo',
    ubicacion: 'ubicacion',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    cantidad: 'cantidad'
  };

  export type AlquilerScalarFieldEnum = (typeof AlquilerScalarFieldEnum)[keyof typeof AlquilerScalarFieldEnum]


  export const PaqueteDetalleScalarFieldEnum: {
    id_detalle: 'id_detalle',
    id_paquete: 'id_paquete',
    id_producto: 'id_producto',
    cantidad: 'cantidad'
  };

  export type PaqueteDetalleScalarFieldEnum = (typeof PaqueteDetalleScalarFieldEnum)[keyof typeof PaqueteDetalleScalarFieldEnum]


  export const CarritoScalarFieldEnum: {
    id_carrito: 'id_carrito',
    id_cliente: 'id_cliente',
    fecha_creacion: 'fecha_creacion'
  };

  export type CarritoScalarFieldEnum = (typeof CarritoScalarFieldEnum)[keyof typeof CarritoScalarFieldEnum]


  export const CarritoItemScalarFieldEnum: {
    id_item: 'id_item',
    id_carrito: 'id_carrito',
    id_producto: 'id_producto',
    cantidad: 'cantidad'
  };

  export type CarritoItemScalarFieldEnum = (typeof CarritoItemScalarFieldEnum)[keyof typeof CarritoItemScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id_pedido: 'id_pedido',
    total: 'total',
    estado: 'estado',
    fecha_pedido: 'fecha_pedido',
    id_cliente: 'id_cliente'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const PedidoItemScalarFieldEnum: {
    id_detalle: 'id_detalle',
    id_pedido: 'id_pedido',
    id_producto: 'id_producto',
    cantidad: 'cantidad',
    precio: 'precio'
  };

  export type PedidoItemScalarFieldEnum = (typeof PedidoItemScalarFieldEnum)[keyof typeof PedidoItemScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    id_pago: 'id_pago',
    id_pedido: 'id_pedido',
    fecha_pago: 'fecha_pago',
    monto: 'monto',
    metodo: 'metodo',
    estado: 'estado'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const ContactoInternoScalarFieldEnum: {
    id_contacto: 'id_contacto',
    nombre: 'nombre',
    email: 'email',
    telefono: 'telefono',
    cargo: 'cargo'
  };

  export type ContactoInternoScalarFieldEnum = (typeof ContactoInternoScalarFieldEnum)[keyof typeof ContactoInternoScalarFieldEnum]


  export const AutoScalarFieldEnum: {
    id_auto: 'id_auto',
    id_producto: 'id_producto',
    modelo: 'modelo',
    marca: 'marca',
    capacidad: 'capacidad',
    ubicacion_actual: 'ubicacion_actual',
    estado: 'estado'
  };

  export type AutoScalarFieldEnum = (typeof AutoScalarFieldEnum)[keyof typeof AutoScalarFieldEnum]


  export const VentaScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    monto: 'monto',
    fecha: 'fecha'
  };

  export type VentaScalarFieldEnum = (typeof VentaScalarFieldEnum)[keyof typeof VentaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id_cliente?: IntFilter<"Cliente"> | number
    nombre?: StringFilter<"Cliente"> | string
    apellido?: StringNullableFilter<"Cliente"> | string | null
    email?: StringFilter<"Cliente"> | string
    contrasena?: StringFilter<"Cliente"> | string
    telefono?: StringNullableFilter<"Cliente"> | string | null
    direccion?: StringNullableFilter<"Cliente"> | string | null
    fecha_registro?: DateTimeFilter<"Cliente"> | Date | string
    activo?: BoolFilter<"Cliente"> | boolean
    email_verificado?: BoolFilter<"Cliente"> | boolean
    token_verificacion_email?: StringNullableFilter<"Cliente"> | string | null
    carritos?: CarritoListRelationFilter
    pedidos?: PedidoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fecha_registro?: SortOrder
    activo?: SortOrder
    email_verificado?: SortOrder
    token_verificacion_email?: SortOrderInput | SortOrder
    carritos?: CarritoOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id_cliente?: number
    email?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nombre?: StringFilter<"Cliente"> | string
    apellido?: StringNullableFilter<"Cliente"> | string | null
    contrasena?: StringFilter<"Cliente"> | string
    telefono?: StringNullableFilter<"Cliente"> | string | null
    direccion?: StringNullableFilter<"Cliente"> | string | null
    fecha_registro?: DateTimeFilter<"Cliente"> | Date | string
    activo?: BoolFilter<"Cliente"> | boolean
    email_verificado?: BoolFilter<"Cliente"> | boolean
    token_verificacion_email?: StringNullableFilter<"Cliente"> | string | null
    carritos?: CarritoListRelationFilter
    pedidos?: PedidoListRelationFilter
  }, "id_cliente" | "email">

  export type ClienteOrderByWithAggregationInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fecha_registro?: SortOrder
    activo?: SortOrder
    email_verificado?: SortOrder
    token_verificacion_email?: SortOrderInput | SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id_cliente?: IntWithAggregatesFilter<"Cliente"> | number
    nombre?: StringWithAggregatesFilter<"Cliente"> | string
    apellido?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    email?: StringWithAggregatesFilter<"Cliente"> | string
    contrasena?: StringWithAggregatesFilter<"Cliente"> | string
    telefono?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    fecha_registro?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    activo?: BoolWithAggregatesFilter<"Cliente"> | boolean
    email_verificado?: BoolWithAggregatesFilter<"Cliente"> | boolean
    token_verificacion_email?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id_rol?: IntFilter<"Rol"> | number
    nombre?: StringFilter<"Rol"> | string
    descripcion?: StringNullableFilter<"Rol"> | string | null
    usuarios?: UsuarioInternoListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    usuarios?: UsuarioInternoOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id_rol?: number
    nombre?: string
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    descripcion?: StringNullableFilter<"Rol"> | string | null
    usuarios?: UsuarioInternoListRelationFilter
  }, "id_rol" | "nombre">

  export type RolOrderByWithAggregationInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: RolCountOrderByAggregateInput
    _avg?: RolAvgOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
    _sum?: RolSumOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id_rol?: IntWithAggregatesFilter<"Rol"> | number
    nombre?: StringWithAggregatesFilter<"Rol"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Rol"> | string | null
  }

  export type UsuarioInternoWhereInput = {
    AND?: UsuarioInternoWhereInput | UsuarioInternoWhereInput[]
    OR?: UsuarioInternoWhereInput[]
    NOT?: UsuarioInternoWhereInput | UsuarioInternoWhereInput[]
    id_usuario?: IntFilter<"UsuarioInterno"> | number
    nombre?: StringFilter<"UsuarioInterno"> | string
    apellido?: StringNullableFilter<"UsuarioInterno"> | string | null
    email?: StringFilter<"UsuarioInterno"> | string
    contrasena?: StringFilter<"UsuarioInterno"> | string
    telefono?: StringNullableFilter<"UsuarioInterno"> | string | null
    activo?: BoolFilter<"UsuarioInterno"> | boolean
    id_rol?: IntFilter<"UsuarioInterno"> | number
    rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }

  export type UsuarioInternoOrderByWithRelationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrderInput | SortOrder
    activo?: SortOrder
    id_rol?: SortOrder
    rol?: RolOrderByWithRelationInput
  }

  export type UsuarioInternoWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    email?: string
    AND?: UsuarioInternoWhereInput | UsuarioInternoWhereInput[]
    OR?: UsuarioInternoWhereInput[]
    NOT?: UsuarioInternoWhereInput | UsuarioInternoWhereInput[]
    nombre?: StringFilter<"UsuarioInterno"> | string
    apellido?: StringNullableFilter<"UsuarioInterno"> | string | null
    contrasena?: StringFilter<"UsuarioInterno"> | string
    telefono?: StringNullableFilter<"UsuarioInterno"> | string | null
    activo?: BoolFilter<"UsuarioInterno"> | boolean
    id_rol?: IntFilter<"UsuarioInterno"> | number
    rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }, "id_usuario" | "email">

  export type UsuarioInternoOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrderInput | SortOrder
    activo?: SortOrder
    id_rol?: SortOrder
    _count?: UsuarioInternoCountOrderByAggregateInput
    _avg?: UsuarioInternoAvgOrderByAggregateInput
    _max?: UsuarioInternoMaxOrderByAggregateInput
    _min?: UsuarioInternoMinOrderByAggregateInput
    _sum?: UsuarioInternoSumOrderByAggregateInput
  }

  export type UsuarioInternoScalarWhereWithAggregatesInput = {
    AND?: UsuarioInternoScalarWhereWithAggregatesInput | UsuarioInternoScalarWhereWithAggregatesInput[]
    OR?: UsuarioInternoScalarWhereWithAggregatesInput[]
    NOT?: UsuarioInternoScalarWhereWithAggregatesInput | UsuarioInternoScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"UsuarioInterno"> | number
    nombre?: StringWithAggregatesFilter<"UsuarioInterno"> | string
    apellido?: StringNullableWithAggregatesFilter<"UsuarioInterno"> | string | null
    email?: StringWithAggregatesFilter<"UsuarioInterno"> | string
    contrasena?: StringWithAggregatesFilter<"UsuarioInterno"> | string
    telefono?: StringNullableWithAggregatesFilter<"UsuarioInterno"> | string | null
    activo?: BoolWithAggregatesFilter<"UsuarioInterno"> | boolean
    id_rol?: IntWithAggregatesFilter<"UsuarioInterno"> | number
  }

  export type TipoProductoWhereInput = {
    AND?: TipoProductoWhereInput | TipoProductoWhereInput[]
    OR?: TipoProductoWhereInput[]
    NOT?: TipoProductoWhereInput | TipoProductoWhereInput[]
    id_tipo?: IntFilter<"TipoProducto"> | number
    nombre?: StringFilter<"TipoProducto"> | string
    descripcion?: StringNullableFilter<"TipoProducto"> | string | null
    productos?: ProductoListRelationFilter
  }

  export type TipoProductoOrderByWithRelationInput = {
    id_tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    productos?: ProductoOrderByRelationAggregateInput
  }

  export type TipoProductoWhereUniqueInput = Prisma.AtLeast<{
    id_tipo?: number
    nombre?: string
    AND?: TipoProductoWhereInput | TipoProductoWhereInput[]
    OR?: TipoProductoWhereInput[]
    NOT?: TipoProductoWhereInput | TipoProductoWhereInput[]
    descripcion?: StringNullableFilter<"TipoProducto"> | string | null
    productos?: ProductoListRelationFilter
  }, "id_tipo" | "nombre">

  export type TipoProductoOrderByWithAggregationInput = {
    id_tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: TipoProductoCountOrderByAggregateInput
    _avg?: TipoProductoAvgOrderByAggregateInput
    _max?: TipoProductoMaxOrderByAggregateInput
    _min?: TipoProductoMinOrderByAggregateInput
    _sum?: TipoProductoSumOrderByAggregateInput
  }

  export type TipoProductoScalarWhereWithAggregatesInput = {
    AND?: TipoProductoScalarWhereWithAggregatesInput | TipoProductoScalarWhereWithAggregatesInput[]
    OR?: TipoProductoScalarWhereWithAggregatesInput[]
    NOT?: TipoProductoScalarWhereWithAggregatesInput | TipoProductoScalarWhereWithAggregatesInput[]
    id_tipo?: IntWithAggregatesFilter<"TipoProducto"> | number
    nombre?: StringWithAggregatesFilter<"TipoProducto"> | string
    descripcion?: StringNullableWithAggregatesFilter<"TipoProducto"> | string | null
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id_producto?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    tipo?: StringNullableFilter<"Producto"> | string | null
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: FloatFilter<"Producto"> | number
    stock?: IntNullableFilter<"Producto"> | number | null
    activo?: BoolFilter<"Producto"> | boolean
    id_tipo?: IntNullableFilter<"Producto"> | number | null
    alquiler?: XOR<AlquilerNullableScalarRelationFilter, AlquilerWhereInput> | null
    Auto?: XOR<AutoNullableScalarRelationFilter, AutoWhereInput> | null
    carritoItems?: CarritoItemListRelationFilter
    hospedaje?: XOR<HospedajeNullableScalarRelationFilter, HospedajeWhereInput> | null
    paqueteDetallesAsPaquete?: PaqueteDetalleListRelationFilter
    paqueteDetallesAsProducto?: PaqueteDetalleListRelationFilter
    pasaje?: XOR<PasajeNullableScalarRelationFilter, PasajeWhereInput> | null
    pedidoItems?: PedidoItemListRelationFilter
    tipoProducto?: XOR<TipoProductoNullableScalarRelationFilter, TipoProductoWhereInput> | null
  }

  export type ProductoOrderByWithRelationInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    stock?: SortOrderInput | SortOrder
    activo?: SortOrder
    id_tipo?: SortOrderInput | SortOrder
    alquiler?: AlquilerOrderByWithRelationInput
    Auto?: AutoOrderByWithRelationInput
    carritoItems?: CarritoItemOrderByRelationAggregateInput
    hospedaje?: HospedajeOrderByWithRelationInput
    paqueteDetallesAsPaquete?: PaqueteDetalleOrderByRelationAggregateInput
    paqueteDetallesAsProducto?: PaqueteDetalleOrderByRelationAggregateInput
    pasaje?: PasajeOrderByWithRelationInput
    pedidoItems?: PedidoItemOrderByRelationAggregateInput
    tipoProducto?: TipoProductoOrderByWithRelationInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id_producto?: number
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    nombre?: StringFilter<"Producto"> | string
    tipo?: StringNullableFilter<"Producto"> | string | null
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: FloatFilter<"Producto"> | number
    stock?: IntNullableFilter<"Producto"> | number | null
    activo?: BoolFilter<"Producto"> | boolean
    id_tipo?: IntNullableFilter<"Producto"> | number | null
    alquiler?: XOR<AlquilerNullableScalarRelationFilter, AlquilerWhereInput> | null
    Auto?: XOR<AutoNullableScalarRelationFilter, AutoWhereInput> | null
    carritoItems?: CarritoItemListRelationFilter
    hospedaje?: XOR<HospedajeNullableScalarRelationFilter, HospedajeWhereInput> | null
    paqueteDetallesAsPaquete?: PaqueteDetalleListRelationFilter
    paqueteDetallesAsProducto?: PaqueteDetalleListRelationFilter
    pasaje?: XOR<PasajeNullableScalarRelationFilter, PasajeWhereInput> | null
    pedidoItems?: PedidoItemListRelationFilter
    tipoProducto?: XOR<TipoProductoNullableScalarRelationFilter, TipoProductoWhereInput> | null
  }, "id_producto">

  export type ProductoOrderByWithAggregationInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    stock?: SortOrderInput | SortOrder
    activo?: SortOrder
    id_tipo?: SortOrderInput | SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id_producto?: IntWithAggregatesFilter<"Producto"> | number
    nombre?: StringWithAggregatesFilter<"Producto"> | string
    tipo?: StringNullableWithAggregatesFilter<"Producto"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"Producto"> | string | null
    precio?: FloatWithAggregatesFilter<"Producto"> | number
    stock?: IntNullableWithAggregatesFilter<"Producto"> | number | null
    activo?: BoolWithAggregatesFilter<"Producto"> | boolean
    id_tipo?: IntNullableWithAggregatesFilter<"Producto"> | number | null
  }

  export type HospedajeWhereInput = {
    AND?: HospedajeWhereInput | HospedajeWhereInput[]
    OR?: HospedajeWhereInput[]
    NOT?: HospedajeWhereInput | HospedajeWhereInput[]
    id_hospedaje?: IntFilter<"Hospedaje"> | number
    id_producto?: IntFilter<"Hospedaje"> | number
    ubicacion?: StringNullableFilter<"Hospedaje"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Hospedaje"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"Hospedaje"> | Date | string | null
    capacidad?: IntNullableFilter<"Hospedaje"> | number | null
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type HospedajeOrderByWithRelationInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    ubicacion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    capacidad?: SortOrderInput | SortOrder
    producto?: ProductoOrderByWithRelationInput
  }

  export type HospedajeWhereUniqueInput = Prisma.AtLeast<{
    id_hospedaje?: number
    id_producto?: number
    AND?: HospedajeWhereInput | HospedajeWhereInput[]
    OR?: HospedajeWhereInput[]
    NOT?: HospedajeWhereInput | HospedajeWhereInput[]
    ubicacion?: StringNullableFilter<"Hospedaje"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Hospedaje"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"Hospedaje"> | Date | string | null
    capacidad?: IntNullableFilter<"Hospedaje"> | number | null
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_hospedaje" | "id_producto">

  export type HospedajeOrderByWithAggregationInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    ubicacion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    capacidad?: SortOrderInput | SortOrder
    _count?: HospedajeCountOrderByAggregateInput
    _avg?: HospedajeAvgOrderByAggregateInput
    _max?: HospedajeMaxOrderByAggregateInput
    _min?: HospedajeMinOrderByAggregateInput
    _sum?: HospedajeSumOrderByAggregateInput
  }

  export type HospedajeScalarWhereWithAggregatesInput = {
    AND?: HospedajeScalarWhereWithAggregatesInput | HospedajeScalarWhereWithAggregatesInput[]
    OR?: HospedajeScalarWhereWithAggregatesInput[]
    NOT?: HospedajeScalarWhereWithAggregatesInput | HospedajeScalarWhereWithAggregatesInput[]
    id_hospedaje?: IntWithAggregatesFilter<"Hospedaje"> | number
    id_producto?: IntWithAggregatesFilter<"Hospedaje"> | number
    ubicacion?: StringNullableWithAggregatesFilter<"Hospedaje"> | string | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"Hospedaje"> | Date | string | null
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"Hospedaje"> | Date | string | null
    capacidad?: IntNullableWithAggregatesFilter<"Hospedaje"> | number | null
  }

  export type PasajeWhereInput = {
    AND?: PasajeWhereInput | PasajeWhereInput[]
    OR?: PasajeWhereInput[]
    NOT?: PasajeWhereInput | PasajeWhereInput[]
    id_pasaje?: IntFilter<"Pasaje"> | number
    id_producto?: IntFilter<"Pasaje"> | number
    origen?: StringNullableFilter<"Pasaje"> | string | null
    destino?: StringNullableFilter<"Pasaje"> | string | null
    fecha_salida?: DateTimeNullableFilter<"Pasaje"> | Date | string | null
    fecha_regreso?: DateTimeNullableFilter<"Pasaje"> | Date | string | null
    clase?: StringNullableFilter<"Pasaje"> | string | null
    asientos_disponibles?: IntFilter<"Pasaje"> | number
    aerolinea?: StringNullableFilter<"Pasaje"> | string | null
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type PasajeOrderByWithRelationInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    origen?: SortOrderInput | SortOrder
    destino?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    fecha_regreso?: SortOrderInput | SortOrder
    clase?: SortOrderInput | SortOrder
    asientos_disponibles?: SortOrder
    aerolinea?: SortOrderInput | SortOrder
    producto?: ProductoOrderByWithRelationInput
  }

  export type PasajeWhereUniqueInput = Prisma.AtLeast<{
    id_pasaje?: number
    id_producto?: number
    AND?: PasajeWhereInput | PasajeWhereInput[]
    OR?: PasajeWhereInput[]
    NOT?: PasajeWhereInput | PasajeWhereInput[]
    origen?: StringNullableFilter<"Pasaje"> | string | null
    destino?: StringNullableFilter<"Pasaje"> | string | null
    fecha_salida?: DateTimeNullableFilter<"Pasaje"> | Date | string | null
    fecha_regreso?: DateTimeNullableFilter<"Pasaje"> | Date | string | null
    clase?: StringNullableFilter<"Pasaje"> | string | null
    asientos_disponibles?: IntFilter<"Pasaje"> | number
    aerolinea?: StringNullableFilter<"Pasaje"> | string | null
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_pasaje" | "id_producto">

  export type PasajeOrderByWithAggregationInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    origen?: SortOrderInput | SortOrder
    destino?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    fecha_regreso?: SortOrderInput | SortOrder
    clase?: SortOrderInput | SortOrder
    asientos_disponibles?: SortOrder
    aerolinea?: SortOrderInput | SortOrder
    _count?: PasajeCountOrderByAggregateInput
    _avg?: PasajeAvgOrderByAggregateInput
    _max?: PasajeMaxOrderByAggregateInput
    _min?: PasajeMinOrderByAggregateInput
    _sum?: PasajeSumOrderByAggregateInput
  }

  export type PasajeScalarWhereWithAggregatesInput = {
    AND?: PasajeScalarWhereWithAggregatesInput | PasajeScalarWhereWithAggregatesInput[]
    OR?: PasajeScalarWhereWithAggregatesInput[]
    NOT?: PasajeScalarWhereWithAggregatesInput | PasajeScalarWhereWithAggregatesInput[]
    id_pasaje?: IntWithAggregatesFilter<"Pasaje"> | number
    id_producto?: IntWithAggregatesFilter<"Pasaje"> | number
    origen?: StringNullableWithAggregatesFilter<"Pasaje"> | string | null
    destino?: StringNullableWithAggregatesFilter<"Pasaje"> | string | null
    fecha_salida?: DateTimeNullableWithAggregatesFilter<"Pasaje"> | Date | string | null
    fecha_regreso?: DateTimeNullableWithAggregatesFilter<"Pasaje"> | Date | string | null
    clase?: StringNullableWithAggregatesFilter<"Pasaje"> | string | null
    asientos_disponibles?: IntWithAggregatesFilter<"Pasaje"> | number
    aerolinea?: StringNullableWithAggregatesFilter<"Pasaje"> | string | null
  }

  export type AlquilerWhereInput = {
    AND?: AlquilerWhereInput | AlquilerWhereInput[]
    OR?: AlquilerWhereInput[]
    NOT?: AlquilerWhereInput | AlquilerWhereInput[]
    id_alquiler?: IntFilter<"Alquiler"> | number
    id_producto?: IntFilter<"Alquiler"> | number
    tipo_vehiculo?: StringNullableFilter<"Alquiler"> | string | null
    ubicacion?: StringNullableFilter<"Alquiler"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Alquiler"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"Alquiler"> | Date | string | null
    cantidad?: IntFilter<"Alquiler"> | number
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type AlquilerOrderByWithRelationInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    tipo_vehiculo?: SortOrderInput | SortOrder
    ubicacion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    producto?: ProductoOrderByWithRelationInput
  }

  export type AlquilerWhereUniqueInput = Prisma.AtLeast<{
    id_alquiler?: number
    id_producto?: number
    AND?: AlquilerWhereInput | AlquilerWhereInput[]
    OR?: AlquilerWhereInput[]
    NOT?: AlquilerWhereInput | AlquilerWhereInput[]
    tipo_vehiculo?: StringNullableFilter<"Alquiler"> | string | null
    ubicacion?: StringNullableFilter<"Alquiler"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Alquiler"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"Alquiler"> | Date | string | null
    cantidad?: IntFilter<"Alquiler"> | number
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_alquiler" | "id_producto">

  export type AlquilerOrderByWithAggregationInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    tipo_vehiculo?: SortOrderInput | SortOrder
    ubicacion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    _count?: AlquilerCountOrderByAggregateInput
    _avg?: AlquilerAvgOrderByAggregateInput
    _max?: AlquilerMaxOrderByAggregateInput
    _min?: AlquilerMinOrderByAggregateInput
    _sum?: AlquilerSumOrderByAggregateInput
  }

  export type AlquilerScalarWhereWithAggregatesInput = {
    AND?: AlquilerScalarWhereWithAggregatesInput | AlquilerScalarWhereWithAggregatesInput[]
    OR?: AlquilerScalarWhereWithAggregatesInput[]
    NOT?: AlquilerScalarWhereWithAggregatesInput | AlquilerScalarWhereWithAggregatesInput[]
    id_alquiler?: IntWithAggregatesFilter<"Alquiler"> | number
    id_producto?: IntWithAggregatesFilter<"Alquiler"> | number
    tipo_vehiculo?: StringNullableWithAggregatesFilter<"Alquiler"> | string | null
    ubicacion?: StringNullableWithAggregatesFilter<"Alquiler"> | string | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"Alquiler"> | Date | string | null
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"Alquiler"> | Date | string | null
    cantidad?: IntWithAggregatesFilter<"Alquiler"> | number
  }

  export type PaqueteDetalleWhereInput = {
    AND?: PaqueteDetalleWhereInput | PaqueteDetalleWhereInput[]
    OR?: PaqueteDetalleWhereInput[]
    NOT?: PaqueteDetalleWhereInput | PaqueteDetalleWhereInput[]
    id_detalle?: IntFilter<"PaqueteDetalle"> | number
    id_paquete?: IntFilter<"PaqueteDetalle"> | number
    id_producto?: IntFilter<"PaqueteDetalle"> | number
    cantidad?: IntFilter<"PaqueteDetalle"> | number
    paquete?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type PaqueteDetalleOrderByWithRelationInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    paquete?: ProductoOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
  }

  export type PaqueteDetalleWhereUniqueInput = Prisma.AtLeast<{
    id_detalle?: number
    AND?: PaqueteDetalleWhereInput | PaqueteDetalleWhereInput[]
    OR?: PaqueteDetalleWhereInput[]
    NOT?: PaqueteDetalleWhereInput | PaqueteDetalleWhereInput[]
    id_paquete?: IntFilter<"PaqueteDetalle"> | number
    id_producto?: IntFilter<"PaqueteDetalle"> | number
    cantidad?: IntFilter<"PaqueteDetalle"> | number
    paquete?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_detalle">

  export type PaqueteDetalleOrderByWithAggregationInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    _count?: PaqueteDetalleCountOrderByAggregateInput
    _avg?: PaqueteDetalleAvgOrderByAggregateInput
    _max?: PaqueteDetalleMaxOrderByAggregateInput
    _min?: PaqueteDetalleMinOrderByAggregateInput
    _sum?: PaqueteDetalleSumOrderByAggregateInput
  }

  export type PaqueteDetalleScalarWhereWithAggregatesInput = {
    AND?: PaqueteDetalleScalarWhereWithAggregatesInput | PaqueteDetalleScalarWhereWithAggregatesInput[]
    OR?: PaqueteDetalleScalarWhereWithAggregatesInput[]
    NOT?: PaqueteDetalleScalarWhereWithAggregatesInput | PaqueteDetalleScalarWhereWithAggregatesInput[]
    id_detalle?: IntWithAggregatesFilter<"PaqueteDetalle"> | number
    id_paquete?: IntWithAggregatesFilter<"PaqueteDetalle"> | number
    id_producto?: IntWithAggregatesFilter<"PaqueteDetalle"> | number
    cantidad?: IntWithAggregatesFilter<"PaqueteDetalle"> | number
  }

  export type CarritoWhereInput = {
    AND?: CarritoWhereInput | CarritoWhereInput[]
    OR?: CarritoWhereInput[]
    NOT?: CarritoWhereInput | CarritoWhereInput[]
    id_carrito?: IntFilter<"Carrito"> | number
    id_cliente?: IntFilter<"Carrito"> | number
    fecha_creacion?: DateTimeFilter<"Carrito"> | Date | string
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: CarritoItemListRelationFilter
  }

  export type CarritoOrderByWithRelationInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
    fecha_creacion?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    items?: CarritoItemOrderByRelationAggregateInput
  }

  export type CarritoWhereUniqueInput = Prisma.AtLeast<{
    id_carrito?: number
    AND?: CarritoWhereInput | CarritoWhereInput[]
    OR?: CarritoWhereInput[]
    NOT?: CarritoWhereInput | CarritoWhereInput[]
    id_cliente?: IntFilter<"Carrito"> | number
    fecha_creacion?: DateTimeFilter<"Carrito"> | Date | string
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: CarritoItemListRelationFilter
  }, "id_carrito">

  export type CarritoOrderByWithAggregationInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
    fecha_creacion?: SortOrder
    _count?: CarritoCountOrderByAggregateInput
    _avg?: CarritoAvgOrderByAggregateInput
    _max?: CarritoMaxOrderByAggregateInput
    _min?: CarritoMinOrderByAggregateInput
    _sum?: CarritoSumOrderByAggregateInput
  }

  export type CarritoScalarWhereWithAggregatesInput = {
    AND?: CarritoScalarWhereWithAggregatesInput | CarritoScalarWhereWithAggregatesInput[]
    OR?: CarritoScalarWhereWithAggregatesInput[]
    NOT?: CarritoScalarWhereWithAggregatesInput | CarritoScalarWhereWithAggregatesInput[]
    id_carrito?: IntWithAggregatesFilter<"Carrito"> | number
    id_cliente?: IntWithAggregatesFilter<"Carrito"> | number
    fecha_creacion?: DateTimeWithAggregatesFilter<"Carrito"> | Date | string
  }

  export type CarritoItemWhereInput = {
    AND?: CarritoItemWhereInput | CarritoItemWhereInput[]
    OR?: CarritoItemWhereInput[]
    NOT?: CarritoItemWhereInput | CarritoItemWhereInput[]
    id_item?: IntFilter<"CarritoItem"> | number
    id_carrito?: IntFilter<"CarritoItem"> | number
    id_producto?: IntFilter<"CarritoItem"> | number
    cantidad?: IntFilter<"CarritoItem"> | number
    carrito?: XOR<CarritoScalarRelationFilter, CarritoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type CarritoItemOrderByWithRelationInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    carrito?: CarritoOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
  }

  export type CarritoItemWhereUniqueInput = Prisma.AtLeast<{
    id_item?: number
    AND?: CarritoItemWhereInput | CarritoItemWhereInput[]
    OR?: CarritoItemWhereInput[]
    NOT?: CarritoItemWhereInput | CarritoItemWhereInput[]
    id_carrito?: IntFilter<"CarritoItem"> | number
    id_producto?: IntFilter<"CarritoItem"> | number
    cantidad?: IntFilter<"CarritoItem"> | number
    carrito?: XOR<CarritoScalarRelationFilter, CarritoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_item">

  export type CarritoItemOrderByWithAggregationInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    _count?: CarritoItemCountOrderByAggregateInput
    _avg?: CarritoItemAvgOrderByAggregateInput
    _max?: CarritoItemMaxOrderByAggregateInput
    _min?: CarritoItemMinOrderByAggregateInput
    _sum?: CarritoItemSumOrderByAggregateInput
  }

  export type CarritoItemScalarWhereWithAggregatesInput = {
    AND?: CarritoItemScalarWhereWithAggregatesInput | CarritoItemScalarWhereWithAggregatesInput[]
    OR?: CarritoItemScalarWhereWithAggregatesInput[]
    NOT?: CarritoItemScalarWhereWithAggregatesInput | CarritoItemScalarWhereWithAggregatesInput[]
    id_item?: IntWithAggregatesFilter<"CarritoItem"> | number
    id_carrito?: IntWithAggregatesFilter<"CarritoItem"> | number
    id_producto?: IntWithAggregatesFilter<"CarritoItem"> | number
    cantidad?: IntWithAggregatesFilter<"CarritoItem"> | number
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    id_pedido?: IntFilter<"Pedido"> | number
    total?: DecimalFilter<"Pedido"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pedido"> | string
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    id_cliente?: IntFilter<"Pedido"> | number
    pagos?: PagoListRelationFilter
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: PedidoItemListRelationFilter
    ventas?: VentaListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    fecha_pedido?: SortOrder
    id_cliente?: SortOrder
    pagos?: PagoOrderByRelationAggregateInput
    cliente?: ClienteOrderByWithRelationInput
    items?: PedidoItemOrderByRelationAggregateInput
    ventas?: VentaOrderByRelationAggregateInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    id_pedido?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    total?: DecimalFilter<"Pedido"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pedido"> | string
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    id_cliente?: IntFilter<"Pedido"> | number
    pagos?: PagoListRelationFilter
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: PedidoItemListRelationFilter
    ventas?: VentaListRelationFilter
  }, "id_pedido">

  export type PedidoOrderByWithAggregationInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    fecha_pedido?: SortOrder
    id_cliente?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    id_pedido?: IntWithAggregatesFilter<"Pedido"> | number
    total?: DecimalWithAggregatesFilter<"Pedido"> | Decimal | DecimalJsLike | number | string
    estado?: StringWithAggregatesFilter<"Pedido"> | string
    fecha_pedido?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    id_cliente?: IntWithAggregatesFilter<"Pedido"> | number
  }

  export type PedidoItemWhereInput = {
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    id_detalle?: IntFilter<"PedidoItem"> | number
    id_pedido?: IntFilter<"PedidoItem"> | number
    id_producto?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    precio?: DecimalFilter<"PedidoItem"> | Decimal | DecimalJsLike | number | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type PedidoItemOrderByWithRelationInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
  }

  export type PedidoItemWhereUniqueInput = Prisma.AtLeast<{
    id_detalle?: number
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    id_pedido?: IntFilter<"PedidoItem"> | number
    id_producto?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    precio?: DecimalFilter<"PedidoItem"> | Decimal | DecimalJsLike | number | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_detalle">

  export type PedidoItemOrderByWithAggregationInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    _count?: PedidoItemCountOrderByAggregateInput
    _avg?: PedidoItemAvgOrderByAggregateInput
    _max?: PedidoItemMaxOrderByAggregateInput
    _min?: PedidoItemMinOrderByAggregateInput
    _sum?: PedidoItemSumOrderByAggregateInput
  }

  export type PedidoItemScalarWhereWithAggregatesInput = {
    AND?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    OR?: PedidoItemScalarWhereWithAggregatesInput[]
    NOT?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    id_detalle?: IntWithAggregatesFilter<"PedidoItem"> | number
    id_pedido?: IntWithAggregatesFilter<"PedidoItem"> | number
    id_producto?: IntWithAggregatesFilter<"PedidoItem"> | number
    cantidad?: IntWithAggregatesFilter<"PedidoItem"> | number
    precio?: DecimalWithAggregatesFilter<"PedidoItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PagoWhereInput = {
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    id_pago?: IntFilter<"Pago"> | number
    id_pedido?: IntFilter<"Pago"> | number
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    metodo?: StringNullableFilter<"Pago"> | string | null
    estado?: StringFilter<"Pago"> | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }

  export type PagoOrderByWithRelationInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    metodo?: SortOrderInput | SortOrder
    estado?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
  }

  export type PagoWhereUniqueInput = Prisma.AtLeast<{
    id_pago?: number
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    id_pedido?: IntFilter<"Pago"> | number
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    metodo?: StringNullableFilter<"Pago"> | string | null
    estado?: StringFilter<"Pago"> | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }, "id_pago">

  export type PagoOrderByWithAggregationInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    metodo?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: PagoCountOrderByAggregateInput
    _avg?: PagoAvgOrderByAggregateInput
    _max?: PagoMaxOrderByAggregateInput
    _min?: PagoMinOrderByAggregateInput
    _sum?: PagoSumOrderByAggregateInput
  }

  export type PagoScalarWhereWithAggregatesInput = {
    AND?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    OR?: PagoScalarWhereWithAggregatesInput[]
    NOT?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    id_pago?: IntWithAggregatesFilter<"Pago"> | number
    id_pedido?: IntWithAggregatesFilter<"Pago"> | number
    fecha_pago?: DateTimeWithAggregatesFilter<"Pago"> | Date | string
    monto?: DecimalWithAggregatesFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    metodo?: StringNullableWithAggregatesFilter<"Pago"> | string | null
    estado?: StringWithAggregatesFilter<"Pago"> | string
  }

  export type ContactoInternoWhereInput = {
    AND?: ContactoInternoWhereInput | ContactoInternoWhereInput[]
    OR?: ContactoInternoWhereInput[]
    NOT?: ContactoInternoWhereInput | ContactoInternoWhereInput[]
    id_contacto?: IntFilter<"ContactoInterno"> | number
    nombre?: StringFilter<"ContactoInterno"> | string
    email?: StringFilter<"ContactoInterno"> | string
    telefono?: StringNullableFilter<"ContactoInterno"> | string | null
    cargo?: StringNullableFilter<"ContactoInterno"> | string | null
  }

  export type ContactoInternoOrderByWithRelationInput = {
    id_contacto?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
  }

  export type ContactoInternoWhereUniqueInput = Prisma.AtLeast<{
    id_contacto?: number
    AND?: ContactoInternoWhereInput | ContactoInternoWhereInput[]
    OR?: ContactoInternoWhereInput[]
    NOT?: ContactoInternoWhereInput | ContactoInternoWhereInput[]
    nombre?: StringFilter<"ContactoInterno"> | string
    email?: StringFilter<"ContactoInterno"> | string
    telefono?: StringNullableFilter<"ContactoInterno"> | string | null
    cargo?: StringNullableFilter<"ContactoInterno"> | string | null
  }, "id_contacto">

  export type ContactoInternoOrderByWithAggregationInput = {
    id_contacto?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    _count?: ContactoInternoCountOrderByAggregateInput
    _avg?: ContactoInternoAvgOrderByAggregateInput
    _max?: ContactoInternoMaxOrderByAggregateInput
    _min?: ContactoInternoMinOrderByAggregateInput
    _sum?: ContactoInternoSumOrderByAggregateInput
  }

  export type ContactoInternoScalarWhereWithAggregatesInput = {
    AND?: ContactoInternoScalarWhereWithAggregatesInput | ContactoInternoScalarWhereWithAggregatesInput[]
    OR?: ContactoInternoScalarWhereWithAggregatesInput[]
    NOT?: ContactoInternoScalarWhereWithAggregatesInput | ContactoInternoScalarWhereWithAggregatesInput[]
    id_contacto?: IntWithAggregatesFilter<"ContactoInterno"> | number
    nombre?: StringWithAggregatesFilter<"ContactoInterno"> | string
    email?: StringWithAggregatesFilter<"ContactoInterno"> | string
    telefono?: StringNullableWithAggregatesFilter<"ContactoInterno"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"ContactoInterno"> | string | null
  }

  export type AutoWhereInput = {
    AND?: AutoWhereInput | AutoWhereInput[]
    OR?: AutoWhereInput[]
    NOT?: AutoWhereInput | AutoWhereInput[]
    id_auto?: IntFilter<"Auto"> | number
    id_producto?: IntFilter<"Auto"> | number
    modelo?: StringNullableFilter<"Auto"> | string | null
    marca?: StringNullableFilter<"Auto"> | string | null
    capacidad?: IntNullableFilter<"Auto"> | number | null
    ubicacion_actual?: StringNullableFilter<"Auto"> | string | null
    estado?: StringFilter<"Auto"> | string
    Producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type AutoOrderByWithRelationInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    modelo?: SortOrderInput | SortOrder
    marca?: SortOrderInput | SortOrder
    capacidad?: SortOrderInput | SortOrder
    ubicacion_actual?: SortOrderInput | SortOrder
    estado?: SortOrder
    Producto?: ProductoOrderByWithRelationInput
  }

  export type AutoWhereUniqueInput = Prisma.AtLeast<{
    id_auto?: number
    id_producto?: number
    AND?: AutoWhereInput | AutoWhereInput[]
    OR?: AutoWhereInput[]
    NOT?: AutoWhereInput | AutoWhereInput[]
    modelo?: StringNullableFilter<"Auto"> | string | null
    marca?: StringNullableFilter<"Auto"> | string | null
    capacidad?: IntNullableFilter<"Auto"> | number | null
    ubicacion_actual?: StringNullableFilter<"Auto"> | string | null
    estado?: StringFilter<"Auto"> | string
    Producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id_auto" | "id_producto">

  export type AutoOrderByWithAggregationInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    modelo?: SortOrderInput | SortOrder
    marca?: SortOrderInput | SortOrder
    capacidad?: SortOrderInput | SortOrder
    ubicacion_actual?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: AutoCountOrderByAggregateInput
    _avg?: AutoAvgOrderByAggregateInput
    _max?: AutoMaxOrderByAggregateInput
    _min?: AutoMinOrderByAggregateInput
    _sum?: AutoSumOrderByAggregateInput
  }

  export type AutoScalarWhereWithAggregatesInput = {
    AND?: AutoScalarWhereWithAggregatesInput | AutoScalarWhereWithAggregatesInput[]
    OR?: AutoScalarWhereWithAggregatesInput[]
    NOT?: AutoScalarWhereWithAggregatesInput | AutoScalarWhereWithAggregatesInput[]
    id_auto?: IntWithAggregatesFilter<"Auto"> | number
    id_producto?: IntWithAggregatesFilter<"Auto"> | number
    modelo?: StringNullableWithAggregatesFilter<"Auto"> | string | null
    marca?: StringNullableWithAggregatesFilter<"Auto"> | string | null
    capacidad?: IntNullableWithAggregatesFilter<"Auto"> | number | null
    ubicacion_actual?: StringNullableWithAggregatesFilter<"Auto"> | string | null
    estado?: StringWithAggregatesFilter<"Auto"> | string
  }

  export type VentaWhereInput = {
    AND?: VentaWhereInput | VentaWhereInput[]
    OR?: VentaWhereInput[]
    NOT?: VentaWhereInput | VentaWhereInput[]
    id?: IntFilter<"Venta"> | number
    pedidoId?: IntFilter<"Venta"> | number
    monto?: FloatFilter<"Venta"> | number
    fecha?: DateTimeFilter<"Venta"> | Date | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }

  export type VentaOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
  }

  export type VentaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VentaWhereInput | VentaWhereInput[]
    OR?: VentaWhereInput[]
    NOT?: VentaWhereInput | VentaWhereInput[]
    pedidoId?: IntFilter<"Venta"> | number
    monto?: FloatFilter<"Venta"> | number
    fecha?: DateTimeFilter<"Venta"> | Date | string
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }, "id">

  export type VentaOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    _count?: VentaCountOrderByAggregateInput
    _avg?: VentaAvgOrderByAggregateInput
    _max?: VentaMaxOrderByAggregateInput
    _min?: VentaMinOrderByAggregateInput
    _sum?: VentaSumOrderByAggregateInput
  }

  export type VentaScalarWhereWithAggregatesInput = {
    AND?: VentaScalarWhereWithAggregatesInput | VentaScalarWhereWithAggregatesInput[]
    OR?: VentaScalarWhereWithAggregatesInput[]
    NOT?: VentaScalarWhereWithAggregatesInput | VentaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Venta"> | number
    pedidoId?: IntWithAggregatesFilter<"Venta"> | number
    monto?: FloatWithAggregatesFilter<"Venta"> | number
    fecha?: DateTimeWithAggregatesFilter<"Venta"> | Date | string
  }

  export type ClienteCreateInput = {
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    carritos?: CarritoCreateNestedManyWithoutClienteInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id_cliente?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    carritos?: CarritoUncheckedCreateNestedManyWithoutClienteInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    carritos?: CarritoUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    carritos?: CarritoUncheckedUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id_cliente?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
  }

  export type ClienteUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClienteUncheckedUpdateManyInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolCreateInput = {
    nombre: string
    descripcion?: string | null
    usuarios?: UsuarioInternoCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateInput = {
    id_rol?: number
    nombre: string
    descripcion?: string | null
    usuarios?: UsuarioInternoUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioInternoUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioInternoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateManyInput = {
    id_rol?: number
    nombre: string
    descripcion?: string | null
  }

  export type RolUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolUncheckedUpdateManyInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioInternoCreateInput = {
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
    rol: RolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioInternoUncheckedCreateInput = {
    id_usuario?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
    id_rol: number
  }

  export type UsuarioInternoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioInternoUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_rol?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioInternoCreateManyInput = {
    id_usuario?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
    id_rol: number
  }

  export type UsuarioInternoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioInternoUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_rol?: IntFieldUpdateOperationsInput | number
  }

  export type TipoProductoCreateInput = {
    nombre: string
    descripcion?: string | null
    productos?: ProductoCreateNestedManyWithoutTipoProductoInput
  }

  export type TipoProductoUncheckedCreateInput = {
    id_tipo?: number
    nombre: string
    descripcion?: string | null
    productos?: ProductoUncheckedCreateNestedManyWithoutTipoProductoInput
  }

  export type TipoProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    productos?: ProductoUpdateManyWithoutTipoProductoNestedInput
  }

  export type TipoProductoUncheckedUpdateInput = {
    id_tipo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    productos?: ProductoUncheckedUpdateManyWithoutTipoProductoNestedInput
  }

  export type TipoProductoCreateManyInput = {
    id_tipo?: number
    nombre: string
    descripcion?: string | null
  }

  export type TipoProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TipoProductoUncheckedUpdateManyInput = {
    id_tipo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductoCreateInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateManyInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
  }

  export type ProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HospedajeCreateInput = {
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    capacidad?: number | null
    producto: ProductoCreateNestedOneWithoutHospedajeInput
  }

  export type HospedajeUncheckedCreateInput = {
    id_hospedaje?: number
    id_producto: number
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    capacidad?: number | null
  }

  export type HospedajeUpdateInput = {
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    producto?: ProductoUpdateOneRequiredWithoutHospedajeNestedInput
  }

  export type HospedajeUncheckedUpdateInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HospedajeCreateManyInput = {
    id_hospedaje?: number
    id_producto: number
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    capacidad?: number | null
  }

  export type HospedajeUpdateManyMutationInput = {
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HospedajeUncheckedUpdateManyInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PasajeCreateInput = {
    origen?: string | null
    destino?: string | null
    fecha_salida?: Date | string | null
    fecha_regreso?: Date | string | null
    clase?: string | null
    asientos_disponibles?: number
    aerolinea?: string | null
    producto: ProductoCreateNestedOneWithoutPasajeInput
  }

  export type PasajeUncheckedCreateInput = {
    id_pasaje?: number
    id_producto: number
    origen?: string | null
    destino?: string | null
    fecha_salida?: Date | string | null
    fecha_regreso?: Date | string | null
    clase?: string | null
    asientos_disponibles?: number
    aerolinea?: string | null
  }

  export type PasajeUpdateInput = {
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
    producto?: ProductoUpdateOneRequiredWithoutPasajeNestedInput
  }

  export type PasajeUncheckedUpdateInput = {
    id_pasaje?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasajeCreateManyInput = {
    id_pasaje?: number
    id_producto: number
    origen?: string | null
    destino?: string | null
    fecha_salida?: Date | string | null
    fecha_regreso?: Date | string | null
    clase?: string | null
    asientos_disponibles?: number
    aerolinea?: string | null
  }

  export type PasajeUpdateManyMutationInput = {
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasajeUncheckedUpdateManyInput = {
    id_pasaje?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlquilerCreateInput = {
    tipo_vehiculo?: string | null
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    cantidad?: number
    producto: ProductoCreateNestedOneWithoutAlquilerInput
  }

  export type AlquilerUncheckedCreateInput = {
    id_alquiler?: number
    id_producto: number
    tipo_vehiculo?: string | null
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    cantidad?: number
  }

  export type AlquilerUpdateInput = {
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutAlquilerNestedInput
  }

  export type AlquilerUncheckedUpdateInput = {
    id_alquiler?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type AlquilerCreateManyInput = {
    id_alquiler?: number
    id_producto: number
    tipo_vehiculo?: string | null
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    cantidad?: number
  }

  export type AlquilerUpdateManyMutationInput = {
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type AlquilerUncheckedUpdateManyInput = {
    id_alquiler?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleCreateInput = {
    cantidad?: number
    paquete: ProductoCreateNestedOneWithoutPaqueteDetallesAsPaqueteInput
    producto: ProductoCreateNestedOneWithoutPaqueteDetallesAsProductoInput
  }

  export type PaqueteDetalleUncheckedCreateInput = {
    id_detalle?: number
    id_paquete: number
    id_producto: number
    cantidad?: number
  }

  export type PaqueteDetalleUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    paquete?: ProductoUpdateOneRequiredWithoutPaqueteDetallesAsPaqueteNestedInput
    producto?: ProductoUpdateOneRequiredWithoutPaqueteDetallesAsProductoNestedInput
  }

  export type PaqueteDetalleUncheckedUpdateInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleCreateManyInput = {
    id_detalle?: number
    id_paquete: number
    id_producto: number
    cantidad?: number
  }

  export type PaqueteDetalleUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleUncheckedUpdateManyInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoCreateInput = {
    fecha_creacion?: Date | string
    cliente: ClienteCreateNestedOneWithoutCarritosInput
    items?: CarritoItemCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUncheckedCreateInput = {
    id_carrito?: number
    id_cliente: number
    fecha_creacion?: Date | string
    items?: CarritoItemUncheckedCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUpdateInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutCarritosNestedInput
    items?: CarritoItemUpdateManyWithoutCarritoNestedInput
  }

  export type CarritoUncheckedUpdateInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CarritoItemUncheckedUpdateManyWithoutCarritoNestedInput
  }

  export type CarritoCreateManyInput = {
    id_carrito?: number
    id_cliente: number
    fecha_creacion?: Date | string
  }

  export type CarritoUpdateManyMutationInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarritoUncheckedUpdateManyInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarritoItemCreateInput = {
    cantidad?: number
    carrito: CarritoCreateNestedOneWithoutItemsInput
    producto: ProductoCreateNestedOneWithoutCarritoItemsInput
  }

  export type CarritoItemUncheckedCreateInput = {
    id_item?: number
    id_carrito: number
    id_producto: number
    cantidad?: number
  }

  export type CarritoItemUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    carrito?: CarritoUpdateOneRequiredWithoutItemsNestedInput
    producto?: ProductoUpdateOneRequiredWithoutCarritoItemsNestedInput
  }

  export type CarritoItemUncheckedUpdateInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemCreateManyInput = {
    id_item?: number
    id_carrito: number
    id_producto: number
    cantidad?: number
  }

  export type CarritoItemUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemUncheckedUpdateManyInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateInput = {
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    pagos?: PagoCreateNestedManyWithoutPedidoInput
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    ventas?: VentaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    id_cliente: number
    pagos?: PagoUncheckedCreateNestedManyWithoutPedidoInput
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ventas?: VentaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUpdateManyWithoutPedidoNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    pagos?: PagoUncheckedUpdateManyWithoutPedidoNestedInput
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    id_cliente: number
  }

  export type PedidoUpdateManyMutationInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoItemCreateInput = {
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    pedido: PedidoCreateNestedOneWithoutItemsInput
    producto: ProductoCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateInput = {
    id_detalle?: number
    id_pedido: number
    id_producto: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pedido?: PedidoUpdateOneRequiredWithoutItemsNestedInput
    producto?: ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemCreateManyInput = {
    id_detalle?: number
    id_pedido: number
    id_producto: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemUncheckedUpdateManyInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PagoCreateInput = {
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
    pedido: PedidoCreateNestedOneWithoutPagosInput
  }

  export type PagoUncheckedCreateInput = {
    id_pago?: number
    id_pedido: number
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
  }

  export type PagoUpdateInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    pedido?: PedidoUpdateOneRequiredWithoutPagosNestedInput
  }

  export type PagoUncheckedUpdateInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type PagoCreateManyInput = {
    id_pago?: number
    id_pedido: number
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
  }

  export type PagoUpdateManyMutationInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type PagoUncheckedUpdateManyInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ContactoInternoCreateInput = {
    nombre: string
    email: string
    telefono?: string | null
    cargo?: string | null
  }

  export type ContactoInternoUncheckedCreateInput = {
    id_contacto?: number
    nombre: string
    email: string
    telefono?: string | null
    cargo?: string | null
  }

  export type ContactoInternoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactoInternoUncheckedUpdateInput = {
    id_contacto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactoInternoCreateManyInput = {
    id_contacto?: number
    nombre: string
    email: string
    telefono?: string | null
    cargo?: string | null
  }

  export type ContactoInternoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactoInternoUncheckedUpdateManyInput = {
    id_contacto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutoCreateInput = {
    modelo?: string | null
    marca?: string | null
    capacidad?: number | null
    ubicacion_actual?: string | null
    estado: string
    Producto: ProductoCreateNestedOneWithoutAutoInput
  }

  export type AutoUncheckedCreateInput = {
    id_auto?: number
    id_producto: number
    modelo?: string | null
    marca?: string | null
    capacidad?: number | null
    ubicacion_actual?: string | null
    estado: string
  }

  export type AutoUpdateInput = {
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    Producto?: ProductoUpdateOneRequiredWithoutAutoNestedInput
  }

  export type AutoUncheckedUpdateInput = {
    id_auto?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AutoCreateManyInput = {
    id_auto?: number
    id_producto: number
    modelo?: string | null
    marca?: string | null
    capacidad?: number | null
    ubicacion_actual?: string | null
    estado: string
  }

  export type AutoUpdateManyMutationInput = {
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AutoUncheckedUpdateManyInput = {
    id_auto?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type VentaCreateInput = {
    monto: number
    fecha: Date | string
    pedido: PedidoCreateNestedOneWithoutVentasInput
  }

  export type VentaUncheckedCreateInput = {
    id?: number
    pedidoId: number
    monto: number
    fecha: Date | string
  }

  export type VentaUpdateInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutVentasNestedInput
  }

  export type VentaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentaCreateManyInput = {
    id?: number
    pedidoId: number
    monto: number
    fecha: Date | string
  }

  export type VentaUpdateManyMutationInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CarritoListRelationFilter = {
    every?: CarritoWhereInput
    some?: CarritoWhereInput
    none?: CarritoWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CarritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fecha_registro?: SortOrder
    activo?: SortOrder
    email_verificado?: SortOrder
    token_verificacion_email?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id_cliente?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fecha_registro?: SortOrder
    activo?: SortOrder
    email_verificado?: SortOrder
    token_verificacion_email?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fecha_registro?: SortOrder
    activo?: SortOrder
    email_verificado?: SortOrder
    token_verificacion_email?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id_cliente?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsuarioInternoListRelationFilter = {
    every?: UsuarioInternoWhereInput
    some?: UsuarioInternoWhereInput
    none?: UsuarioInternoWhereInput
  }

  export type UsuarioInternoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolAvgOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolSumOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type RolScalarRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type UsuarioInternoCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    activo?: SortOrder
    id_rol?: SortOrder
  }

  export type UsuarioInternoAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type UsuarioInternoMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    activo?: SortOrder
    id_rol?: SortOrder
  }

  export type UsuarioInternoMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    activo?: SortOrder
    id_rol?: SortOrder
  }

  export type UsuarioInternoSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoProductoCountOrderByAggregateInput = {
    id_tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoProductoAvgOrderByAggregateInput = {
    id_tipo?: SortOrder
  }

  export type TipoProductoMaxOrderByAggregateInput = {
    id_tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoProductoMinOrderByAggregateInput = {
    id_tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoProductoSumOrderByAggregateInput = {
    id_tipo?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AlquilerNullableScalarRelationFilter = {
    is?: AlquilerWhereInput | null
    isNot?: AlquilerWhereInput | null
  }

  export type AutoNullableScalarRelationFilter = {
    is?: AutoWhereInput | null
    isNot?: AutoWhereInput | null
  }

  export type CarritoItemListRelationFilter = {
    every?: CarritoItemWhereInput
    some?: CarritoItemWhereInput
    none?: CarritoItemWhereInput
  }

  export type HospedajeNullableScalarRelationFilter = {
    is?: HospedajeWhereInput | null
    isNot?: HospedajeWhereInput | null
  }

  export type PaqueteDetalleListRelationFilter = {
    every?: PaqueteDetalleWhereInput
    some?: PaqueteDetalleWhereInput
    none?: PaqueteDetalleWhereInput
  }

  export type PasajeNullableScalarRelationFilter = {
    is?: PasajeWhereInput | null
    isNot?: PasajeWhereInput | null
  }

  export type PedidoItemListRelationFilter = {
    every?: PedidoItemWhereInput
    some?: PedidoItemWhereInput
    none?: PedidoItemWhereInput
  }

  export type TipoProductoNullableScalarRelationFilter = {
    is?: TipoProductoWhereInput | null
    isNot?: TipoProductoWhereInput | null
  }

  export type CarritoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaqueteDetalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    activo?: SortOrder
    id_tipo?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id_producto?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    id_tipo?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    activo?: SortOrder
    id_tipo?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    activo?: SortOrder
    id_tipo?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id_producto?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    id_tipo?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProductoScalarRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type HospedajeCountOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    capacidad?: SortOrder
  }

  export type HospedajeAvgOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    capacidad?: SortOrder
  }

  export type HospedajeMaxOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    capacidad?: SortOrder
  }

  export type HospedajeMinOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    capacidad?: SortOrder
  }

  export type HospedajeSumOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_producto?: SortOrder
    capacidad?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PasajeCountOrderByAggregateInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fecha_salida?: SortOrder
    fecha_regreso?: SortOrder
    clase?: SortOrder
    asientos_disponibles?: SortOrder
    aerolinea?: SortOrder
  }

  export type PasajeAvgOrderByAggregateInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    asientos_disponibles?: SortOrder
  }

  export type PasajeMaxOrderByAggregateInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fecha_salida?: SortOrder
    fecha_regreso?: SortOrder
    clase?: SortOrder
    asientos_disponibles?: SortOrder
    aerolinea?: SortOrder
  }

  export type PasajeMinOrderByAggregateInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fecha_salida?: SortOrder
    fecha_regreso?: SortOrder
    clase?: SortOrder
    asientos_disponibles?: SortOrder
    aerolinea?: SortOrder
  }

  export type PasajeSumOrderByAggregateInput = {
    id_pasaje?: SortOrder
    id_producto?: SortOrder
    asientos_disponibles?: SortOrder
  }

  export type AlquilerCountOrderByAggregateInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    tipo_vehiculo?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    cantidad?: SortOrder
  }

  export type AlquilerAvgOrderByAggregateInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type AlquilerMaxOrderByAggregateInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    tipo_vehiculo?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    cantidad?: SortOrder
  }

  export type AlquilerMinOrderByAggregateInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    tipo_vehiculo?: SortOrder
    ubicacion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    cantidad?: SortOrder
  }

  export type AlquilerSumOrderByAggregateInput = {
    id_alquiler?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type PaqueteDetalleCountOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type PaqueteDetalleAvgOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type PaqueteDetalleMaxOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type PaqueteDetalleMinOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type PaqueteDetalleSumOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_paquete?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type ClienteScalarRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type CarritoCountOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type CarritoAvgOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
  }

  export type CarritoMaxOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type CarritoMinOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type CarritoSumOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_cliente?: SortOrder
  }

  export type CarritoScalarRelationFilter = {
    is?: CarritoWhereInput
    isNot?: CarritoWhereInput
  }

  export type CarritoItemCountOrderByAggregateInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemAvgOrderByAggregateInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemMaxOrderByAggregateInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemMinOrderByAggregateInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemSumOrderByAggregateInput = {
    id_item?: SortOrder
    id_carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PagoListRelationFilter = {
    every?: PagoWhereInput
    some?: PagoWhereInput
    none?: PagoWhereInput
  }

  export type VentaListRelationFilter = {
    every?: VentaWhereInput
    some?: VentaWhereInput
    none?: VentaWhereInput
  }

  export type PagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    fecha_pedido?: SortOrder
    id_cliente?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    id_cliente?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    fecha_pedido?: SortOrder
    id_cliente?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    fecha_pedido?: SortOrder
    id_cliente?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id_pedido?: SortOrder
    total?: SortOrder
    id_cliente?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PedidoScalarRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type PedidoItemCountOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
  }

  export type PedidoItemAvgOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
  }

  export type PedidoItemMaxOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
  }

  export type PedidoItemMinOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
  }

  export type PedidoItemSumOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_pedido?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
  }

  export type PagoCountOrderByAggregateInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    metodo?: SortOrder
    estado?: SortOrder
  }

  export type PagoAvgOrderByAggregateInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    monto?: SortOrder
  }

  export type PagoMaxOrderByAggregateInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    metodo?: SortOrder
    estado?: SortOrder
  }

  export type PagoMinOrderByAggregateInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    metodo?: SortOrder
    estado?: SortOrder
  }

  export type PagoSumOrderByAggregateInput = {
    id_pago?: SortOrder
    id_pedido?: SortOrder
    monto?: SortOrder
  }

  export type ContactoInternoCountOrderByAggregateInput = {
    id_contacto?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
  }

  export type ContactoInternoAvgOrderByAggregateInput = {
    id_contacto?: SortOrder
  }

  export type ContactoInternoMaxOrderByAggregateInput = {
    id_contacto?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
  }

  export type ContactoInternoMinOrderByAggregateInput = {
    id_contacto?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
  }

  export type ContactoInternoSumOrderByAggregateInput = {
    id_contacto?: SortOrder
  }

  export type AutoCountOrderByAggregateInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    modelo?: SortOrder
    marca?: SortOrder
    capacidad?: SortOrder
    ubicacion_actual?: SortOrder
    estado?: SortOrder
  }

  export type AutoAvgOrderByAggregateInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    capacidad?: SortOrder
  }

  export type AutoMaxOrderByAggregateInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    modelo?: SortOrder
    marca?: SortOrder
    capacidad?: SortOrder
    ubicacion_actual?: SortOrder
    estado?: SortOrder
  }

  export type AutoMinOrderByAggregateInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    modelo?: SortOrder
    marca?: SortOrder
    capacidad?: SortOrder
    ubicacion_actual?: SortOrder
    estado?: SortOrder
  }

  export type AutoSumOrderByAggregateInput = {
    id_auto?: SortOrder
    id_producto?: SortOrder
    capacidad?: SortOrder
  }

  export type VentaCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
  }

  export type VentaAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
  }

  export type VentaMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
  }

  export type VentaMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
  }

  export type VentaSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    monto?: SortOrder
  }

  export type CarritoCreateNestedManyWithoutClienteInput = {
    create?: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput> | CarritoCreateWithoutClienteInput[] | CarritoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CarritoCreateOrConnectWithoutClienteInput | CarritoCreateOrConnectWithoutClienteInput[]
    createMany?: CarritoCreateManyClienteInputEnvelope
    connect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
  }

  export type PedidoCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type CarritoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput> | CarritoCreateWithoutClienteInput[] | CarritoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CarritoCreateOrConnectWithoutClienteInput | CarritoCreateOrConnectWithoutClienteInput[]
    createMany?: CarritoCreateManyClienteInputEnvelope
    connect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CarritoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput> | CarritoCreateWithoutClienteInput[] | CarritoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CarritoCreateOrConnectWithoutClienteInput | CarritoCreateOrConnectWithoutClienteInput[]
    upsert?: CarritoUpsertWithWhereUniqueWithoutClienteInput | CarritoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: CarritoCreateManyClienteInputEnvelope
    set?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    disconnect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    delete?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    connect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    update?: CarritoUpdateWithWhereUniqueWithoutClienteInput | CarritoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: CarritoUpdateManyWithWhereWithoutClienteInput | CarritoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: CarritoScalarWhereInput | CarritoScalarWhereInput[]
  }

  export type PedidoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CarritoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput> | CarritoCreateWithoutClienteInput[] | CarritoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CarritoCreateOrConnectWithoutClienteInput | CarritoCreateOrConnectWithoutClienteInput[]
    upsert?: CarritoUpsertWithWhereUniqueWithoutClienteInput | CarritoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: CarritoCreateManyClienteInputEnvelope
    set?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    disconnect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    delete?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    connect?: CarritoWhereUniqueInput | CarritoWhereUniqueInput[]
    update?: CarritoUpdateWithWhereUniqueWithoutClienteInput | CarritoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: CarritoUpdateManyWithWhereWithoutClienteInput | CarritoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: CarritoScalarWhereInput | CarritoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type UsuarioInternoCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput> | UsuarioInternoCreateWithoutRolInput[] | UsuarioInternoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioInternoCreateOrConnectWithoutRolInput | UsuarioInternoCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioInternoCreateManyRolInputEnvelope
    connect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
  }

  export type UsuarioInternoUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput> | UsuarioInternoCreateWithoutRolInput[] | UsuarioInternoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioInternoCreateOrConnectWithoutRolInput | UsuarioInternoCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioInternoCreateManyRolInputEnvelope
    connect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
  }

  export type UsuarioInternoUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput> | UsuarioInternoCreateWithoutRolInput[] | UsuarioInternoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioInternoCreateOrConnectWithoutRolInput | UsuarioInternoCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioInternoUpsertWithWhereUniqueWithoutRolInput | UsuarioInternoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioInternoCreateManyRolInputEnvelope
    set?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    disconnect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    delete?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    connect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    update?: UsuarioInternoUpdateWithWhereUniqueWithoutRolInput | UsuarioInternoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioInternoUpdateManyWithWhereWithoutRolInput | UsuarioInternoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioInternoScalarWhereInput | UsuarioInternoScalarWhereInput[]
  }

  export type UsuarioInternoUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput> | UsuarioInternoCreateWithoutRolInput[] | UsuarioInternoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioInternoCreateOrConnectWithoutRolInput | UsuarioInternoCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioInternoUpsertWithWhereUniqueWithoutRolInput | UsuarioInternoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioInternoCreateManyRolInputEnvelope
    set?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    disconnect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    delete?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    connect?: UsuarioInternoWhereUniqueInput | UsuarioInternoWhereUniqueInput[]
    update?: UsuarioInternoUpdateWithWhereUniqueWithoutRolInput | UsuarioInternoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioInternoUpdateManyWithWhereWithoutRolInput | UsuarioInternoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioInternoScalarWhereInput | UsuarioInternoScalarWhereInput[]
  }

  export type RolCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    connect?: RolWhereUniqueInput
  }

  export type RolUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    upsert?: RolUpsertWithoutUsuariosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutUsuariosInput, RolUpdateWithoutUsuariosInput>, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type ProductoCreateNestedManyWithoutTipoProductoInput = {
    create?: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput> | ProductoCreateWithoutTipoProductoInput[] | ProductoUncheckedCreateWithoutTipoProductoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutTipoProductoInput | ProductoCreateOrConnectWithoutTipoProductoInput[]
    createMany?: ProductoCreateManyTipoProductoInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutTipoProductoInput = {
    create?: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput> | ProductoCreateWithoutTipoProductoInput[] | ProductoUncheckedCreateWithoutTipoProductoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutTipoProductoInput | ProductoCreateOrConnectWithoutTipoProductoInput[]
    createMany?: ProductoCreateManyTipoProductoInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type ProductoUpdateManyWithoutTipoProductoNestedInput = {
    create?: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput> | ProductoCreateWithoutTipoProductoInput[] | ProductoUncheckedCreateWithoutTipoProductoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutTipoProductoInput | ProductoCreateOrConnectWithoutTipoProductoInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutTipoProductoInput | ProductoUpsertWithWhereUniqueWithoutTipoProductoInput[]
    createMany?: ProductoCreateManyTipoProductoInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutTipoProductoInput | ProductoUpdateWithWhereUniqueWithoutTipoProductoInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutTipoProductoInput | ProductoUpdateManyWithWhereWithoutTipoProductoInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutTipoProductoNestedInput = {
    create?: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput> | ProductoCreateWithoutTipoProductoInput[] | ProductoUncheckedCreateWithoutTipoProductoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutTipoProductoInput | ProductoCreateOrConnectWithoutTipoProductoInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutTipoProductoInput | ProductoUpsertWithWhereUniqueWithoutTipoProductoInput[]
    createMany?: ProductoCreateManyTipoProductoInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutTipoProductoInput | ProductoUpdateWithWhereUniqueWithoutTipoProductoInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutTipoProductoInput | ProductoUpdateManyWithWhereWithoutTipoProductoInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type AlquilerCreateNestedOneWithoutProductoInput = {
    create?: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AlquilerCreateOrConnectWithoutProductoInput
    connect?: AlquilerWhereUniqueInput
  }

  export type AutoCreateNestedOneWithoutProductoInput = {
    create?: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AutoCreateOrConnectWithoutProductoInput
    connect?: AutoWhereUniqueInput
  }

  export type CarritoItemCreateNestedManyWithoutProductoInput = {
    create?: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput> | CarritoItemCreateWithoutProductoInput[] | CarritoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutProductoInput | CarritoItemCreateOrConnectWithoutProductoInput[]
    createMany?: CarritoItemCreateManyProductoInputEnvelope
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
  }

  export type HospedajeCreateNestedOneWithoutProductoInput = {
    create?: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: HospedajeCreateOrConnectWithoutProductoInput
    connect?: HospedajeWhereUniqueInput
  }

  export type PaqueteDetalleCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput> | PaqueteDetalleCreateWithoutPaqueteInput[] | PaqueteDetalleUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutPaqueteInput | PaqueteDetalleCreateOrConnectWithoutPaqueteInput[]
    createMany?: PaqueteDetalleCreateManyPaqueteInputEnvelope
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
  }

  export type PaqueteDetalleCreateNestedManyWithoutProductoInput = {
    create?: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput> | PaqueteDetalleCreateWithoutProductoInput[] | PaqueteDetalleUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutProductoInput | PaqueteDetalleCreateOrConnectWithoutProductoInput[]
    createMany?: PaqueteDetalleCreateManyProductoInputEnvelope
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
  }

  export type PasajeCreateNestedOneWithoutProductoInput = {
    create?: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: PasajeCreateOrConnectWithoutProductoInput
    connect?: PasajeWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutProductoInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type TipoProductoCreateNestedOneWithoutProductosInput = {
    create?: XOR<TipoProductoCreateWithoutProductosInput, TipoProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: TipoProductoCreateOrConnectWithoutProductosInput
    connect?: TipoProductoWhereUniqueInput
  }

  export type AlquilerUncheckedCreateNestedOneWithoutProductoInput = {
    create?: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AlquilerCreateOrConnectWithoutProductoInput
    connect?: AlquilerWhereUniqueInput
  }

  export type AutoUncheckedCreateNestedOneWithoutProductoInput = {
    create?: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AutoCreateOrConnectWithoutProductoInput
    connect?: AutoWhereUniqueInput
  }

  export type CarritoItemUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput> | CarritoItemCreateWithoutProductoInput[] | CarritoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutProductoInput | CarritoItemCreateOrConnectWithoutProductoInput[]
    createMany?: CarritoItemCreateManyProductoInputEnvelope
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
  }

  export type HospedajeUncheckedCreateNestedOneWithoutProductoInput = {
    create?: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: HospedajeCreateOrConnectWithoutProductoInput
    connect?: HospedajeWhereUniqueInput
  }

  export type PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput> | PaqueteDetalleCreateWithoutPaqueteInput[] | PaqueteDetalleUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutPaqueteInput | PaqueteDetalleCreateOrConnectWithoutPaqueteInput[]
    createMany?: PaqueteDetalleCreateManyPaqueteInputEnvelope
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
  }

  export type PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput> | PaqueteDetalleCreateWithoutProductoInput[] | PaqueteDetalleUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutProductoInput | PaqueteDetalleCreateOrConnectWithoutProductoInput[]
    createMany?: PaqueteDetalleCreateManyProductoInputEnvelope
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
  }

  export type PasajeUncheckedCreateNestedOneWithoutProductoInput = {
    create?: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: PasajeCreateOrConnectWithoutProductoInput
    connect?: PasajeWhereUniqueInput
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlquilerUpdateOneWithoutProductoNestedInput = {
    create?: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AlquilerCreateOrConnectWithoutProductoInput
    upsert?: AlquilerUpsertWithoutProductoInput
    disconnect?: AlquilerWhereInput | boolean
    delete?: AlquilerWhereInput | boolean
    connect?: AlquilerWhereUniqueInput
    update?: XOR<XOR<AlquilerUpdateToOneWithWhereWithoutProductoInput, AlquilerUpdateWithoutProductoInput>, AlquilerUncheckedUpdateWithoutProductoInput>
  }

  export type AutoUpdateOneWithoutProductoNestedInput = {
    create?: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AutoCreateOrConnectWithoutProductoInput
    upsert?: AutoUpsertWithoutProductoInput
    disconnect?: AutoWhereInput | boolean
    delete?: AutoWhereInput | boolean
    connect?: AutoWhereUniqueInput
    update?: XOR<XOR<AutoUpdateToOneWithWhereWithoutProductoInput, AutoUpdateWithoutProductoInput>, AutoUncheckedUpdateWithoutProductoInput>
  }

  export type CarritoItemUpdateManyWithoutProductoNestedInput = {
    create?: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput> | CarritoItemCreateWithoutProductoInput[] | CarritoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutProductoInput | CarritoItemCreateOrConnectWithoutProductoInput[]
    upsert?: CarritoItemUpsertWithWhereUniqueWithoutProductoInput | CarritoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: CarritoItemCreateManyProductoInputEnvelope
    set?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    disconnect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    delete?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    update?: CarritoItemUpdateWithWhereUniqueWithoutProductoInput | CarritoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: CarritoItemUpdateManyWithWhereWithoutProductoInput | CarritoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
  }

  export type HospedajeUpdateOneWithoutProductoNestedInput = {
    create?: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: HospedajeCreateOrConnectWithoutProductoInput
    upsert?: HospedajeUpsertWithoutProductoInput
    disconnect?: HospedajeWhereInput | boolean
    delete?: HospedajeWhereInput | boolean
    connect?: HospedajeWhereUniqueInput
    update?: XOR<XOR<HospedajeUpdateToOneWithWhereWithoutProductoInput, HospedajeUpdateWithoutProductoInput>, HospedajeUncheckedUpdateWithoutProductoInput>
  }

  export type PaqueteDetalleUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput> | PaqueteDetalleCreateWithoutPaqueteInput[] | PaqueteDetalleUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutPaqueteInput | PaqueteDetalleCreateOrConnectWithoutPaqueteInput[]
    upsert?: PaqueteDetalleUpsertWithWhereUniqueWithoutPaqueteInput | PaqueteDetalleUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: PaqueteDetalleCreateManyPaqueteInputEnvelope
    set?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    disconnect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    delete?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    update?: PaqueteDetalleUpdateWithWhereUniqueWithoutPaqueteInput | PaqueteDetalleUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: PaqueteDetalleUpdateManyWithWhereWithoutPaqueteInput | PaqueteDetalleUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
  }

  export type PaqueteDetalleUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput> | PaqueteDetalleCreateWithoutProductoInput[] | PaqueteDetalleUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutProductoInput | PaqueteDetalleCreateOrConnectWithoutProductoInput[]
    upsert?: PaqueteDetalleUpsertWithWhereUniqueWithoutProductoInput | PaqueteDetalleUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PaqueteDetalleCreateManyProductoInputEnvelope
    set?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    disconnect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    delete?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    update?: PaqueteDetalleUpdateWithWhereUniqueWithoutProductoInput | PaqueteDetalleUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PaqueteDetalleUpdateManyWithWhereWithoutProductoInput | PaqueteDetalleUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
  }

  export type PasajeUpdateOneWithoutProductoNestedInput = {
    create?: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: PasajeCreateOrConnectWithoutProductoInput
    upsert?: PasajeUpsertWithoutProductoInput
    disconnect?: PasajeWhereInput | boolean
    delete?: PasajeWhereInput | boolean
    connect?: PasajeWhereUniqueInput
    update?: XOR<XOR<PasajeUpdateToOneWithWhereWithoutProductoInput, PasajeUpdateWithoutProductoInput>, PasajeUncheckedUpdateWithoutProductoInput>
  }

  export type PedidoItemUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProductoInput | PedidoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProductoInput | PedidoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProductoInput | PedidoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type TipoProductoUpdateOneWithoutProductosNestedInput = {
    create?: XOR<TipoProductoCreateWithoutProductosInput, TipoProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: TipoProductoCreateOrConnectWithoutProductosInput
    upsert?: TipoProductoUpsertWithoutProductosInput
    disconnect?: TipoProductoWhereInput | boolean
    delete?: TipoProductoWhereInput | boolean
    connect?: TipoProductoWhereUniqueInput
    update?: XOR<XOR<TipoProductoUpdateToOneWithWhereWithoutProductosInput, TipoProductoUpdateWithoutProductosInput>, TipoProductoUncheckedUpdateWithoutProductosInput>
  }

  export type AlquilerUncheckedUpdateOneWithoutProductoNestedInput = {
    create?: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AlquilerCreateOrConnectWithoutProductoInput
    upsert?: AlquilerUpsertWithoutProductoInput
    disconnect?: AlquilerWhereInput | boolean
    delete?: AlquilerWhereInput | boolean
    connect?: AlquilerWhereUniqueInput
    update?: XOR<XOR<AlquilerUpdateToOneWithWhereWithoutProductoInput, AlquilerUpdateWithoutProductoInput>, AlquilerUncheckedUpdateWithoutProductoInput>
  }

  export type AutoUncheckedUpdateOneWithoutProductoNestedInput = {
    create?: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
    connectOrCreate?: AutoCreateOrConnectWithoutProductoInput
    upsert?: AutoUpsertWithoutProductoInput
    disconnect?: AutoWhereInput | boolean
    delete?: AutoWhereInput | boolean
    connect?: AutoWhereUniqueInput
    update?: XOR<XOR<AutoUpdateToOneWithWhereWithoutProductoInput, AutoUpdateWithoutProductoInput>, AutoUncheckedUpdateWithoutProductoInput>
  }

  export type CarritoItemUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput> | CarritoItemCreateWithoutProductoInput[] | CarritoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutProductoInput | CarritoItemCreateOrConnectWithoutProductoInput[]
    upsert?: CarritoItemUpsertWithWhereUniqueWithoutProductoInput | CarritoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: CarritoItemCreateManyProductoInputEnvelope
    set?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    disconnect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    delete?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    update?: CarritoItemUpdateWithWhereUniqueWithoutProductoInput | CarritoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: CarritoItemUpdateManyWithWhereWithoutProductoInput | CarritoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
  }

  export type HospedajeUncheckedUpdateOneWithoutProductoNestedInput = {
    create?: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: HospedajeCreateOrConnectWithoutProductoInput
    upsert?: HospedajeUpsertWithoutProductoInput
    disconnect?: HospedajeWhereInput | boolean
    delete?: HospedajeWhereInput | boolean
    connect?: HospedajeWhereUniqueInput
    update?: XOR<XOR<HospedajeUpdateToOneWithWhereWithoutProductoInput, HospedajeUpdateWithoutProductoInput>, HospedajeUncheckedUpdateWithoutProductoInput>
  }

  export type PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput> | PaqueteDetalleCreateWithoutPaqueteInput[] | PaqueteDetalleUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutPaqueteInput | PaqueteDetalleCreateOrConnectWithoutPaqueteInput[]
    upsert?: PaqueteDetalleUpsertWithWhereUniqueWithoutPaqueteInput | PaqueteDetalleUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: PaqueteDetalleCreateManyPaqueteInputEnvelope
    set?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    disconnect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    delete?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    update?: PaqueteDetalleUpdateWithWhereUniqueWithoutPaqueteInput | PaqueteDetalleUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: PaqueteDetalleUpdateManyWithWhereWithoutPaqueteInput | PaqueteDetalleUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
  }

  export type PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput> | PaqueteDetalleCreateWithoutProductoInput[] | PaqueteDetalleUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PaqueteDetalleCreateOrConnectWithoutProductoInput | PaqueteDetalleCreateOrConnectWithoutProductoInput[]
    upsert?: PaqueteDetalleUpsertWithWhereUniqueWithoutProductoInput | PaqueteDetalleUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PaqueteDetalleCreateManyProductoInputEnvelope
    set?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    disconnect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    delete?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    connect?: PaqueteDetalleWhereUniqueInput | PaqueteDetalleWhereUniqueInput[]
    update?: PaqueteDetalleUpdateWithWhereUniqueWithoutProductoInput | PaqueteDetalleUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PaqueteDetalleUpdateManyWithWhereWithoutProductoInput | PaqueteDetalleUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
  }

  export type PasajeUncheckedUpdateOneWithoutProductoNestedInput = {
    create?: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
    connectOrCreate?: PasajeCreateOrConnectWithoutProductoInput
    upsert?: PasajeUpsertWithoutProductoInput
    disconnect?: PasajeWhereInput | boolean
    delete?: PasajeWhereInput | boolean
    connect?: PasajeWhereUniqueInput
    update?: XOR<XOR<PasajeUpdateToOneWithWhereWithoutProductoInput, PasajeUpdateWithoutProductoInput>, PasajeUncheckedUpdateWithoutProductoInput>
  }

  export type PedidoItemUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProductoInput | PedidoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProductoInput | PedidoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProductoInput | PedidoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutHospedajeInput = {
    create?: XOR<ProductoCreateWithoutHospedajeInput, ProductoUncheckedCreateWithoutHospedajeInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHospedajeInput
    connect?: ProductoWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProductoUpdateOneRequiredWithoutHospedajeNestedInput = {
    create?: XOR<ProductoCreateWithoutHospedajeInput, ProductoUncheckedCreateWithoutHospedajeInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHospedajeInput
    upsert?: ProductoUpsertWithoutHospedajeInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutHospedajeInput, ProductoUpdateWithoutHospedajeInput>, ProductoUncheckedUpdateWithoutHospedajeInput>
  }

  export type ProductoCreateNestedOneWithoutPasajeInput = {
    create?: XOR<ProductoCreateWithoutPasajeInput, ProductoUncheckedCreateWithoutPasajeInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPasajeInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutPasajeNestedInput = {
    create?: XOR<ProductoCreateWithoutPasajeInput, ProductoUncheckedCreateWithoutPasajeInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPasajeInput
    upsert?: ProductoUpsertWithoutPasajeInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPasajeInput, ProductoUpdateWithoutPasajeInput>, ProductoUncheckedUpdateWithoutPasajeInput>
  }

  export type ProductoCreateNestedOneWithoutAlquilerInput = {
    create?: XOR<ProductoCreateWithoutAlquilerInput, ProductoUncheckedCreateWithoutAlquilerInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutAlquilerInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutAlquilerNestedInput = {
    create?: XOR<ProductoCreateWithoutAlquilerInput, ProductoUncheckedCreateWithoutAlquilerInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutAlquilerInput
    upsert?: ProductoUpsertWithoutAlquilerInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutAlquilerInput, ProductoUpdateWithoutAlquilerInput>, ProductoUncheckedUpdateWithoutAlquilerInput>
  }

  export type ProductoCreateNestedOneWithoutPaqueteDetallesAsPaqueteInput = {
    create?: XOR<ProductoCreateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsPaqueteInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPaqueteDetallesAsPaqueteInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutPaqueteDetallesAsProductoInput = {
    create?: XOR<ProductoCreateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsProductoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPaqueteDetallesAsProductoInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutPaqueteDetallesAsPaqueteNestedInput = {
    create?: XOR<ProductoCreateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsPaqueteInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPaqueteDetallesAsPaqueteInput
    upsert?: ProductoUpsertWithoutPaqueteDetallesAsPaqueteInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPaqueteDetallesAsPaqueteInput, ProductoUpdateWithoutPaqueteDetallesAsPaqueteInput>, ProductoUncheckedUpdateWithoutPaqueteDetallesAsPaqueteInput>
  }

  export type ProductoUpdateOneRequiredWithoutPaqueteDetallesAsProductoNestedInput = {
    create?: XOR<ProductoCreateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsProductoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPaqueteDetallesAsProductoInput
    upsert?: ProductoUpsertWithoutPaqueteDetallesAsProductoInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPaqueteDetallesAsProductoInput, ProductoUpdateWithoutPaqueteDetallesAsProductoInput>, ProductoUncheckedUpdateWithoutPaqueteDetallesAsProductoInput>
  }

  export type ClienteCreateNestedOneWithoutCarritosInput = {
    create?: XOR<ClienteCreateWithoutCarritosInput, ClienteUncheckedCreateWithoutCarritosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCarritosInput
    connect?: ClienteWhereUniqueInput
  }

  export type CarritoItemCreateNestedManyWithoutCarritoInput = {
    create?: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput> | CarritoItemCreateWithoutCarritoInput[] | CarritoItemUncheckedCreateWithoutCarritoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutCarritoInput | CarritoItemCreateOrConnectWithoutCarritoInput[]
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
  }

  export type CarritoItemUncheckedCreateNestedManyWithoutCarritoInput = {
    create?: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput> | CarritoItemCreateWithoutCarritoInput[] | CarritoItemUncheckedCreateWithoutCarritoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutCarritoInput | CarritoItemCreateOrConnectWithoutCarritoInput[]
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
  }

  export type ClienteUpdateOneRequiredWithoutCarritosNestedInput = {
    create?: XOR<ClienteCreateWithoutCarritosInput, ClienteUncheckedCreateWithoutCarritosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCarritosInput
    upsert?: ClienteUpsertWithoutCarritosInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutCarritosInput, ClienteUpdateWithoutCarritosInput>, ClienteUncheckedUpdateWithoutCarritosInput>
  }

  export type CarritoItemUpdateManyWithoutCarritoNestedInput = {
    create?: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput> | CarritoItemCreateWithoutCarritoInput[] | CarritoItemUncheckedCreateWithoutCarritoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutCarritoInput | CarritoItemCreateOrConnectWithoutCarritoInput[]
    upsert?: CarritoItemUpsertWithWhereUniqueWithoutCarritoInput | CarritoItemUpsertWithWhereUniqueWithoutCarritoInput[]
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    set?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    disconnect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    delete?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    update?: CarritoItemUpdateWithWhereUniqueWithoutCarritoInput | CarritoItemUpdateWithWhereUniqueWithoutCarritoInput[]
    updateMany?: CarritoItemUpdateManyWithWhereWithoutCarritoInput | CarritoItemUpdateManyWithWhereWithoutCarritoInput[]
    deleteMany?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
  }

  export type CarritoItemUncheckedUpdateManyWithoutCarritoNestedInput = {
    create?: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput> | CarritoItemCreateWithoutCarritoInput[] | CarritoItemUncheckedCreateWithoutCarritoInput[]
    connectOrCreate?: CarritoItemCreateOrConnectWithoutCarritoInput | CarritoItemCreateOrConnectWithoutCarritoInput[]
    upsert?: CarritoItemUpsertWithWhereUniqueWithoutCarritoInput | CarritoItemUpsertWithWhereUniqueWithoutCarritoInput[]
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    set?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    disconnect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    delete?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    connect?: CarritoItemWhereUniqueInput | CarritoItemWhereUniqueInput[]
    update?: CarritoItemUpdateWithWhereUniqueWithoutCarritoInput | CarritoItemUpdateWithWhereUniqueWithoutCarritoInput[]
    updateMany?: CarritoItemUpdateManyWithWhereWithoutCarritoInput | CarritoItemUpdateManyWithWhereWithoutCarritoInput[]
    deleteMany?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
  }

  export type CarritoCreateNestedOneWithoutItemsInput = {
    create?: XOR<CarritoCreateWithoutItemsInput, CarritoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CarritoCreateOrConnectWithoutItemsInput
    connect?: CarritoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutCarritoItemsInput = {
    create?: XOR<ProductoCreateWithoutCarritoItemsInput, ProductoUncheckedCreateWithoutCarritoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutCarritoItemsInput
    connect?: ProductoWhereUniqueInput
  }

  export type CarritoUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CarritoCreateWithoutItemsInput, CarritoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CarritoCreateOrConnectWithoutItemsInput
    upsert?: CarritoUpsertWithoutItemsInput
    connect?: CarritoWhereUniqueInput
    update?: XOR<XOR<CarritoUpdateToOneWithWhereWithoutItemsInput, CarritoUpdateWithoutItemsInput>, CarritoUncheckedUpdateWithoutItemsInput>
  }

  export type ProductoUpdateOneRequiredWithoutCarritoItemsNestedInput = {
    create?: XOR<ProductoCreateWithoutCarritoItemsInput, ProductoUncheckedCreateWithoutCarritoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutCarritoItemsInput
    upsert?: ProductoUpsertWithoutCarritoItemsInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutCarritoItemsInput, ProductoUpdateWithoutCarritoItemsInput>, ProductoUncheckedUpdateWithoutCarritoItemsInput>
  }

  export type PagoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput> | PagoCreateWithoutPedidoInput[] | PagoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutPedidoInput | PagoCreateOrConnectWithoutPedidoInput[]
    createMany?: PagoCreateManyPedidoInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type ClienteCreateNestedOneWithoutPedidosInput = {
    create?: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidosInput
    connect?: ClienteWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type VentaCreateNestedManyWithoutPedidoInput = {
    create?: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput> | VentaCreateWithoutPedidoInput[] | VentaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: VentaCreateOrConnectWithoutPedidoInput | VentaCreateOrConnectWithoutPedidoInput[]
    createMany?: VentaCreateManyPedidoInputEnvelope
    connect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
  }

  export type PagoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput> | PagoCreateWithoutPedidoInput[] | PagoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutPedidoInput | PagoCreateOrConnectWithoutPedidoInput[]
    createMany?: PagoCreateManyPedidoInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type VentaUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput> | VentaCreateWithoutPedidoInput[] | VentaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: VentaCreateOrConnectWithoutPedidoInput | VentaCreateOrConnectWithoutPedidoInput[]
    createMany?: VentaCreateManyPedidoInputEnvelope
    connect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PagoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput> | PagoCreateWithoutPedidoInput[] | PagoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutPedidoInput | PagoCreateOrConnectWithoutPedidoInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutPedidoInput | PagoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PagoCreateManyPedidoInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutPedidoInput | PagoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutPedidoInput | PagoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type ClienteUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidosInput
    upsert?: ClienteUpsertWithoutPedidosInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutPedidosInput, ClienteUpdateWithoutPedidosInput>, ClienteUncheckedUpdateWithoutPedidosInput>
  }

  export type PedidoItemUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type VentaUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput> | VentaCreateWithoutPedidoInput[] | VentaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: VentaCreateOrConnectWithoutPedidoInput | VentaCreateOrConnectWithoutPedidoInput[]
    upsert?: VentaUpsertWithWhereUniqueWithoutPedidoInput | VentaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: VentaCreateManyPedidoInputEnvelope
    set?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    disconnect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    delete?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    connect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    update?: VentaUpdateWithWhereUniqueWithoutPedidoInput | VentaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: VentaUpdateManyWithWhereWithoutPedidoInput | VentaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: VentaScalarWhereInput | VentaScalarWhereInput[]
  }

  export type PagoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput> | PagoCreateWithoutPedidoInput[] | PagoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutPedidoInput | PagoCreateOrConnectWithoutPedidoInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutPedidoInput | PagoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PagoCreateManyPedidoInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutPedidoInput | PagoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutPedidoInput | PagoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type VentaUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput> | VentaCreateWithoutPedidoInput[] | VentaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: VentaCreateOrConnectWithoutPedidoInput | VentaCreateOrConnectWithoutPedidoInput[]
    upsert?: VentaUpsertWithWhereUniqueWithoutPedidoInput | VentaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: VentaCreateManyPedidoInputEnvelope
    set?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    disconnect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    delete?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    connect?: VentaWhereUniqueInput | VentaWhereUniqueInput[]
    update?: VentaUpdateWithWhereUniqueWithoutPedidoInput | VentaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: VentaUpdateManyWithWhereWithoutPedidoInput | VentaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: VentaScalarWhereInput | VentaScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutItemsInput = {
    create?: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItemsInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutPedidoItemsInput = {
    create?: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidoItemsInput
    connect?: ProductoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItemsInput
    upsert?: PedidoUpsertWithoutItemsInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutItemsInput, PedidoUpdateWithoutItemsInput>, PedidoUncheckedUpdateWithoutItemsInput>
  }

  export type ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput = {
    create?: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidoItemsInput
    upsert?: ProductoUpsertWithoutPedidoItemsInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPedidoItemsInput, ProductoUpdateWithoutPedidoItemsInput>, ProductoUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type PedidoCreateNestedOneWithoutPagosInput = {
    create?: XOR<PedidoCreateWithoutPagosInput, PedidoUncheckedCreateWithoutPagosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPagosInput
    connect?: PedidoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<PedidoCreateWithoutPagosInput, PedidoUncheckedCreateWithoutPagosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPagosInput
    upsert?: PedidoUpsertWithoutPagosInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutPagosInput, PedidoUpdateWithoutPagosInput>, PedidoUncheckedUpdateWithoutPagosInput>
  }

  export type ProductoCreateNestedOneWithoutAutoInput = {
    create?: XOR<ProductoCreateWithoutAutoInput, ProductoUncheckedCreateWithoutAutoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutAutoInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutAutoNestedInput = {
    create?: XOR<ProductoCreateWithoutAutoInput, ProductoUncheckedCreateWithoutAutoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutAutoInput
    upsert?: ProductoUpsertWithoutAutoInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutAutoInput, ProductoUpdateWithoutAutoInput>, ProductoUncheckedUpdateWithoutAutoInput>
  }

  export type PedidoCreateNestedOneWithoutVentasInput = {
    create?: XOR<PedidoCreateWithoutVentasInput, PedidoUncheckedCreateWithoutVentasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutVentasInput
    connect?: PedidoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutVentasNestedInput = {
    create?: XOR<PedidoCreateWithoutVentasInput, PedidoUncheckedCreateWithoutVentasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutVentasInput
    upsert?: PedidoUpsertWithoutVentasInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutVentasInput, PedidoUpdateWithoutVentasInput>, PedidoUncheckedUpdateWithoutVentasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CarritoCreateWithoutClienteInput = {
    fecha_creacion?: Date | string
    items?: CarritoItemCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUncheckedCreateWithoutClienteInput = {
    id_carrito?: number
    fecha_creacion?: Date | string
    items?: CarritoItemUncheckedCreateNestedManyWithoutCarritoInput
  }

  export type CarritoCreateOrConnectWithoutClienteInput = {
    where: CarritoWhereUniqueInput
    create: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput>
  }

  export type CarritoCreateManyClienteInputEnvelope = {
    data: CarritoCreateManyClienteInput | CarritoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutClienteInput = {
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    pagos?: PagoCreateNestedManyWithoutPedidoInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    ventas?: VentaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutClienteInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    pagos?: PagoUncheckedCreateNestedManyWithoutPedidoInput
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ventas?: VentaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoCreateManyClienteInputEnvelope = {
    data: PedidoCreateManyClienteInput | PedidoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type CarritoUpsertWithWhereUniqueWithoutClienteInput = {
    where: CarritoWhereUniqueInput
    update: XOR<CarritoUpdateWithoutClienteInput, CarritoUncheckedUpdateWithoutClienteInput>
    create: XOR<CarritoCreateWithoutClienteInput, CarritoUncheckedCreateWithoutClienteInput>
  }

  export type CarritoUpdateWithWhereUniqueWithoutClienteInput = {
    where: CarritoWhereUniqueInput
    data: XOR<CarritoUpdateWithoutClienteInput, CarritoUncheckedUpdateWithoutClienteInput>
  }

  export type CarritoUpdateManyWithWhereWithoutClienteInput = {
    where: CarritoScalarWhereInput
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyWithoutClienteInput>
  }

  export type CarritoScalarWhereInput = {
    AND?: CarritoScalarWhereInput | CarritoScalarWhereInput[]
    OR?: CarritoScalarWhereInput[]
    NOT?: CarritoScalarWhereInput | CarritoScalarWhereInput[]
    id_carrito?: IntFilter<"Carrito"> | number
    id_cliente?: IntFilter<"Carrito"> | number
    fecha_creacion?: DateTimeFilter<"Carrito"> | Date | string
  }

  export type PedidoUpsertWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
  }

  export type PedidoUpdateManyWithWhereWithoutClienteInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutClienteInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    id_pedido?: IntFilter<"Pedido"> | number
    total?: DecimalFilter<"Pedido"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pedido"> | string
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    id_cliente?: IntFilter<"Pedido"> | number
  }

  export type UsuarioInternoCreateWithoutRolInput = {
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
  }

  export type UsuarioInternoUncheckedCreateWithoutRolInput = {
    id_usuario?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
  }

  export type UsuarioInternoCreateOrConnectWithoutRolInput = {
    where: UsuarioInternoWhereUniqueInput
    create: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput>
  }

  export type UsuarioInternoCreateManyRolInputEnvelope = {
    data: UsuarioInternoCreateManyRolInput | UsuarioInternoCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioInternoUpsertWithWhereUniqueWithoutRolInput = {
    where: UsuarioInternoWhereUniqueInput
    update: XOR<UsuarioInternoUpdateWithoutRolInput, UsuarioInternoUncheckedUpdateWithoutRolInput>
    create: XOR<UsuarioInternoCreateWithoutRolInput, UsuarioInternoUncheckedCreateWithoutRolInput>
  }

  export type UsuarioInternoUpdateWithWhereUniqueWithoutRolInput = {
    where: UsuarioInternoWhereUniqueInput
    data: XOR<UsuarioInternoUpdateWithoutRolInput, UsuarioInternoUncheckedUpdateWithoutRolInput>
  }

  export type UsuarioInternoUpdateManyWithWhereWithoutRolInput = {
    where: UsuarioInternoScalarWhereInput
    data: XOR<UsuarioInternoUpdateManyMutationInput, UsuarioInternoUncheckedUpdateManyWithoutRolInput>
  }

  export type UsuarioInternoScalarWhereInput = {
    AND?: UsuarioInternoScalarWhereInput | UsuarioInternoScalarWhereInput[]
    OR?: UsuarioInternoScalarWhereInput[]
    NOT?: UsuarioInternoScalarWhereInput | UsuarioInternoScalarWhereInput[]
    id_usuario?: IntFilter<"UsuarioInterno"> | number
    nombre?: StringFilter<"UsuarioInterno"> | string
    apellido?: StringNullableFilter<"UsuarioInterno"> | string | null
    email?: StringFilter<"UsuarioInterno"> | string
    contrasena?: StringFilter<"UsuarioInterno"> | string
    telefono?: StringNullableFilter<"UsuarioInterno"> | string | null
    activo?: BoolFilter<"UsuarioInterno"> | boolean
    id_rol?: IntFilter<"UsuarioInterno"> | number
  }

  export type RolCreateWithoutUsuariosInput = {
    nombre: string
    descripcion?: string | null
  }

  export type RolUncheckedCreateWithoutUsuariosInput = {
    id_rol?: number
    nombre: string
    descripcion?: string | null
  }

  export type RolCreateOrConnectWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type RolUpsertWithoutUsuariosInput = {
    update: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateWithoutUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolUncheckedUpdateWithoutUsuariosInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductoCreateWithoutTipoProductoInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutTipoProductoInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutTipoProductoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput>
  }

  export type ProductoCreateManyTipoProductoInputEnvelope = {
    data: ProductoCreateManyTipoProductoInput | ProductoCreateManyTipoProductoInput[]
    skipDuplicates?: boolean
  }

  export type ProductoUpsertWithWhereUniqueWithoutTipoProductoInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutTipoProductoInput, ProductoUncheckedUpdateWithoutTipoProductoInput>
    create: XOR<ProductoCreateWithoutTipoProductoInput, ProductoUncheckedCreateWithoutTipoProductoInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutTipoProductoInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutTipoProductoInput, ProductoUncheckedUpdateWithoutTipoProductoInput>
  }

  export type ProductoUpdateManyWithWhereWithoutTipoProductoInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutTipoProductoInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id_producto?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    tipo?: StringNullableFilter<"Producto"> | string | null
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: FloatFilter<"Producto"> | number
    stock?: IntNullableFilter<"Producto"> | number | null
    activo?: BoolFilter<"Producto"> | boolean
    id_tipo?: IntNullableFilter<"Producto"> | number | null
  }

  export type AlquilerCreateWithoutProductoInput = {
    tipo_vehiculo?: string | null
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    cantidad?: number
  }

  export type AlquilerUncheckedCreateWithoutProductoInput = {
    id_alquiler?: number
    tipo_vehiculo?: string | null
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    cantidad?: number
  }

  export type AlquilerCreateOrConnectWithoutProductoInput = {
    where: AlquilerWhereUniqueInput
    create: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
  }

  export type AutoCreateWithoutProductoInput = {
    modelo?: string | null
    marca?: string | null
    capacidad?: number | null
    ubicacion_actual?: string | null
    estado: string
  }

  export type AutoUncheckedCreateWithoutProductoInput = {
    id_auto?: number
    modelo?: string | null
    marca?: string | null
    capacidad?: number | null
    ubicacion_actual?: string | null
    estado: string
  }

  export type AutoCreateOrConnectWithoutProductoInput = {
    where: AutoWhereUniqueInput
    create: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
  }

  export type CarritoItemCreateWithoutProductoInput = {
    cantidad?: number
    carrito: CarritoCreateNestedOneWithoutItemsInput
  }

  export type CarritoItemUncheckedCreateWithoutProductoInput = {
    id_item?: number
    id_carrito: number
    cantidad?: number
  }

  export type CarritoItemCreateOrConnectWithoutProductoInput = {
    where: CarritoItemWhereUniqueInput
    create: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput>
  }

  export type CarritoItemCreateManyProductoInputEnvelope = {
    data: CarritoItemCreateManyProductoInput | CarritoItemCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type HospedajeCreateWithoutProductoInput = {
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    capacidad?: number | null
  }

  export type HospedajeUncheckedCreateWithoutProductoInput = {
    id_hospedaje?: number
    ubicacion?: string | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    capacidad?: number | null
  }

  export type HospedajeCreateOrConnectWithoutProductoInput = {
    where: HospedajeWhereUniqueInput
    create: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
  }

  export type PaqueteDetalleCreateWithoutPaqueteInput = {
    cantidad?: number
    producto: ProductoCreateNestedOneWithoutPaqueteDetallesAsProductoInput
  }

  export type PaqueteDetalleUncheckedCreateWithoutPaqueteInput = {
    id_detalle?: number
    id_producto: number
    cantidad?: number
  }

  export type PaqueteDetalleCreateOrConnectWithoutPaqueteInput = {
    where: PaqueteDetalleWhereUniqueInput
    create: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput>
  }

  export type PaqueteDetalleCreateManyPaqueteInputEnvelope = {
    data: PaqueteDetalleCreateManyPaqueteInput | PaqueteDetalleCreateManyPaqueteInput[]
    skipDuplicates?: boolean
  }

  export type PaqueteDetalleCreateWithoutProductoInput = {
    cantidad?: number
    paquete: ProductoCreateNestedOneWithoutPaqueteDetallesAsPaqueteInput
  }

  export type PaqueteDetalleUncheckedCreateWithoutProductoInput = {
    id_detalle?: number
    id_paquete: number
    cantidad?: number
  }

  export type PaqueteDetalleCreateOrConnectWithoutProductoInput = {
    where: PaqueteDetalleWhereUniqueInput
    create: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput>
  }

  export type PaqueteDetalleCreateManyProductoInputEnvelope = {
    data: PaqueteDetalleCreateManyProductoInput | PaqueteDetalleCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type PasajeCreateWithoutProductoInput = {
    origen?: string | null
    destino?: string | null
    fecha_salida?: Date | string | null
    fecha_regreso?: Date | string | null
    clase?: string | null
    asientos_disponibles?: number
    aerolinea?: string | null
  }

  export type PasajeUncheckedCreateWithoutProductoInput = {
    id_pasaje?: number
    origen?: string | null
    destino?: string | null
    fecha_salida?: Date | string | null
    fecha_regreso?: Date | string | null
    clase?: string | null
    asientos_disponibles?: number
    aerolinea?: string | null
  }

  export type PasajeCreateOrConnectWithoutProductoInput = {
    where: PasajeWhereUniqueInput
    create: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
  }

  export type PedidoItemCreateWithoutProductoInput = {
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    pedido: PedidoCreateNestedOneWithoutItemsInput
  }

  export type PedidoItemUncheckedCreateWithoutProductoInput = {
    id_detalle?: number
    id_pedido: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemCreateOrConnectWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput>
  }

  export type PedidoItemCreateManyProductoInputEnvelope = {
    data: PedidoItemCreateManyProductoInput | PedidoItemCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type TipoProductoCreateWithoutProductosInput = {
    nombre: string
    descripcion?: string | null
  }

  export type TipoProductoUncheckedCreateWithoutProductosInput = {
    id_tipo?: number
    nombre: string
    descripcion?: string | null
  }

  export type TipoProductoCreateOrConnectWithoutProductosInput = {
    where: TipoProductoWhereUniqueInput
    create: XOR<TipoProductoCreateWithoutProductosInput, TipoProductoUncheckedCreateWithoutProductosInput>
  }

  export type AlquilerUpsertWithoutProductoInput = {
    update: XOR<AlquilerUpdateWithoutProductoInput, AlquilerUncheckedUpdateWithoutProductoInput>
    create: XOR<AlquilerCreateWithoutProductoInput, AlquilerUncheckedCreateWithoutProductoInput>
    where?: AlquilerWhereInput
  }

  export type AlquilerUpdateToOneWithWhereWithoutProductoInput = {
    where?: AlquilerWhereInput
    data: XOR<AlquilerUpdateWithoutProductoInput, AlquilerUncheckedUpdateWithoutProductoInput>
  }

  export type AlquilerUpdateWithoutProductoInput = {
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type AlquilerUncheckedUpdateWithoutProductoInput = {
    id_alquiler?: IntFieldUpdateOperationsInput | number
    tipo_vehiculo?: NullableStringFieldUpdateOperationsInput | string | null
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type AutoUpsertWithoutProductoInput = {
    update: XOR<AutoUpdateWithoutProductoInput, AutoUncheckedUpdateWithoutProductoInput>
    create: XOR<AutoCreateWithoutProductoInput, AutoUncheckedCreateWithoutProductoInput>
    where?: AutoWhereInput
  }

  export type AutoUpdateToOneWithWhereWithoutProductoInput = {
    where?: AutoWhereInput
    data: XOR<AutoUpdateWithoutProductoInput, AutoUncheckedUpdateWithoutProductoInput>
  }

  export type AutoUpdateWithoutProductoInput = {
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AutoUncheckedUpdateWithoutProductoInput = {
    id_auto?: IntFieldUpdateOperationsInput | number
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
    ubicacion_actual?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type CarritoItemUpsertWithWhereUniqueWithoutProductoInput = {
    where: CarritoItemWhereUniqueInput
    update: XOR<CarritoItemUpdateWithoutProductoInput, CarritoItemUncheckedUpdateWithoutProductoInput>
    create: XOR<CarritoItemCreateWithoutProductoInput, CarritoItemUncheckedCreateWithoutProductoInput>
  }

  export type CarritoItemUpdateWithWhereUniqueWithoutProductoInput = {
    where: CarritoItemWhereUniqueInput
    data: XOR<CarritoItemUpdateWithoutProductoInput, CarritoItemUncheckedUpdateWithoutProductoInput>
  }

  export type CarritoItemUpdateManyWithWhereWithoutProductoInput = {
    where: CarritoItemScalarWhereInput
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyWithoutProductoInput>
  }

  export type CarritoItemScalarWhereInput = {
    AND?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
    OR?: CarritoItemScalarWhereInput[]
    NOT?: CarritoItemScalarWhereInput | CarritoItemScalarWhereInput[]
    id_item?: IntFilter<"CarritoItem"> | number
    id_carrito?: IntFilter<"CarritoItem"> | number
    id_producto?: IntFilter<"CarritoItem"> | number
    cantidad?: IntFilter<"CarritoItem"> | number
  }

  export type HospedajeUpsertWithoutProductoInput = {
    update: XOR<HospedajeUpdateWithoutProductoInput, HospedajeUncheckedUpdateWithoutProductoInput>
    create: XOR<HospedajeCreateWithoutProductoInput, HospedajeUncheckedCreateWithoutProductoInput>
    where?: HospedajeWhereInput
  }

  export type HospedajeUpdateToOneWithWhereWithoutProductoInput = {
    where?: HospedajeWhereInput
    data: XOR<HospedajeUpdateWithoutProductoInput, HospedajeUncheckedUpdateWithoutProductoInput>
  }

  export type HospedajeUpdateWithoutProductoInput = {
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HospedajeUncheckedUpdateWithoutProductoInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    ubicacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capacidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaqueteDetalleUpsertWithWhereUniqueWithoutPaqueteInput = {
    where: PaqueteDetalleWhereUniqueInput
    update: XOR<PaqueteDetalleUpdateWithoutPaqueteInput, PaqueteDetalleUncheckedUpdateWithoutPaqueteInput>
    create: XOR<PaqueteDetalleCreateWithoutPaqueteInput, PaqueteDetalleUncheckedCreateWithoutPaqueteInput>
  }

  export type PaqueteDetalleUpdateWithWhereUniqueWithoutPaqueteInput = {
    where: PaqueteDetalleWhereUniqueInput
    data: XOR<PaqueteDetalleUpdateWithoutPaqueteInput, PaqueteDetalleUncheckedUpdateWithoutPaqueteInput>
  }

  export type PaqueteDetalleUpdateManyWithWhereWithoutPaqueteInput = {
    where: PaqueteDetalleScalarWhereInput
    data: XOR<PaqueteDetalleUpdateManyMutationInput, PaqueteDetalleUncheckedUpdateManyWithoutPaqueteInput>
  }

  export type PaqueteDetalleScalarWhereInput = {
    AND?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
    OR?: PaqueteDetalleScalarWhereInput[]
    NOT?: PaqueteDetalleScalarWhereInput | PaqueteDetalleScalarWhereInput[]
    id_detalle?: IntFilter<"PaqueteDetalle"> | number
    id_paquete?: IntFilter<"PaqueteDetalle"> | number
    id_producto?: IntFilter<"PaqueteDetalle"> | number
    cantidad?: IntFilter<"PaqueteDetalle"> | number
  }

  export type PaqueteDetalleUpsertWithWhereUniqueWithoutProductoInput = {
    where: PaqueteDetalleWhereUniqueInput
    update: XOR<PaqueteDetalleUpdateWithoutProductoInput, PaqueteDetalleUncheckedUpdateWithoutProductoInput>
    create: XOR<PaqueteDetalleCreateWithoutProductoInput, PaqueteDetalleUncheckedCreateWithoutProductoInput>
  }

  export type PaqueteDetalleUpdateWithWhereUniqueWithoutProductoInput = {
    where: PaqueteDetalleWhereUniqueInput
    data: XOR<PaqueteDetalleUpdateWithoutProductoInput, PaqueteDetalleUncheckedUpdateWithoutProductoInput>
  }

  export type PaqueteDetalleUpdateManyWithWhereWithoutProductoInput = {
    where: PaqueteDetalleScalarWhereInput
    data: XOR<PaqueteDetalleUpdateManyMutationInput, PaqueteDetalleUncheckedUpdateManyWithoutProductoInput>
  }

  export type PasajeUpsertWithoutProductoInput = {
    update: XOR<PasajeUpdateWithoutProductoInput, PasajeUncheckedUpdateWithoutProductoInput>
    create: XOR<PasajeCreateWithoutProductoInput, PasajeUncheckedCreateWithoutProductoInput>
    where?: PasajeWhereInput
  }

  export type PasajeUpdateToOneWithWhereWithoutProductoInput = {
    where?: PasajeWhereInput
    data: XOR<PasajeUpdateWithoutProductoInput, PasajeUncheckedUpdateWithoutProductoInput>
  }

  export type PasajeUpdateWithoutProductoInput = {
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasajeUncheckedUpdateWithoutProductoInput = {
    id_pasaje?: IntFieldUpdateOperationsInput | number
    origen?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_regreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clase?: NullableStringFieldUpdateOperationsInput | string | null
    asientos_disponibles?: IntFieldUpdateOperationsInput | number
    aerolinea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutProductoInput, PedidoItemUncheckedUpdateWithoutProductoInput>
    create: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutProductoInput, PedidoItemUncheckedUpdateWithoutProductoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutProductoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutProductoInput>
  }

  export type PedidoItemScalarWhereInput = {
    AND?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    OR?: PedidoItemScalarWhereInput[]
    NOT?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    id_detalle?: IntFilter<"PedidoItem"> | number
    id_pedido?: IntFilter<"PedidoItem"> | number
    id_producto?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    precio?: DecimalFilter<"PedidoItem"> | Decimal | DecimalJsLike | number | string
  }

  export type TipoProductoUpsertWithoutProductosInput = {
    update: XOR<TipoProductoUpdateWithoutProductosInput, TipoProductoUncheckedUpdateWithoutProductosInput>
    create: XOR<TipoProductoCreateWithoutProductosInput, TipoProductoUncheckedCreateWithoutProductosInput>
    where?: TipoProductoWhereInput
  }

  export type TipoProductoUpdateToOneWithWhereWithoutProductosInput = {
    where?: TipoProductoWhereInput
    data: XOR<TipoProductoUpdateWithoutProductosInput, TipoProductoUncheckedUpdateWithoutProductosInput>
  }

  export type TipoProductoUpdateWithoutProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TipoProductoUncheckedUpdateWithoutProductosInput = {
    id_tipo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductoCreateWithoutHospedajeInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutHospedajeInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutHospedajeInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutHospedajeInput, ProductoUncheckedCreateWithoutHospedajeInput>
  }

  export type ProductoUpsertWithoutHospedajeInput = {
    update: XOR<ProductoUpdateWithoutHospedajeInput, ProductoUncheckedUpdateWithoutHospedajeInput>
    create: XOR<ProductoCreateWithoutHospedajeInput, ProductoUncheckedCreateWithoutHospedajeInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutHospedajeInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutHospedajeInput, ProductoUncheckedUpdateWithoutHospedajeInput>
  }

  export type ProductoUpdateWithoutHospedajeInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutHospedajeInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateWithoutPasajeInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutPasajeInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutPasajeInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPasajeInput, ProductoUncheckedCreateWithoutPasajeInput>
  }

  export type ProductoUpsertWithoutPasajeInput = {
    update: XOR<ProductoUpdateWithoutPasajeInput, ProductoUncheckedUpdateWithoutPasajeInput>
    create: XOR<ProductoCreateWithoutPasajeInput, ProductoUncheckedCreateWithoutPasajeInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPasajeInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPasajeInput, ProductoUncheckedUpdateWithoutPasajeInput>
  }

  export type ProductoUpdateWithoutPasajeInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPasajeInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateWithoutAlquilerInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutAlquilerInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutAlquilerInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutAlquilerInput, ProductoUncheckedCreateWithoutAlquilerInput>
  }

  export type ProductoUpsertWithoutAlquilerInput = {
    update: XOR<ProductoUpdateWithoutAlquilerInput, ProductoUncheckedUpdateWithoutAlquilerInput>
    create: XOR<ProductoCreateWithoutAlquilerInput, ProductoUncheckedCreateWithoutAlquilerInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutAlquilerInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutAlquilerInput, ProductoUncheckedUpdateWithoutAlquilerInput>
  }

  export type ProductoUpdateWithoutAlquilerInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutAlquilerInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateWithoutPaqueteDetallesAsPaqueteInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutPaqueteDetallesAsPaqueteInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutPaqueteDetallesAsPaqueteInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsPaqueteInput>
  }

  export type ProductoCreateWithoutPaqueteDetallesAsProductoInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutPaqueteDetallesAsProductoInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutPaqueteDetallesAsProductoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsProductoInput>
  }

  export type ProductoUpsertWithoutPaqueteDetallesAsPaqueteInput = {
    update: XOR<ProductoUpdateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedUpdateWithoutPaqueteDetallesAsPaqueteInput>
    create: XOR<ProductoCreateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsPaqueteInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPaqueteDetallesAsPaqueteInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPaqueteDetallesAsPaqueteInput, ProductoUncheckedUpdateWithoutPaqueteDetallesAsPaqueteInput>
  }

  export type ProductoUpdateWithoutPaqueteDetallesAsPaqueteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPaqueteDetallesAsPaqueteInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUpsertWithoutPaqueteDetallesAsProductoInput = {
    update: XOR<ProductoUpdateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedUpdateWithoutPaqueteDetallesAsProductoInput>
    create: XOR<ProductoCreateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedCreateWithoutPaqueteDetallesAsProductoInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPaqueteDetallesAsProductoInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPaqueteDetallesAsProductoInput, ProductoUncheckedUpdateWithoutPaqueteDetallesAsProductoInput>
  }

  export type ProductoUpdateWithoutPaqueteDetallesAsProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPaqueteDetallesAsProductoInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ClienteCreateWithoutCarritosInput = {
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutCarritosInput = {
    id_cliente?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutCarritosInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutCarritosInput, ClienteUncheckedCreateWithoutCarritosInput>
  }

  export type CarritoItemCreateWithoutCarritoInput = {
    cantidad?: number
    producto: ProductoCreateNestedOneWithoutCarritoItemsInput
  }

  export type CarritoItemUncheckedCreateWithoutCarritoInput = {
    id_item?: number
    id_producto: number
    cantidad?: number
  }

  export type CarritoItemCreateOrConnectWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    create: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput>
  }

  export type CarritoItemCreateManyCarritoInputEnvelope = {
    data: CarritoItemCreateManyCarritoInput | CarritoItemCreateManyCarritoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithoutCarritosInput = {
    update: XOR<ClienteUpdateWithoutCarritosInput, ClienteUncheckedUpdateWithoutCarritosInput>
    create: XOR<ClienteCreateWithoutCarritosInput, ClienteUncheckedCreateWithoutCarritosInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutCarritosInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutCarritosInput, ClienteUncheckedUpdateWithoutCarritosInput>
  }

  export type ClienteUpdateWithoutCarritosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutCarritosInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type CarritoItemUpsertWithWhereUniqueWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    update: XOR<CarritoItemUpdateWithoutCarritoInput, CarritoItemUncheckedUpdateWithoutCarritoInput>
    create: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput>
  }

  export type CarritoItemUpdateWithWhereUniqueWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    data: XOR<CarritoItemUpdateWithoutCarritoInput, CarritoItemUncheckedUpdateWithoutCarritoInput>
  }

  export type CarritoItemUpdateManyWithWhereWithoutCarritoInput = {
    where: CarritoItemScalarWhereInput
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyWithoutCarritoInput>
  }

  export type CarritoCreateWithoutItemsInput = {
    fecha_creacion?: Date | string
    cliente: ClienteCreateNestedOneWithoutCarritosInput
  }

  export type CarritoUncheckedCreateWithoutItemsInput = {
    id_carrito?: number
    id_cliente: number
    fecha_creacion?: Date | string
  }

  export type CarritoCreateOrConnectWithoutItemsInput = {
    where: CarritoWhereUniqueInput
    create: XOR<CarritoCreateWithoutItemsInput, CarritoUncheckedCreateWithoutItemsInput>
  }

  export type ProductoCreateWithoutCarritoItemsInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutCarritoItemsInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutCarritoItemsInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutCarritoItemsInput, ProductoUncheckedCreateWithoutCarritoItemsInput>
  }

  export type CarritoUpsertWithoutItemsInput = {
    update: XOR<CarritoUpdateWithoutItemsInput, CarritoUncheckedUpdateWithoutItemsInput>
    create: XOR<CarritoCreateWithoutItemsInput, CarritoUncheckedCreateWithoutItemsInput>
    where?: CarritoWhereInput
  }

  export type CarritoUpdateToOneWithWhereWithoutItemsInput = {
    where?: CarritoWhereInput
    data: XOR<CarritoUpdateWithoutItemsInput, CarritoUncheckedUpdateWithoutItemsInput>
  }

  export type CarritoUpdateWithoutItemsInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutCarritosNestedInput
  }

  export type CarritoUncheckedUpdateWithoutItemsInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoUpsertWithoutCarritoItemsInput = {
    update: XOR<ProductoUpdateWithoutCarritoItemsInput, ProductoUncheckedUpdateWithoutCarritoItemsInput>
    create: XOR<ProductoCreateWithoutCarritoItemsInput, ProductoUncheckedCreateWithoutCarritoItemsInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutCarritoItemsInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutCarritoItemsInput, ProductoUncheckedUpdateWithoutCarritoItemsInput>
  }

  export type ProductoUpdateWithoutCarritoItemsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutCarritoItemsInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type PagoCreateWithoutPedidoInput = {
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
  }

  export type PagoUncheckedCreateWithoutPedidoInput = {
    id_pago?: number
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
  }

  export type PagoCreateOrConnectWithoutPedidoInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput>
  }

  export type PagoCreateManyPedidoInputEnvelope = {
    data: PagoCreateManyPedidoInput | PagoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteCreateWithoutPedidosInput = {
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    carritos?: CarritoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutPedidosInput = {
    id_cliente?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    fecha_registro?: Date | string
    activo?: boolean
    email_verificado?: boolean
    token_verificacion_email?: string | null
    carritos?: CarritoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutPedidosInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoItemCreateWithoutPedidoInput = {
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    producto: ProductoCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateWithoutPedidoInput = {
    id_detalle?: number
    id_producto: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemCreateOrConnectWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemCreateManyPedidoInputEnvelope = {
    data: PedidoItemCreateManyPedidoInput | PedidoItemCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type VentaCreateWithoutPedidoInput = {
    monto: number
    fecha: Date | string
  }

  export type VentaUncheckedCreateWithoutPedidoInput = {
    id?: number
    monto: number
    fecha: Date | string
  }

  export type VentaCreateOrConnectWithoutPedidoInput = {
    where: VentaWhereUniqueInput
    create: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput>
  }

  export type VentaCreateManyPedidoInputEnvelope = {
    data: VentaCreateManyPedidoInput | VentaCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type PagoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PagoWhereUniqueInput
    update: XOR<PagoUpdateWithoutPedidoInput, PagoUncheckedUpdateWithoutPedidoInput>
    create: XOR<PagoCreateWithoutPedidoInput, PagoUncheckedCreateWithoutPedidoInput>
  }

  export type PagoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PagoWhereUniqueInput
    data: XOR<PagoUpdateWithoutPedidoInput, PagoUncheckedUpdateWithoutPedidoInput>
  }

  export type PagoUpdateManyWithWhereWithoutPedidoInput = {
    where: PagoScalarWhereInput
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type PagoScalarWhereInput = {
    AND?: PagoScalarWhereInput | PagoScalarWhereInput[]
    OR?: PagoScalarWhereInput[]
    NOT?: PagoScalarWhereInput | PagoScalarWhereInput[]
    id_pago?: IntFilter<"Pago"> | number
    id_pedido?: IntFilter<"Pago"> | number
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    metodo?: StringNullableFilter<"Pago"> | string | null
    estado?: StringFilter<"Pago"> | string
  }

  export type ClienteUpsertWithoutPedidosInput = {
    update: XOR<ClienteUpdateWithoutPedidosInput, ClienteUncheckedUpdateWithoutPedidosInput>
    create: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutPedidosInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutPedidosInput, ClienteUncheckedUpdateWithoutPedidosInput>
  }

  export type ClienteUpdateWithoutPedidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    carritos?: CarritoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutPedidosInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    email_verificado?: BoolFieldUpdateOperationsInput | boolean
    token_verificacion_email?: NullableStringFieldUpdateOperationsInput | string | null
    carritos?: CarritoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutPedidoInput>
  }

  export type VentaUpsertWithWhereUniqueWithoutPedidoInput = {
    where: VentaWhereUniqueInput
    update: XOR<VentaUpdateWithoutPedidoInput, VentaUncheckedUpdateWithoutPedidoInput>
    create: XOR<VentaCreateWithoutPedidoInput, VentaUncheckedCreateWithoutPedidoInput>
  }

  export type VentaUpdateWithWhereUniqueWithoutPedidoInput = {
    where: VentaWhereUniqueInput
    data: XOR<VentaUpdateWithoutPedidoInput, VentaUncheckedUpdateWithoutPedidoInput>
  }

  export type VentaUpdateManyWithWhereWithoutPedidoInput = {
    where: VentaScalarWhereInput
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyWithoutPedidoInput>
  }

  export type VentaScalarWhereInput = {
    AND?: VentaScalarWhereInput | VentaScalarWhereInput[]
    OR?: VentaScalarWhereInput[]
    NOT?: VentaScalarWhereInput | VentaScalarWhereInput[]
    id?: IntFilter<"Venta"> | number
    pedidoId?: IntFilter<"Venta"> | number
    monto?: FloatFilter<"Venta"> | number
    fecha?: DateTimeFilter<"Venta"> | Date | string
  }

  export type PedidoCreateWithoutItemsInput = {
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    pagos?: PagoCreateNestedManyWithoutPedidoInput
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    ventas?: VentaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutItemsInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    id_cliente: number
    pagos?: PagoUncheckedCreateNestedManyWithoutPedidoInput
    ventas?: VentaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutItemsInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
  }

  export type ProductoCreateWithoutPedidoItemsInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    Auto?: AutoCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutPedidoItemsInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    Auto?: AutoUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutPedidoItemsInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
  }

  export type PedidoUpsertWithoutItemsInput = {
    update: XOR<PedidoUpdateWithoutItemsInput, PedidoUncheckedUpdateWithoutItemsInput>
    create: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutItemsInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutItemsInput, PedidoUncheckedUpdateWithoutItemsInput>
  }

  export type PedidoUpdateWithoutItemsInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUpdateManyWithoutPedidoNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    ventas?: VentaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutItemsInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    pagos?: PagoUncheckedUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProductoUpsertWithoutPedidoItemsInput = {
    update: XOR<ProductoUpdateWithoutPedidoItemsInput, ProductoUncheckedUpdateWithoutPedidoItemsInput>
    create: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPedidoItemsInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPedidoItemsInput, ProductoUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type ProductoUpdateWithoutPedidoItemsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPedidoItemsInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
  }

  export type PedidoCreateWithoutPagosInput = {
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    ventas?: VentaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutPagosInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    id_cliente: number
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ventas?: VentaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutPagosInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutPagosInput, PedidoUncheckedCreateWithoutPagosInput>
  }

  export type PedidoUpsertWithoutPagosInput = {
    update: XOR<PedidoUpdateWithoutPagosInput, PedidoUncheckedUpdateWithoutPagosInput>
    create: XOR<PedidoCreateWithoutPagosInput, PedidoUncheckedCreateWithoutPagosInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutPagosInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutPagosInput, PedidoUncheckedUpdateWithoutPagosInput>
  }

  export type PedidoUpdateWithoutPagosInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutPagosInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProductoCreateWithoutAutoInput = {
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    alquiler?: AlquilerCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleCreateNestedManyWithoutProductoInput
    pasaje?: PasajeCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    tipoProducto?: TipoProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutAutoInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
    id_tipo?: number | null
    alquiler?: AlquilerUncheckedCreateNestedOneWithoutProductoInput
    carritoItems?: CarritoItemUncheckedCreateNestedManyWithoutProductoInput
    hospedaje?: HospedajeUncheckedCreateNestedOneWithoutProductoInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedCreateNestedManyWithoutPaqueteInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedCreateNestedManyWithoutProductoInput
    pasaje?: PasajeUncheckedCreateNestedOneWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutAutoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutAutoInput, ProductoUncheckedCreateWithoutAutoInput>
  }

  export type ProductoUpsertWithoutAutoInput = {
    update: XOR<ProductoUpdateWithoutAutoInput, ProductoUncheckedUpdateWithoutAutoInput>
    create: XOR<ProductoCreateWithoutAutoInput, ProductoUncheckedCreateWithoutAutoInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutAutoInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutAutoInput, ProductoUncheckedUpdateWithoutAutoInput>
  }

  export type ProductoUpdateWithoutAutoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    tipoProducto?: TipoProductoUpdateOneWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutAutoInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    id_tipo?: NullableIntFieldUpdateOperationsInput | number | null
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type PedidoCreateWithoutVentasInput = {
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    pagos?: PagoCreateNestedManyWithoutPedidoInput
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutVentasInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
    id_cliente: number
    pagos?: PagoUncheckedCreateNestedManyWithoutPedidoInput
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutVentasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutVentasInput, PedidoUncheckedCreateWithoutVentasInput>
  }

  export type PedidoUpsertWithoutVentasInput = {
    update: XOR<PedidoUpdateWithoutVentasInput, PedidoUncheckedUpdateWithoutVentasInput>
    create: XOR<PedidoCreateWithoutVentasInput, PedidoUncheckedCreateWithoutVentasInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutVentasInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutVentasInput, PedidoUncheckedUpdateWithoutVentasInput>
  }

  export type PedidoUpdateWithoutVentasInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUpdateManyWithoutPedidoNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutVentasInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    pagos?: PagoUncheckedUpdateManyWithoutPedidoNestedInput
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type CarritoCreateManyClienteInput = {
    id_carrito?: number
    fecha_creacion?: Date | string
  }

  export type PedidoCreateManyClienteInput = {
    id_pedido?: number
    total: Decimal | DecimalJsLike | number | string
    estado: string
    fecha_pedido?: Date | string
  }

  export type CarritoUpdateWithoutClienteInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CarritoItemUpdateManyWithoutCarritoNestedInput
  }

  export type CarritoUncheckedUpdateWithoutClienteInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CarritoItemUncheckedUpdateManyWithoutCarritoNestedInput
  }

  export type CarritoUncheckedUpdateManyWithoutClienteInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpdateWithoutClienteInput = {
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUpdateManyWithoutPedidoNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutClienteInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUncheckedUpdateManyWithoutPedidoNestedInput
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ventas?: VentaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutClienteInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioInternoCreateManyRolInput = {
    id_usuario?: number
    nombre: string
    apellido?: string | null
    email: string
    contrasena: string
    telefono?: string | null
    activo?: boolean
  }

  export type UsuarioInternoUpdateWithoutRolInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioInternoUncheckedUpdateWithoutRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioInternoUncheckedUpdateManyWithoutRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoCreateManyTipoProductoInput = {
    id_producto?: number
    nombre: string
    tipo?: string | null
    descripcion?: string | null
    precio: number
    stock?: number | null
    activo?: boolean
  }

  export type ProductoUpdateWithoutTipoProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUpdateOneWithoutProductoNestedInput
    Auto?: AutoUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutTipoProductoInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    alquiler?: AlquilerUncheckedUpdateOneWithoutProductoNestedInput
    Auto?: AutoUncheckedUpdateOneWithoutProductoNestedInput
    carritoItems?: CarritoItemUncheckedUpdateManyWithoutProductoNestedInput
    hospedaje?: HospedajeUncheckedUpdateOneWithoutProductoNestedInput
    paqueteDetallesAsPaquete?: PaqueteDetalleUncheckedUpdateManyWithoutPaqueteNestedInput
    paqueteDetallesAsProducto?: PaqueteDetalleUncheckedUpdateManyWithoutProductoNestedInput
    pasaje?: PasajeUncheckedUpdateOneWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutTipoProductoInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: FloatFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CarritoItemCreateManyProductoInput = {
    id_item?: number
    id_carrito: number
    cantidad?: number
  }

  export type PaqueteDetalleCreateManyPaqueteInput = {
    id_detalle?: number
    id_producto: number
    cantidad?: number
  }

  export type PaqueteDetalleCreateManyProductoInput = {
    id_detalle?: number
    id_paquete: number
    cantidad?: number
  }

  export type PedidoItemCreateManyProductoInput = {
    id_detalle?: number
    id_pedido: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type CarritoItemUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    carrito?: CarritoUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CarritoItemUncheckedUpdateWithoutProductoInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_carrito?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemUncheckedUpdateManyWithoutProductoInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_carrito?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleUpdateWithoutPaqueteInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutPaqueteDetallesAsProductoNestedInput
  }

  export type PaqueteDetalleUncheckedUpdateWithoutPaqueteInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleUncheckedUpdateManyWithoutPaqueteInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    paquete?: ProductoUpdateOneRequiredWithoutPaqueteDetallesAsPaqueteNestedInput
  }

  export type PaqueteDetalleUncheckedUpdateWithoutProductoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteDetalleUncheckedUpdateManyWithoutProductoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoItemUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pedido?: PedidoUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutProductoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemUncheckedUpdateManyWithoutProductoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CarritoItemCreateManyCarritoInput = {
    id_item?: number
    id_producto: number
    cantidad?: number
  }

  export type CarritoItemUpdateWithoutCarritoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutCarritoItemsNestedInput
  }

  export type CarritoItemUncheckedUpdateWithoutCarritoInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemUncheckedUpdateManyWithoutCarritoInput = {
    id_item?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PagoCreateManyPedidoInput = {
    id_pago?: number
    fecha_pago?: Date | string
    monto: Decimal | DecimalJsLike | number | string
    metodo?: string | null
    estado: string
  }

  export type PedidoItemCreateManyPedidoInput = {
    id_detalle?: number
    id_producto: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type VentaCreateManyPedidoInput = {
    id?: number
    monto: number
    fecha: Date | string
  }

  export type PagoUpdateWithoutPedidoInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type PagoUncheckedUpdateWithoutPedidoInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type PagoUncheckedUpdateManyWithoutPedidoInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoItemUpdateWithoutPedidoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    producto?: ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutPedidoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VentaUpdateWithoutPedidoInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentaUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentaUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}